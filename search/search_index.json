{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Documentation for scVIDR","text":"<p>This site provides comprehensive information about the scVIDR package, including installation instructions, API reference, and tutorials.</p> <p>To get started with scVIDR, follow the instructions in the Getting Started Guide. It will walk you through the installation process and help you set up the project on your local machine.</p>"},{"location":"#overview","title":"Overview","text":"<p>scVIDR (Single Cell Variational Inference of Dose Response) is designed to help you analyze dose-response relationships in single-cell data. This documentation covers:</p> <ul> <li>Installation </li> <li>API Reference </li> <li>Tutorials </li> </ul>"},{"location":"API/API-introduction/","title":"API Introduction","text":"<p>This section provides an overview of the VIDR API, which contains technical descriptions and factual information about the system, APIs, parameters, and more.  </p>"},{"location":"API/API-introduction/#modules","title":"Modules","text":"<ul> <li>Utils</li> <li>PCAEval</li> <li>Modules </li> </ul>"},{"location":"API/PCAEval/","title":"PCAEval Class and Associated Methods in PCAEval.py","text":""},{"location":"API/PCAEval/#pcaeval","title":"PCAEval","text":""},{"location":"API/PCAEval/#pcaeval_1","title":"PCAEval","text":"<p>Implementation of scGen model for batch removal and perturbation prediction.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object that has been registered via <code>scgen.setup_anndata</code>.</p> required <code>hidden_dim</code> <code>int</code> <p>Number of nodes per hidden layer.</p> required <code>latent_dim</code> <code>int</code> <p>Dimensionality of the latent space.</p> <code>100</code> <code>n_layers</code> <code>int</code> <p>Number of hidden layers used for encoder and decoder NNs.</p> required <code>dropout_rate</code> <code>float</code> <p>Dropout rate for neural networks.</p> required <code>**model_kwargs</code> <p>Additional keyword arguments for <code>scgen.SCGENVAE</code>.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; vae = scgen.SCGEN(adata)\n&gt;&gt;&gt; vae.train()\n&gt;&gt;&gt; adata.obsm[\"X_scgen\"] = vae.get_latent_representation()\n</code></pre> Source code in <code>vidr/PCAEval.py</code> <pre><code>class PCAEval:\n    '''\n    Implementation of scGen model for batch removal and perturbation prediction.\n\n    Args:\n        adata (AnnData): \n            An AnnData object that has been registered via `scgen.setup_anndata`.\n        hidden_dim (int): \n            Number of nodes per hidden layer.\n        latent_dim (int): \n            Dimensionality of the latent space.\n        n_layers (int): \n            Number of hidden layers used for encoder and decoder NNs.\n        dropout_rate (float): \n            Dropout rate for neural networks.\n        **model_kwargs: \n            Additional keyword arguments for `scgen.SCGENVAE`.\n\n    Examples:\n        &gt;&gt;&gt; vae = scgen.SCGEN(adata)\n        &gt;&gt;&gt; vae.train()\n        &gt;&gt;&gt; adata.obsm[\"X_scgen\"] = vae.get_latent_representation()\n\n    '''\n\n    def __init__(\n        self,\n        adata: AnnData,\n        latent_dim: int = 100,\n    ):\n        super(PCAEval, self).__init__()\n        self.adata = adata\n\n        self.pca = PCA(n_components=latent_dim, svd_solver=\"arpack\")\n        if sparse.issparse(self.adata.X):\n            self.adata.X = self.adata.X.A\n\n        self.pca.fit(adata.X)\n\n        self._model_summary_string = (\n            \"PCA Model with the following params: \\n latent_dim: {}\"\n        ).format(\n            latent_dim,\n        )\n\n    def predict(\n        self,\n        cell_type_key=None,\n        treatment_key=None,\n        ctrl_key=None,\n        treat_key=None,\n        cell_type_to_predict=None,\n        regression=False,\n        continuous=False,\n        doses=None,\n    ) -&gt; AnnData:\n        '''\n        Predicts the cell type provided by the user in the treated condition.\n\n        Args:\n            cell_type_key (str, optional): \n                Key for the cell type information in `adata.obs`. Defaults to None.\n            treatment_key (str, optional): \n                Key for the treatment or condition information in `adata.obs`. Defaults to None.\n            ctrl_key (str, optional): \n                Key for the control condition in `treatment_key`. Defaults to None.\n            treat_key (str, optional): \n                Key for the treated condition in `treatment_key`. Defaults to None.\n            cell_type_to_predict (str, optional): \n                The cell type to be predicted. Defaults to None.\n            regression (bool, optional): \n                Whether to perform regression on the latent space. Defaults to False.\n            continuous (bool, optional): \n                Whether to predict continuous doses. Defaults to False.\n            doses (list, optional): \n                List of doses to predict if `continuous` is True. Defaults to None.\n\n        Returns:\n            AnnData: \n                An AnnData object containing the predicted cells in the primary space.\n                If `regression` is True, also returns the regression model.\n                If `continuous` is True, returns a dictionary of AnnData objects for each dose.\n        '''\n\n        # use keys registered from `setup_anndata()\n\n        ctrl_x = self.adata[self.adata.obs[treatment_key] == ctrl_key]\n        treat_x = self.adata[self.adata.obs[treatment_key] == treat_key]\n        ctrl_x = random_sample(ctrl_x, cell_type_key)\n        treat_x = random_sample(treat_x, cell_type_key)\n\n        # Balancing across treatments\n        new_adata = ctrl_x.concatenate(treat_x)\n        new_adata = random_sample(\n            new_adata, treatment_key, max_or_min=\"min\", replacement=False\n        )\n        if sparse.issparse(new_adata.X):\n            new_adata.X = new_adata.X.A\n\n        # Getting testing data\n        ctrl_data = new_adata[\n            (new_adata.obs[cell_type_key] == cell_type_to_predict)\n            &amp; (new_adata.obs[treatment_key] == ctrl_key)\n        ]\n        latent_cd = self.pca.transform(ctrl_data.X)\n\n        # Are we regressing the delta on the latent space or not\n        if not regression:\n            # No regression on latent space\n            ctrl_x = new_adata[new_adata.obs[treatment_key] == ctrl_key].copy()\n            treat_x = new_adata[new_adata.obs[treatment_key] == treat_key].copy()\n            # Compress data to latent space and then calculate the delta\n            latent_ctrl = np.average(self.pca.transform(ctrl_x.X), axis=0)\n            latent_treat = np.average(self.pca.transform(treat_x.X), axis=0)\n            delta = latent_treat - latent_ctrl\n        else:\n            # Regression on latent space\n            latent_X = self.pca.transform(new_adata.X)\n            latent_adata = sc.AnnData(X=latent_X, obs=new_adata.obs.copy())\n            # Get deltas and control centroids for each cell tpye in the training dataset\n            deltas = []\n            latent_centroids = []\n            cell_types = np.unique(latent_adata.obs[cell_type_key])\n            for cell in cell_types:\n                if cell != cell_type_to_predict:\n                    latent_ctrl = latent_adata[\n                        (latent_adata.obs[cell_type_key] == cell)\n                        &amp; (latent_adata.obs[treatment_key] == ctrl_key)\n                    ]\n                    latent_treat = latent_adata[\n                        (latent_adata.obs[cell_type_key] == cell)\n                        &amp; (latent_adata.obs[treatment_key] == treat_key)\n                    ]\n                    ctrl_centroid = np.average(latent_ctrl.X, axis=0)\n                    treat_centroid = np.average(latent_treat.X, axis=0)\n                    delta = np.average(latent_treat.X, axis=0) - np.average(\n                        latent_ctrl.X, axis=0\n                    )\n                    deltas.append(delta)\n                    latent_centroids.append(ctrl_centroid)\n            lr = LinearRegression()\n            reg = lr.fit(latent_centroids, deltas)\n            delta = reg.predict([np.average(latent_cd, axis=0)])[0]\n\n        # Continuous or Binary Perturbation\n        if not continuous:\n            treat_pred = delta + latent_cd\n            predicted_cells = self.pca.inverse_transform(treat_pred)\n            predicted_adata = sc.AnnData(\n                X=predicted_cells,\n                obs=ctrl_data.obs.copy(),\n                var=ctrl_data.var.copy(),\n                obsm=ctrl_data.obsm.copy(),\n            )\n            if not regression:\n                return predicted_adata, delta\n            else:\n                return predicted_adata, delta, reg\n        else:\n            treat_pred_dict = {\n                d: delta * (np.log1p(d) / np.log1p(max(doses))) + latent_cd\n                for d in doses\n                if d &gt; min(doses)\n            }\n            predicted_cells_dict = {\n                d: self.pca.inverse_transform(treat_pred_dict[d])\n                for d in doses\n                if d &gt; min(doses)\n            }\n            predicted_adata_dict = {\n                d: sc.AnnData(\n                    X=predicted_cells_dict[d],\n                    obs=ctrl_data.obs.copy(),\n                    var=ctrl_data.var.copy(),\n                    obsm=ctrl_data.obsm.copy(),\n                )\n                for d in doses\n                if d &gt; min(doses)\n            }\n            if not regression:\n                return predicted_adata_dict, delta\n            else:\n                return predicted_adata_dict, delta, reg\n\n    def reg_mean_plot(\n        self,\n        adata,\n        axis_keys,\n        labels,\n        condition_key,\n        path_to_save=\"./reg_mean.pdf\",\n        save=True,\n        gene_list=None,\n        show=False,\n        top_100_genes=None,\n        verbose=False,\n        legend=True,\n        title=None,\n        x_coeff=0.30,\n        y_coeff=0.8,\n        fontsize=14,\n        **kwargs,\n    ):\n        '''\n        Plots mean matching figure for a set of specific genes.\n\n    Args:\n        adata (AnnData): \n            AnnData object with equivalent structure to the initial AnnData. If `None`, defaults to the\n            AnnData object used to initialize the model. Must have been set up with `batch_key` and `labels_key`\n            corresponding to batch and cell type metadata, respectively.\n        axis_keys (dict): \n            Dictionary of `adata.obs` keys that are used by the axes of the plot. Must be in the form \n            `{\"x\": \"Key for x-axis\", \"y\": \"Key for y-axis\"}`.\n        labels (dict): \n            Dictionary of axis labels in the form `{\"x\": \"x-axis-name\", \"y\": \"y-axis name\"}`.\n        path_to_save (str): \n            Path where the plot will be saved.\n        save (bool): \n            If `True`, the plot will be saved to the specified path.\n        gene_list (list): \n            List of gene names to be plotted.\n        show (bool): \n            If `True`, the plot will be displayed after saving.\n\n    Examples:\n        &gt;&gt;&gt; import anndata\n        &gt;&gt;&gt; import scgen\n        &gt;&gt;&gt; import scanpy as sc\n        &gt;&gt;&gt; train = sc.read(\"./tests/data/train.h5ad\", backup_url=\"https://goo.gl/33HtVh\")\n        &gt;&gt;&gt; scgen.setup_anndata(train)\n        &gt;&gt;&gt; network = scgen.SCGEN(train)\n        &gt;&gt;&gt; network.train()\n        &gt;&gt;&gt; unperturbed_data = train[((train.obs[\"cell_type\"] == \"CD4T\") &amp; (train.obs[\"condition\"] == \"control\"))]\n        &gt;&gt;&gt; pred, delta = network.predict(\n        &gt;&gt;&gt;     adata=train,\n        &gt;&gt;&gt;     adata_to_predict=unperturbed_data,\n        &gt;&gt;&gt;     ctrl_key=\"control\",\n        &gt;&gt;&gt;     treat_key=\"treatulated\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; pred_adata = anndata.AnnData(\n        &gt;&gt;&gt;     pred,\n        &gt;&gt;&gt;     obs={\"condition\": [\"pred\"] * len(pred)},\n        &gt;&gt;&gt;     var={\"var_names\": train.var_names},\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; CD4T = train[train.obs[\"cell_type\"] == \"CD4T\"]\n        &gt;&gt;&gt; all_adata = CD4T.concatenate(pred_adata)\n        &gt;&gt;&gt; network.reg_mean_plot(\n        &gt;&gt;&gt;     all_adata,\n        &gt;&gt;&gt;     axis_keys={\"x\": \"control\", \"y\": \"pred\", \"y1\": \"treatulated\"},\n        &gt;&gt;&gt;     gene_list=[\"ISG15\", \"CD3D\"],\n        &gt;&gt;&gt;     path_to_save=\"tests/reg_mean.pdf\",\n        &gt;&gt;&gt;     show=False\n        &gt;&gt;&gt; )\n        '''\n        import seaborn as sns\n\n        sns.set()\n        sns.set(color_codes=True)\n\n        if sparse.issparse(adata.X):\n            adata.X = adata.X.A\n\n        diff_genes = top_100_genes\n        treat = adata[adata.obs[condition_key] == axis_keys[\"y\"]]\n        ctrl = adata[adata.obs[condition_key] == axis_keys[\"x\"]]\n        if diff_genes is not None:\n            if hasattr(diff_genes, \"tolist\"):\n                diff_genes = diff_genes.tolist()\n            adata_diff = adata[:, diff_genes]\n            treat_diff = adata_diff[adata_diff.obs[condition_key] == axis_keys[\"y\"]]\n            ctrl_diff = adata_diff[adata_diff.obs[condition_key] == axis_keys[\"x\"]]\n            x_diff = numpy.average(ctrl_diff.X, axis=0)\n            y_diff = numpy.average(treat_diff.X, axis=0)\n            m, b, r_value_diff, p_value_diff, std_err_diff = stats.linregress(\n                x_diff, y_diff\n            )\n            if verbose:\n                print(\"top_100 DEGs mean: \", r_value_diff**2)\n        x = numpy.average(ctrl.X, axis=0)\n        y = numpy.average(treat.X, axis=0)\n        m, b, r_value, p_value, std_err = stats.linregress(x, y)\n        if verbose:\n            print(\"All genes mean: \", r_value**2)\n        df = pd.DataFrame({axis_keys[\"x\"]: x, axis_keys[\"y\"]: y})\n        ax = sns.regplot(x=axis_keys[\"x\"], y=axis_keys[\"y\"], data=df)\n        ax.tick_params(labelsize=fontsize)\n        if \"range\" in kwargs:\n            start, stop, step = kwargs.get(\"range\")\n            ax.set_xticks(numpy.arange(start, stop, step))\n            ax.set_yticks(numpy.arange(start, stop, step))\n        ax.set_xlabel(labels[\"x\"], fontsize=fontsize)\n        ax.set_ylabel(labels[\"y\"], fontsize=fontsize)\n        if gene_list is not None:\n            texts = []\n            for i in gene_list:\n                j = adata.var_names.tolist().index(i)\n                x_bar = x[j]\n                y_bar = y[j]\n                texts.append(pyplot.text(x_bar, y_bar, i, fontsize=11, color=\"black\"))\n                pyplot.plot(x_bar, y_bar, \"o\", color=\"red\", markersize=5)\n                # if \"y1\" in axis_keys.keys():\n                # y1_bar = y1[j]\n                # pyplot.text(x_bar, y1_bar, i, fontsize=11, color=\"black\")\n        if gene_list is not None:\n            adjust_text(\n                texts,\n                x=x,\n                y=y,\n                arrowprops=dict(arrowstyle=\"-&gt;\", color=\"grey\", lw=0.5),\n                force_points=(0.0, 0.0),\n            )\n        if legend:\n            pyplot.legend(loc=\"center left\", bbox_to_anchor=(1, 0.5))\n        if title is None:\n            pyplot.title(\"\", fontsize=fontsize)\n        else:\n            pyplot.title(title, fontsize=fontsize)\n        ax.text(\n            max(x) - max(x) * x_coeff,\n            max(y) - y_coeff * max(y),\n            r\"$\\mathrm{R^2_{\\mathrm{\\mathsf{all\\ genes}}}}$= \" + f\"{r_value ** 2:.2f}\",\n            fontsize=kwargs.get(\"textsize\", fontsize),\n        )\n        if diff_genes is not None:\n            ax.text(\n                max(x) - max(x) * x_coeff,\n                max(y) - (y_coeff + 0.15) * max(y),\n                r\"$\\mathrm{R^2_{\\mathrm{\\mathsf{top\\ 100\\ DEGs}}}}$= \"\n                + f\"{r_value_diff ** 2:.2f}\",\n                fontsize=kwargs.get(\"textsize\", fontsize),\n            )\n        if save:\n            pyplot.savefig(f\"{path_to_save}\", bbox_inches=\"tight\", dpi=100)\n        if show:\n            pyplot.show()\n        pyplot.close()\n        if diff_genes is not None:\n            return r_value**2, r_value_diff**2\n        else:\n            return r_value**2\n\n    def get_gene_perturb_coef(self, delta):\n        '''Get gene perturbation coefficients for a given delta.\n\n        This method calculates gene-specific perturbation coefficients using the decoder's weights and the provided delta.\n        If you have performed linear regression, you can input the regression weights for delta. This will provide general\n        regression weights instead of gene-specific ones. The method uses the dot product of the linear decoder's weights\n        with the delta to compute the coefficients and returns a DataFrame of genes and their perturbation coefficients.\n\n        Args:\n            delta (numpy.ndarray): The delta vector, representing the difference between control and treated\n                                conditions in latent space.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing genes as the index and their perturbation coefficients as a column.\n\n        Raises:\n            Exception: If the model is not trained or the decoder is non-linear.\n\n        Example:\n            &gt;&gt;&gt; delta = np.random.randn(latent_dim)\n            &gt;&gt;&gt; gene_coef_df = model.get_gene_perturb_coef(delta)\n            &gt;&gt;&gt; print(gene_coef_df)\n\n    '''\n        if self.is_trained_ &amp; self._is_linear_decoder:\n            W = model.module.decoder[0].weight.cpu().detach().numpy()\n            gene_weights = np.dot(W, delta)\n            gene_weight_df = pd.DataFrame(\n                    {i: j for (i, j) in zip(train.var_names, gene_weights)},\n                    index=[\"gene_weights\"],\n                ).T\n            return gene_weight_df\n        else:\n            raise Exception(\n                \"Either model isn't trained or has a non-linear decoder.\"\n                )\n\n    def get_pseudo_dose(self, delta, cell_types=None):\n        ''' Calculate the pseudodose ordering of cells by projecting them orthogonally onto the span of the delta.\n\n        This method computes the pseudodose values of the cells by projecting the cells' expression data onto the \n        latent vector (delta). It can be applied to specific cell types if provided. The pseudodose values represent \n        the orthogonal projection of each cell onto the delta, which can be interpreted as a measure of cell state.\n\n        Args:\n            delta (numpy.ndarray): The latent vector representing the perturbation or difference between two conditions \n                                in latent space.\n            cell_types (list of str, optional): A list of cell types to include in the pseudodose calculation. \n                                                If `None`, all cell types in the AnnData object will be used.\n\n        Returns:\n            numpy.ndarray: An array of pseudodose values for each cell, representing its position along the span of delta.\n\n        Example:\n            &gt;&gt;&gt; delta = np.random.randn(latent_dim)\n            &gt;&gt;&gt; pseudo_dose = model.get_pseudo_dose(delta, cell_types=[\"CD4T\", \"B-cells\"])\n            &gt;&gt;&gt; print(pseudo_dose)\n\n        '''\n        cell_type_key = self.scvi_setup_dict_[\"categorical_mappings\"][\n                \"_scvi_labels\"\n            ][\"original_key\"]\n        if cell_types == None:\n            adata = self.adata\n        else:\n            adata = self.adata[self.adata.obs[cell_type_key].isin(cell_types), :]\n\n        pt_values = []\n        for i in adata.X:\n            pt_value = np.dot(i, delta) / np.dot(delta, delta)\n            pt_values.append(pt_value)\n\n        return np.array(pt_values)\n</code></pre>"},{"location":"API/PCAEval/#vidr.PCAEval.PCAEval.get_gene_perturb_coef","title":"<code>get_gene_perturb_coef(delta)</code>","text":"<p>Get gene perturbation coefficients for a given delta.</p> <p>This method calculates gene-specific perturbation coefficients using the decoder's weights and the provided delta. If you have performed linear regression, you can input the regression weights for delta. This will provide general regression weights instead of gene-specific ones. The method uses the dot product of the linear decoder's weights with the delta to compute the coefficients and returns a DataFrame of genes and their perturbation coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>ndarray</code> <p>The delta vector, representing the difference between control and treated                 conditions in latent space.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing genes as the index and their perturbation coefficients as a column.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the model is not trained or the decoder is non-linear.</p> Example <p>delta = np.random.randn(latent_dim) gene_coef_df = model.get_gene_perturb_coef(delta) print(gene_coef_df)</p> Source code in <code>vidr/PCAEval.py</code> <pre><code>def get_gene_perturb_coef(self, delta):\n    '''Get gene perturbation coefficients for a given delta.\n\n    This method calculates gene-specific perturbation coefficients using the decoder's weights and the provided delta.\n    If you have performed linear regression, you can input the regression weights for delta. This will provide general\n    regression weights instead of gene-specific ones. The method uses the dot product of the linear decoder's weights\n    with the delta to compute the coefficients and returns a DataFrame of genes and their perturbation coefficients.\n\n    Args:\n        delta (numpy.ndarray): The delta vector, representing the difference between control and treated\n                            conditions in latent space.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing genes as the index and their perturbation coefficients as a column.\n\n    Raises:\n        Exception: If the model is not trained or the decoder is non-linear.\n\n    Example:\n        &gt;&gt;&gt; delta = np.random.randn(latent_dim)\n        &gt;&gt;&gt; gene_coef_df = model.get_gene_perturb_coef(delta)\n        &gt;&gt;&gt; print(gene_coef_df)\n\n'''\n    if self.is_trained_ &amp; self._is_linear_decoder:\n        W = model.module.decoder[0].weight.cpu().detach().numpy()\n        gene_weights = np.dot(W, delta)\n        gene_weight_df = pd.DataFrame(\n                {i: j for (i, j) in zip(train.var_names, gene_weights)},\n                index=[\"gene_weights\"],\n            ).T\n        return gene_weight_df\n    else:\n        raise Exception(\n            \"Either model isn't trained or has a non-linear decoder.\"\n            )\n</code></pre>"},{"location":"API/PCAEval/#vidr.PCAEval.PCAEval.get_pseudo_dose","title":"<code>get_pseudo_dose(delta, cell_types=None)</code>","text":"<p>Calculate the pseudodose ordering of cells by projecting them orthogonally onto the span of the delta.</p> <p>This method computes the pseudodose values of the cells by projecting the cells' expression data onto the  latent vector (delta). It can be applied to specific cell types if provided. The pseudodose values represent  the orthogonal projection of each cell onto the delta, which can be interpreted as a measure of cell state.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>ndarray</code> <p>The latent vector representing the perturbation or difference between two conditions                  in latent space.</p> required <code>cell_types</code> <code>list of str</code> <p>A list of cell types to include in the pseudodose calculation.                                  If <code>None</code>, all cell types in the AnnData object will be used.</p> <code>None</code> <p>Returns:</p> Type Description <p>numpy.ndarray: An array of pseudodose values for each cell, representing its position along the span of delta.</p> Example <p>delta = np.random.randn(latent_dim) pseudo_dose = model.get_pseudo_dose(delta, cell_types=[\"CD4T\", \"B-cells\"]) print(pseudo_dose)</p> Source code in <code>vidr/PCAEval.py</code> <pre><code>def get_pseudo_dose(self, delta, cell_types=None):\n    ''' Calculate the pseudodose ordering of cells by projecting them orthogonally onto the span of the delta.\n\n    This method computes the pseudodose values of the cells by projecting the cells' expression data onto the \n    latent vector (delta). It can be applied to specific cell types if provided. The pseudodose values represent \n    the orthogonal projection of each cell onto the delta, which can be interpreted as a measure of cell state.\n\n    Args:\n        delta (numpy.ndarray): The latent vector representing the perturbation or difference between two conditions \n                            in latent space.\n        cell_types (list of str, optional): A list of cell types to include in the pseudodose calculation. \n                                            If `None`, all cell types in the AnnData object will be used.\n\n    Returns:\n        numpy.ndarray: An array of pseudodose values for each cell, representing its position along the span of delta.\n\n    Example:\n        &gt;&gt;&gt; delta = np.random.randn(latent_dim)\n        &gt;&gt;&gt; pseudo_dose = model.get_pseudo_dose(delta, cell_types=[\"CD4T\", \"B-cells\"])\n        &gt;&gt;&gt; print(pseudo_dose)\n\n    '''\n    cell_type_key = self.scvi_setup_dict_[\"categorical_mappings\"][\n            \"_scvi_labels\"\n        ][\"original_key\"]\n    if cell_types == None:\n        adata = self.adata\n    else:\n        adata = self.adata[self.adata.obs[cell_type_key].isin(cell_types), :]\n\n    pt_values = []\n    for i in adata.X:\n        pt_value = np.dot(i, delta) / np.dot(delta, delta)\n        pt_values.append(pt_value)\n\n    return np.array(pt_values)\n</code></pre>"},{"location":"API/PCAEval/#vidr.PCAEval.PCAEval.predict","title":"<code>predict(cell_type_key=None, treatment_key=None, ctrl_key=None, treat_key=None, cell_type_to_predict=None, regression=False, continuous=False, doses=None)</code>","text":"<p>Predicts the cell type provided by the user in the treated condition.</p> <p>Parameters:</p> Name Type Description Default <code>cell_type_key</code> <code>str</code> <p>Key for the cell type information in <code>adata.obs</code>. Defaults to None.</p> <code>None</code> <code>treatment_key</code> <code>str</code> <p>Key for the treatment or condition information in <code>adata.obs</code>. Defaults to None.</p> <code>None</code> <code>ctrl_key</code> <code>str</code> <p>Key for the control condition in <code>treatment_key</code>. Defaults to None.</p> <code>None</code> <code>treat_key</code> <code>str</code> <p>Key for the treated condition in <code>treatment_key</code>. Defaults to None.</p> <code>None</code> <code>cell_type_to_predict</code> <code>str</code> <p>The cell type to be predicted. Defaults to None.</p> <code>None</code> <code>regression</code> <code>bool</code> <p>Whether to perform regression on the latent space. Defaults to False.</p> <code>False</code> <code>continuous</code> <code>bool</code> <p>Whether to predict continuous doses. Defaults to False.</p> <code>False</code> <code>doses</code> <code>list</code> <p>List of doses to predict if <code>continuous</code> is True. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AnnData</code> <code>AnnData</code> <p>An AnnData object containing the predicted cells in the primary space. If <code>regression</code> is True, also returns the regression model. If <code>continuous</code> is True, returns a dictionary of AnnData objects for each dose.</p> Source code in <code>vidr/PCAEval.py</code> <pre><code>def predict(\n    self,\n    cell_type_key=None,\n    treatment_key=None,\n    ctrl_key=None,\n    treat_key=None,\n    cell_type_to_predict=None,\n    regression=False,\n    continuous=False,\n    doses=None,\n) -&gt; AnnData:\n    '''\n    Predicts the cell type provided by the user in the treated condition.\n\n    Args:\n        cell_type_key (str, optional): \n            Key for the cell type information in `adata.obs`. Defaults to None.\n        treatment_key (str, optional): \n            Key for the treatment or condition information in `adata.obs`. Defaults to None.\n        ctrl_key (str, optional): \n            Key for the control condition in `treatment_key`. Defaults to None.\n        treat_key (str, optional): \n            Key for the treated condition in `treatment_key`. Defaults to None.\n        cell_type_to_predict (str, optional): \n            The cell type to be predicted. Defaults to None.\n        regression (bool, optional): \n            Whether to perform regression on the latent space. Defaults to False.\n        continuous (bool, optional): \n            Whether to predict continuous doses. Defaults to False.\n        doses (list, optional): \n            List of doses to predict if `continuous` is True. Defaults to None.\n\n    Returns:\n        AnnData: \n            An AnnData object containing the predicted cells in the primary space.\n            If `regression` is True, also returns the regression model.\n            If `continuous` is True, returns a dictionary of AnnData objects for each dose.\n    '''\n\n    # use keys registered from `setup_anndata()\n\n    ctrl_x = self.adata[self.adata.obs[treatment_key] == ctrl_key]\n    treat_x = self.adata[self.adata.obs[treatment_key] == treat_key]\n    ctrl_x = random_sample(ctrl_x, cell_type_key)\n    treat_x = random_sample(treat_x, cell_type_key)\n\n    # Balancing across treatments\n    new_adata = ctrl_x.concatenate(treat_x)\n    new_adata = random_sample(\n        new_adata, treatment_key, max_or_min=\"min\", replacement=False\n    )\n    if sparse.issparse(new_adata.X):\n        new_adata.X = new_adata.X.A\n\n    # Getting testing data\n    ctrl_data = new_adata[\n        (new_adata.obs[cell_type_key] == cell_type_to_predict)\n        &amp; (new_adata.obs[treatment_key] == ctrl_key)\n    ]\n    latent_cd = self.pca.transform(ctrl_data.X)\n\n    # Are we regressing the delta on the latent space or not\n    if not regression:\n        # No regression on latent space\n        ctrl_x = new_adata[new_adata.obs[treatment_key] == ctrl_key].copy()\n        treat_x = new_adata[new_adata.obs[treatment_key] == treat_key].copy()\n        # Compress data to latent space and then calculate the delta\n        latent_ctrl = np.average(self.pca.transform(ctrl_x.X), axis=0)\n        latent_treat = np.average(self.pca.transform(treat_x.X), axis=0)\n        delta = latent_treat - latent_ctrl\n    else:\n        # Regression on latent space\n        latent_X = self.pca.transform(new_adata.X)\n        latent_adata = sc.AnnData(X=latent_X, obs=new_adata.obs.copy())\n        # Get deltas and control centroids for each cell tpye in the training dataset\n        deltas = []\n        latent_centroids = []\n        cell_types = np.unique(latent_adata.obs[cell_type_key])\n        for cell in cell_types:\n            if cell != cell_type_to_predict:\n                latent_ctrl = latent_adata[\n                    (latent_adata.obs[cell_type_key] == cell)\n                    &amp; (latent_adata.obs[treatment_key] == ctrl_key)\n                ]\n                latent_treat = latent_adata[\n                    (latent_adata.obs[cell_type_key] == cell)\n                    &amp; (latent_adata.obs[treatment_key] == treat_key)\n                ]\n                ctrl_centroid = np.average(latent_ctrl.X, axis=0)\n                treat_centroid = np.average(latent_treat.X, axis=0)\n                delta = np.average(latent_treat.X, axis=0) - np.average(\n                    latent_ctrl.X, axis=0\n                )\n                deltas.append(delta)\n                latent_centroids.append(ctrl_centroid)\n        lr = LinearRegression()\n        reg = lr.fit(latent_centroids, deltas)\n        delta = reg.predict([np.average(latent_cd, axis=0)])[0]\n\n    # Continuous or Binary Perturbation\n    if not continuous:\n        treat_pred = delta + latent_cd\n        predicted_cells = self.pca.inverse_transform(treat_pred)\n        predicted_adata = sc.AnnData(\n            X=predicted_cells,\n            obs=ctrl_data.obs.copy(),\n            var=ctrl_data.var.copy(),\n            obsm=ctrl_data.obsm.copy(),\n        )\n        if not regression:\n            return predicted_adata, delta\n        else:\n            return predicted_adata, delta, reg\n    else:\n        treat_pred_dict = {\n            d: delta * (np.log1p(d) / np.log1p(max(doses))) + latent_cd\n            for d in doses\n            if d &gt; min(doses)\n        }\n        predicted_cells_dict = {\n            d: self.pca.inverse_transform(treat_pred_dict[d])\n            for d in doses\n            if d &gt; min(doses)\n        }\n        predicted_adata_dict = {\n            d: sc.AnnData(\n                X=predicted_cells_dict[d],\n                obs=ctrl_data.obs.copy(),\n                var=ctrl_data.var.copy(),\n                obsm=ctrl_data.obsm.copy(),\n            )\n            for d in doses\n            if d &gt; min(doses)\n        }\n        if not regression:\n            return predicted_adata_dict, delta\n        else:\n            return predicted_adata_dict, delta, reg\n</code></pre>"},{"location":"API/PCAEval/#vidr.PCAEval.PCAEval.reg_mean_plot","title":"<code>reg_mean_plot(adata, axis_keys, labels, condition_key, path_to_save='./reg_mean.pdf', save=True, gene_list=None, show=False, top_100_genes=None, verbose=False, legend=True, title=None, x_coeff=0.3, y_coeff=0.8, fontsize=14, **kwargs)</code>","text":"<pre><code>Plots mean matching figure for a set of specific genes.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object with equivalent structure to the initial AnnData. If <code>None</code>, defaults to the AnnData object used to initialize the model. Must have been set up with <code>batch_key</code> and <code>labels_key</code> corresponding to batch and cell type metadata, respectively.</p> required <code>axis_keys</code> <code>dict</code> <p>Dictionary of <code>adata.obs</code> keys that are used by the axes of the plot. Must be in the form  <code>{\"x\": \"Key for x-axis\", \"y\": \"Key for y-axis\"}</code>.</p> required <code>labels</code> <code>dict</code> <p>Dictionary of axis labels in the form <code>{\"x\": \"x-axis-name\", \"y\": \"y-axis name\"}</code>.</p> required <code>path_to_save</code> <code>str</code> <p>Path where the plot will be saved.</p> <code>'./reg_mean.pdf'</code> <code>save</code> <code>bool</code> <p>If <code>True</code>, the plot will be saved to the specified path.</p> <code>True</code> <code>gene_list</code> <code>list</code> <p>List of gene names to be plotted.</p> <code>None</code> <code>show</code> <code>bool</code> <p>If <code>True</code>, the plot will be displayed after saving.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import anndata\n&gt;&gt;&gt; import scgen\n&gt;&gt;&gt; import scanpy as sc\n&gt;&gt;&gt; train = sc.read(\"./tests/data/train.h5ad\", backup_url=\"https://goo.gl/33HtVh\")\n&gt;&gt;&gt; scgen.setup_anndata(train)\n&gt;&gt;&gt; network = scgen.SCGEN(train)\n&gt;&gt;&gt; network.train()\n&gt;&gt;&gt; unperturbed_data = train[((train.obs[\"cell_type\"] == \"CD4T\") &amp; (train.obs[\"condition\"] == \"control\"))]\n&gt;&gt;&gt; pred, delta = network.predict(\n&gt;&gt;&gt;     adata=train,\n&gt;&gt;&gt;     adata_to_predict=unperturbed_data,\n&gt;&gt;&gt;     ctrl_key=\"control\",\n&gt;&gt;&gt;     treat_key=\"treatulated\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; pred_adata = anndata.AnnData(\n&gt;&gt;&gt;     pred,\n&gt;&gt;&gt;     obs={\"condition\": [\"pred\"] * len(pred)},\n&gt;&gt;&gt;     var={\"var_names\": train.var_names},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; CD4T = train[train.obs[\"cell_type\"] == \"CD4T\"]\n&gt;&gt;&gt; all_adata = CD4T.concatenate(pred_adata)\n&gt;&gt;&gt; network.reg_mean_plot(\n&gt;&gt;&gt;     all_adata,\n&gt;&gt;&gt;     axis_keys={\"x\": \"control\", \"y\": \"pred\", \"y1\": \"treatulated\"},\n&gt;&gt;&gt;     gene_list=[\"ISG15\", \"CD3D\"],\n&gt;&gt;&gt;     path_to_save=\"tests/reg_mean.pdf\",\n&gt;&gt;&gt;     show=False\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>vidr/PCAEval.py</code> <pre><code>def reg_mean_plot(\n    self,\n    adata,\n    axis_keys,\n    labels,\n    condition_key,\n    path_to_save=\"./reg_mean.pdf\",\n    save=True,\n    gene_list=None,\n    show=False,\n    top_100_genes=None,\n    verbose=False,\n    legend=True,\n    title=None,\n    x_coeff=0.30,\n    y_coeff=0.8,\n    fontsize=14,\n    **kwargs,\n):\n    '''\n    Plots mean matching figure for a set of specific genes.\n\nArgs:\n    adata (AnnData): \n        AnnData object with equivalent structure to the initial AnnData. If `None`, defaults to the\n        AnnData object used to initialize the model. Must have been set up with `batch_key` and `labels_key`\n        corresponding to batch and cell type metadata, respectively.\n    axis_keys (dict): \n        Dictionary of `adata.obs` keys that are used by the axes of the plot. Must be in the form \n        `{\"x\": \"Key for x-axis\", \"y\": \"Key for y-axis\"}`.\n    labels (dict): \n        Dictionary of axis labels in the form `{\"x\": \"x-axis-name\", \"y\": \"y-axis name\"}`.\n    path_to_save (str): \n        Path where the plot will be saved.\n    save (bool): \n        If `True`, the plot will be saved to the specified path.\n    gene_list (list): \n        List of gene names to be plotted.\n    show (bool): \n        If `True`, the plot will be displayed after saving.\n\nExamples:\n    &gt;&gt;&gt; import anndata\n    &gt;&gt;&gt; import scgen\n    &gt;&gt;&gt; import scanpy as sc\n    &gt;&gt;&gt; train = sc.read(\"./tests/data/train.h5ad\", backup_url=\"https://goo.gl/33HtVh\")\n    &gt;&gt;&gt; scgen.setup_anndata(train)\n    &gt;&gt;&gt; network = scgen.SCGEN(train)\n    &gt;&gt;&gt; network.train()\n    &gt;&gt;&gt; unperturbed_data = train[((train.obs[\"cell_type\"] == \"CD4T\") &amp; (train.obs[\"condition\"] == \"control\"))]\n    &gt;&gt;&gt; pred, delta = network.predict(\n    &gt;&gt;&gt;     adata=train,\n    &gt;&gt;&gt;     adata_to_predict=unperturbed_data,\n    &gt;&gt;&gt;     ctrl_key=\"control\",\n    &gt;&gt;&gt;     treat_key=\"treatulated\"\n    &gt;&gt;&gt; )\n    &gt;&gt;&gt; pred_adata = anndata.AnnData(\n    &gt;&gt;&gt;     pred,\n    &gt;&gt;&gt;     obs={\"condition\": [\"pred\"] * len(pred)},\n    &gt;&gt;&gt;     var={\"var_names\": train.var_names},\n    &gt;&gt;&gt; )\n    &gt;&gt;&gt; CD4T = train[train.obs[\"cell_type\"] == \"CD4T\"]\n    &gt;&gt;&gt; all_adata = CD4T.concatenate(pred_adata)\n    &gt;&gt;&gt; network.reg_mean_plot(\n    &gt;&gt;&gt;     all_adata,\n    &gt;&gt;&gt;     axis_keys={\"x\": \"control\", \"y\": \"pred\", \"y1\": \"treatulated\"},\n    &gt;&gt;&gt;     gene_list=[\"ISG15\", \"CD3D\"],\n    &gt;&gt;&gt;     path_to_save=\"tests/reg_mean.pdf\",\n    &gt;&gt;&gt;     show=False\n    &gt;&gt;&gt; )\n    '''\n    import seaborn as sns\n\n    sns.set()\n    sns.set(color_codes=True)\n\n    if sparse.issparse(adata.X):\n        adata.X = adata.X.A\n\n    diff_genes = top_100_genes\n    treat = adata[adata.obs[condition_key] == axis_keys[\"y\"]]\n    ctrl = adata[adata.obs[condition_key] == axis_keys[\"x\"]]\n    if diff_genes is not None:\n        if hasattr(diff_genes, \"tolist\"):\n            diff_genes = diff_genes.tolist()\n        adata_diff = adata[:, diff_genes]\n        treat_diff = adata_diff[adata_diff.obs[condition_key] == axis_keys[\"y\"]]\n        ctrl_diff = adata_diff[adata_diff.obs[condition_key] == axis_keys[\"x\"]]\n        x_diff = numpy.average(ctrl_diff.X, axis=0)\n        y_diff = numpy.average(treat_diff.X, axis=0)\n        m, b, r_value_diff, p_value_diff, std_err_diff = stats.linregress(\n            x_diff, y_diff\n        )\n        if verbose:\n            print(\"top_100 DEGs mean: \", r_value_diff**2)\n    x = numpy.average(ctrl.X, axis=0)\n    y = numpy.average(treat.X, axis=0)\n    m, b, r_value, p_value, std_err = stats.linregress(x, y)\n    if verbose:\n        print(\"All genes mean: \", r_value**2)\n    df = pd.DataFrame({axis_keys[\"x\"]: x, axis_keys[\"y\"]: y})\n    ax = sns.regplot(x=axis_keys[\"x\"], y=axis_keys[\"y\"], data=df)\n    ax.tick_params(labelsize=fontsize)\n    if \"range\" in kwargs:\n        start, stop, step = kwargs.get(\"range\")\n        ax.set_xticks(numpy.arange(start, stop, step))\n        ax.set_yticks(numpy.arange(start, stop, step))\n    ax.set_xlabel(labels[\"x\"], fontsize=fontsize)\n    ax.set_ylabel(labels[\"y\"], fontsize=fontsize)\n    if gene_list is not None:\n        texts = []\n        for i in gene_list:\n            j = adata.var_names.tolist().index(i)\n            x_bar = x[j]\n            y_bar = y[j]\n            texts.append(pyplot.text(x_bar, y_bar, i, fontsize=11, color=\"black\"))\n            pyplot.plot(x_bar, y_bar, \"o\", color=\"red\", markersize=5)\n            # if \"y1\" in axis_keys.keys():\n            # y1_bar = y1[j]\n            # pyplot.text(x_bar, y1_bar, i, fontsize=11, color=\"black\")\n    if gene_list is not None:\n        adjust_text(\n            texts,\n            x=x,\n            y=y,\n            arrowprops=dict(arrowstyle=\"-&gt;\", color=\"grey\", lw=0.5),\n            force_points=(0.0, 0.0),\n        )\n    if legend:\n        pyplot.legend(loc=\"center left\", bbox_to_anchor=(1, 0.5))\n    if title is None:\n        pyplot.title(\"\", fontsize=fontsize)\n    else:\n        pyplot.title(title, fontsize=fontsize)\n    ax.text(\n        max(x) - max(x) * x_coeff,\n        max(y) - y_coeff * max(y),\n        r\"$\\mathrm{R^2_{\\mathrm{\\mathsf{all\\ genes}}}}$= \" + f\"{r_value ** 2:.2f}\",\n        fontsize=kwargs.get(\"textsize\", fontsize),\n    )\n    if diff_genes is not None:\n        ax.text(\n            max(x) - max(x) * x_coeff,\n            max(y) - (y_coeff + 0.15) * max(y),\n            r\"$\\mathrm{R^2_{\\mathrm{\\mathsf{top\\ 100\\ DEGs}}}}$= \"\n            + f\"{r_value_diff ** 2:.2f}\",\n            fontsize=kwargs.get(\"textsize\", fontsize),\n        )\n    if save:\n        pyplot.savefig(f\"{path_to_save}\", bbox_inches=\"tight\", dpi=100)\n    if show:\n        pyplot.show()\n    pyplot.close()\n    if diff_genes is not None:\n        return r_value**2, r_value_diff**2\n    else:\n        return r_value**2\n</code></pre>"},{"location":"API/modules/","title":"VIDR Encoder &amp; Decoder Classes and Associated Methods in modules.py","text":"<p>This section provides an overview of the VIDR Encoder and Decoder classes and their associated methods.</p>"},{"location":"API/modules/#vidr-encoder","title":"VIDR Encoder","text":""},{"location":"API/modules/#vidr-encoder_1","title":"VIDR Encoder","text":"<p>               Bases: <code>Module</code></p> <p>Variational Encoder for scVIDR (Single-Cell Variational Inference for Dose Response).</p> <p>This class implements the encoder portion of a variational autoencoder (VAE), which encodes input data into a latent representation by learning mean and variance for reparameterization.</p> <p>Attributes:</p> Name Type Description <code>eps</code> <code>float</code> <p>Small constant added to variance for numerical stability.</p> <code>fclayers</code> <code>Sequential</code> <p>Fully connected layers with batch normalization, dropout, and activation.</p> <code>encoder</code> <code>Sequential</code> <p>The full encoder model consisting of input and hidden layers.</p> <code>mean</code> <code>Linear</code> <p>Linear layer to compute the mean of the latent distribution.</p> <code>log_var</code> <code>Linear</code> <p>Linear layer to compute the log-variance of the latent distribution.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>Dimensionality of the input data.</p> required <code>latent_dim</code> <code>int</code> <p>Dimensionality of the latent representation.</p> required <code>hidden_dim</code> <code>int</code> <p>Number of hidden units in the fully connected layers.</p> required <code>n_hidden_layers</code> <code>int</code> <p>Number of hidden layers.</p> required <code>momentum</code> <code>float</code> <p>Momentum parameter for batch normalization. Defaults to 0.01.</p> <code>0.01</code> <code>eps</code> <code>float</code> <p>Epsilon for numerical stability in batch normalization. Defaults to 0.001.</p> <code>0.001</code> <code>dropout_rate</code> <code>float</code> <p>Dropout rate for regularization. Defaults to 0.2.</p> <code>0.2</code> <code>reparam_eps</code> <code>float</code> <p>Epsilon added to variance during reparameterization. Defaults to 1e-4.</p> <code>0.0001</code> <code>nonlin</code> <code>callable</code> <p>Non-linear activation function. Defaults to nn.LeakyReLU.</p> <code>LeakyReLU</code> <p>Methods:</p> Name Description <code>forward</code> <p>Encodes the input data, computes mean and variance, and performs reparameterization.</p> Source code in <code>vidr/modules.py</code> <pre><code>class VIDREncoder(nn.Module):\n    '''  Variational Encoder for scVIDR (Single-Cell Variational Inference for Dose Response).\n\n    This class implements the encoder portion of a variational autoencoder (VAE),\n    which encodes input data into a latent representation by learning mean and\n    variance for reparameterization.\n\n    Attributes:\n        eps (float): Small constant added to variance for numerical stability.\n        fclayers (nn.Sequential): Fully connected layers with batch normalization,\n            dropout, and activation.\n        encoder (nn.Sequential): The full encoder model consisting of input and hidden layers.\n        mean (nn.Linear): Linear layer to compute the mean of the latent distribution.\n        log_var (nn.Linear): Linear layer to compute the log-variance of the latent distribution.\n\n    Args:\n        input_dim (int): Dimensionality of the input data.\n        latent_dim (int): Dimensionality of the latent representation.\n        hidden_dim (int): Number of hidden units in the fully connected layers.\n        n_hidden_layers (int): Number of hidden layers.\n        momentum (float, optional): Momentum parameter for batch normalization. Defaults to 0.01.\n        eps (float, optional): Epsilon for numerical stability in batch normalization. Defaults to 0.001.\n        dropout_rate (float, optional): Dropout rate for regularization. Defaults to 0.2.\n        reparam_eps (float, optional): Epsilon added to variance during reparameterization. Defaults to 1e-4.\n        nonlin (callable, optional): Non-linear activation function. Defaults to nn.LeakyReLU.\n\n    Methods:\n        forward(inputs):\n            Encodes the input data, computes mean and variance, and performs reparameterization.\n    '''\n    def __init__(\n        self,\n        input_dim: int,\n        latent_dim: int,\n        hidden_dim: int,\n        n_hidden_layers: int,\n        momentum: float = 0.01,\n        eps: float = 0.001,\n        dropout_rate: float = 0.2,\n        reparam_eps: float = 1e-4,\n        nonlin=nn.LeakyReLU,\n    ):\n        super(VIDREncoder, self).__init__()\n        self.eps = reparam_eps\n        self.fclayers = nn.Sequential(\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.BatchNorm1d(hidden_dim, momentum=momentum, eps=eps),\n            nonlin(),\n            nn.Dropout(p=dropout_rate),\n        )\n\n        # Encoder\n        # Include Input Module\n        modules = [\n            nn.Sequential(\n                nn.Linear(input_dim, hidden_dim),\n                nn.BatchNorm1d(hidden_dim, momentum=momentum, eps=eps),\n                nonlin(),\n                nn.Dropout(p=dropout_rate),\n            )\n        ]\n\n        # Add hidden fully connected layers\n        for i in range(n_hidden_layers - 1):\n            modules.append(self.fclayers)\n\n        self.encoder = nn.Sequential(*modules)\n\n        self.mean = nn.Linear(hidden_dim, latent_dim)\n\n        self.log_var = nn.Linear(hidden_dim, latent_dim)\n\n    def forward(self, inputs):\n        \"\"\"Forward pass of the encoder.\n\n        Encodes the input data into a latent representation by\n        computing the mean and variance, then sampling using \n        the reparameterization trick.\n\n        Args:\n            inputs (torch.Tensor): The input data.\n\n        Returns:\n            tuple: A tuple containing:\n                - mean (torch.Tensor): The mean of the latent distribution.\n                - var (torch.Tensor): The variance of the latent distribution.\n                - latent_rep (torch.Tensor): The reparameterized latent representation.\n        \"\"\"\n        # encode\n        results = self.encoder(inputs)\n        mean = self.mean(results)\n        log_var = self.log_var(results)\n\n        var = torch.exp(log_var) + self.eps\n\n        # reparameterize\n        latent_rep = Normal(mean, var.sqrt()).rsample()\n\n        return mean, var, latent_rep\n</code></pre>"},{"location":"API/modules/#vidr.modules.VIDREncoder.forward","title":"<code>forward(inputs)</code>","text":"<p>Forward pass of the encoder.</p> <p>Encodes the input data into a latent representation by computing the mean and variance, then sampling using  the reparameterization trick.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Tensor</code> <p>The input data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - mean (torch.Tensor): The mean of the latent distribution. - var (torch.Tensor): The variance of the latent distribution. - latent_rep (torch.Tensor): The reparameterized latent representation.</p> Source code in <code>vidr/modules.py</code> <pre><code>def forward(self, inputs):\n    \"\"\"Forward pass of the encoder.\n\n    Encodes the input data into a latent representation by\n    computing the mean and variance, then sampling using \n    the reparameterization trick.\n\n    Args:\n        inputs (torch.Tensor): The input data.\n\n    Returns:\n        tuple: A tuple containing:\n            - mean (torch.Tensor): The mean of the latent distribution.\n            - var (torch.Tensor): The variance of the latent distribution.\n            - latent_rep (torch.Tensor): The reparameterized latent representation.\n    \"\"\"\n    # encode\n    results = self.encoder(inputs)\n    mean = self.mean(results)\n    log_var = self.log_var(results)\n\n    var = torch.exp(log_var) + self.eps\n\n    # reparameterize\n    latent_rep = Normal(mean, var.sqrt()).rsample()\n\n    return mean, var, latent_rep\n</code></pre>"},{"location":"API/modules/#vidr-decoder","title":"VIDR Decoder","text":""},{"location":"API/modules/#vidr-decoder_1","title":"VIDR Decoder","text":"<p>               Bases: <code>Module</code></p> <p>Variational Decoder for scVIDR (Single-Cell Variational Inference for Dose Response).</p> <p>This class implements the decoder portion of a variational autoencoder (VAE), which decodes latent representations back into input space.</p> <p>Attributes:</p> Name Type Description <code>fclayers</code> <code>Sequential</code> <p>Fully connected layers with batch normalization, dropout, and activation.</p> <code>decoder</code> <code>Sequential</code> <p>The full decoder model consisting of latent input, hidden layers, and output layer.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>Dimensionality of the output data.</p> required <code>latent_dim</code> <code>int</code> <p>Dimensionality of the latent representation.</p> required <code>hidden_dim</code> <code>int</code> <p>Number of hidden units in the fully connected layers.</p> required <code>n_hidden_layers</code> <code>int</code> <p>Number of hidden layers.</p> required <code>momentum</code> <code>float</code> <p>Momentum parameter for batch normalization. Defaults to 0.01.</p> <code>0.01</code> <code>eps</code> <code>float</code> <p>Epsilon for numerical stability in batch normalization. Defaults to 0.001.</p> <code>0.001</code> <code>dropout_rate</code> <code>float</code> <p>Dropout rate for regularization. Defaults to 0.2.</p> <code>0.2</code> <code>nonlin</code> <code>callable</code> <p>Non-linear activation function. Defaults to nn.LeakyReLU.</p> <code>LeakyReLU</code> <p>Methods:</p> Name Description <code>forward</code> <p>Decodes the latent representation back into the input space.</p> Source code in <code>vidr/modules.py</code> <pre><code>class VIDRDecoder(nn.Module):\n    ''' Variational Decoder for scVIDR (Single-Cell Variational Inference for Dose Response).\n\n    This class implements the decoder portion of a variational autoencoder (VAE),\n    which decodes latent representations back into input space.\n\n    Attributes:\n        fclayers (nn.Sequential): Fully connected layers with batch normalization,\n            dropout, and activation.\n        decoder (nn.Sequential): The full decoder model consisting of latent input, hidden layers,\n            and output layer.\n\n    Args:\n        input_dim (int): Dimensionality of the output data.\n        latent_dim (int): Dimensionality of the latent representation.\n        hidden_dim (int): Number of hidden units in the fully connected layers.\n        n_hidden_layers (int): Number of hidden layers.\n        momentum (float, optional): Momentum parameter for batch normalization. Defaults to 0.01.\n        eps (float, optional): Epsilon for numerical stability in batch normalization. Defaults to 0.001.\n        dropout_rate (float, optional): Dropout rate for regularization. Defaults to 0.2.\n        nonlin (callable, optional): Non-linear activation function. Defaults to nn.LeakyReLU.\n\n    Methods:\n        forward(latent_rep):\n            Decodes the latent representation back into the input space.\n    '''\n    def __init__(\n        self,\n        input_dim: int,\n        latent_dim: int,\n        hidden_dim: int,\n        n_hidden_layers: int,\n        momentum: float = 0.01,\n        eps: float = 0.001,\n        dropout_rate: float = 0.2,\n        nonlin=nn.LeakyReLU,\n    ):\n        super(VIDRDecoder, self).__init__()\n        self.fclayers = nn.Sequential(\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.BatchNorm1d(hidden_dim, momentum=momentum, eps=eps),\n            nonlin(),\n            nn.Dropout(p=dropout_rate),\n        )\n\n        # Encoder\n        # Include Input Module\n        modules = [\n            nn.Sequential(\n                nn.Linear(latent_dim, hidden_dim),\n                nn.BatchNorm1d(hidden_dim, momentum=momentum, eps=eps),\n                nonlin(),\n                nn.Dropout(p=dropout_rate),\n            )\n        ]\n\n        # Add hidden fully connected layers\n        for i in range(n_hidden_layers - 1):\n            modules.append(self.fclayers)\n\n        modules.append(nn.Linear(hidden_dim, input_dim))\n        self.decoder = nn.Sequential(*modules)\n\n    def forward(self, latent_rep):\n        \"\"\"Forward pass of the decoder.\n\n        Decodes the latent representation back into\n        the original input space.\n\n        Args:\n            latent_rep (torch.Tensor): The latent representation to decode.\n\n        Returns:\n            torch.Tensor: The reconstructed data.\n        \"\"\"\n        # decode\n        x_hat = self.decoder(latent_rep)\n        return x_hat\n</code></pre>"},{"location":"API/modules/#vidr.modules.VIDRDecoder.forward","title":"<code>forward(latent_rep)</code>","text":"<p>Forward pass of the decoder.</p> <p>Decodes the latent representation back into the original input space.</p> <p>Parameters:</p> Name Type Description Default <code>latent_rep</code> <code>Tensor</code> <p>The latent representation to decode.</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The reconstructed data.</p> Source code in <code>vidr/modules.py</code> <pre><code>def forward(self, latent_rep):\n    \"\"\"Forward pass of the decoder.\n\n    Decodes the latent representation back into\n    the original input space.\n\n    Args:\n        latent_rep (torch.Tensor): The latent representation to decode.\n\n    Returns:\n        torch.Tensor: The reconstructed data.\n    \"\"\"\n    # decode\n    x_hat = self.decoder(latent_rep)\n    return x_hat\n</code></pre>"},{"location":"API/utils/","title":"Utility functions in utils.py","text":""},{"location":"API/utils/#create_cell_dose_column","title":"create_cell_dose_column","text":""},{"location":"API/utils/#create_cell_dose_column_1","title":"create_cell_dose_column","text":"<p>Adds a column to 'adata.obs' named by celltype and dose</p> <p>This function combines the values from <code>celltype_column</code> and <code>dose_column</code>  in each row of <code>adata.obs</code>, separated by an underscore (<code>_</code>), and returns  the resulting concatenated values as a new column. This can be useful for  creating unique identifiers for each combination of cell type and dose.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>The AnnData object containing single-cell or similar  biological data, where metadata is stored in <code>adata.obs</code>.</p> required <code>celltype_column</code> <code>str</code> <p>The name of the column in <code>adata.obs</code> that  contains cell type information (e.g., 'celltype').</p> required <code>dose_column</code> <code>str</code> <p>The name of the column in <code>adata.obs</code> that  contains dose information (e.g., 'dose').</p> required <p>Returns:</p> Type Description <p>pandas.Series: A series containing the concatenated values of </p> <p><code>celltype_column</code> and <code>dose_column</code>, which can be added as a new </p> <p>column to <code>adata.obs</code>.</p> Example <p>Suppose <code>adata.obs</code> contains the following columns:</p> celltype dose T-cell low B-cell high T-cell medium <p>You can create a new column combining <code>celltype</code> and <code>dose</code> as follows:</p> <pre><code>adata.obs['cell_dose'] = create_cell_dose_column(adata, 'celltype', 'dose')\n</code></pre> <p>The resulting <code>adata.obs</code> will look like:</p> celltype dose cell_dose T-cell low T-cell_low B-cell high B-cell_high T-cell medium T-cell_medium Source code in <code>vidr/utils.py</code> <pre><code>def create_cell_dose_column(adata, celltype_column, dose_column):\n    ''' Adds a column to 'adata.obs' named by celltype and dose\n\n    This function combines the values from `celltype_column` and `dose_column` \n    in each row of `adata.obs`, separated by an underscore (`_`), and returns \n    the resulting concatenated values as a new column. This can be useful for \n    creating unique identifiers for each combination of cell type and dose.\n\n    Args:\n        adata (AnnData): The AnnData object containing single-cell or similar \n            biological data, where metadata is stored in `adata.obs`.\n        celltype_column (str): The name of the column in `adata.obs` that \n            contains cell type information (e.g., 'celltype').\n        dose_column (str): The name of the column in `adata.obs` that \n            contains dose information (e.g., 'dose').\n\n    Returns:\n        pandas.Series: A series containing the concatenated values of \n        `celltype_column` and `dose_column`, which can be added as a new \n        column to `adata.obs`.\n\n    Example:\n        Suppose `adata.obs` contains the following columns:\n\n        | celltype | dose  |\n        |----------|-------|\n        | T-cell   | low   |\n        | B-cell   | high  |\n        | T-cell   | medium|\n\n        You can create a new column combining `celltype` and `dose` as follows:\n\n        ```python\n        adata.obs['cell_dose'] = create_cell_dose_column(adata, 'celltype', 'dose')\n        ```\n\n        The resulting `adata.obs` will look like:\n\n        | celltype | dose  | cell_dose     |\n        |----------|-------|---------------|\n        | T-cell   | low   | T-cell_low    |\n        | B-cell   | high  | B-cell_high   |\n        | T-cell   | medium| T-cell_medium |\n    '''\n    return adata.obs.apply(lambda x: f\"{x[celltype_column]}_{x[dose_column]}\", axis=1)\n</code></pre>"},{"location":"API/utils/#normalize_data","title":"normalize_data","text":""},{"location":"API/utils/#normalize_data_1","title":"normalize_data","text":"<p>Normalizes, logarithmizes, and selects 5000 highly variable genes.</p> <p>Combines Scanpy preprocessing functions normalize_total, log1p, and highly_variable_genes to streamline the preprocessing workflow. </p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>The AnnData object containing single-cell or similar biological data.</p> required <p>Returns:</p> Name Type Description <code>AnnData</code> <p>A new AnnData object that includes only the top</p> <p>5000 highly variable genes.</p> Example <p>If you have an AnnData object <code>adata</code> with raw single-cell RNA-seq data you can preprocess it by calling:</p> <pre><code>adata_filtered = normalize_data(adata)\n</code></pre> <p>After running this, <code>adata_filtered</code> will contain only the top  5000 highly variable genes, normalized and logarithmically transformed.</p> Source code in <code>vidr/utils.py</code> <pre><code>def normalize_data(adata):\n    ''' Normalizes, logarithmizes, and selects 5000 highly variable genes.\n\n    Combines Scanpy preprocessing functions normalize_total, log1p, and\n    highly_variable_genes to streamline the preprocessing workflow. \n\n    Args:\n       adata (AnnData): The AnnData object containing single-cell or similar\n        biological data.\n\n    Returns:\n        AnnData: A new AnnData object that includes only the top\n        5000 highly variable genes.\n\n    Example:\n        If you have an AnnData object `adata` with raw single-cell RNA-seq data\n        you can preprocess it by calling:\n\n        ```python\n        adata_filtered = normalize_data(adata)\n        ```\n\n        After running this, `adata_filtered` will contain only the top \n        5000 highly variable genes, normalized and logarithmically transformed.\n\n    '''\n\n    sc.pp.normalize_total(adata)\n    sc.pp.log1p(adata)\n    sc.pp.highly_variable_genes(adata, n_top_genes=5000)\n\n    return adata[:, adata.var.highly_variable]\n</code></pre>"},{"location":"API/utils/#prepare_data","title":"prepare_data","text":""},{"location":"API/utils/#prepare_data_1","title":"prepare_data","text":"<p>Prepares training and testing data for analysis based on cell type and treatment conditions.</p> <p>This function filters an <code>AnnData</code> object into train and test datasets.  The test set includes the specified cell type to predict and the treatment to predict. The training set includes all other data.</p> <p>cells of a specified type and treatment condition for prediction purposes. It also normalizes  the data if it's not already normalized, using the <code>normalize_data</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>The AnnData object containing single-cell or similar biological data.</p> required <code>cell_type_key</code> <code>str</code> <p>The column name in <code>adata.obs</code> that contains cell type information.</p> required <code>treatment_key</code> <code>str</code> <p>The column name in <code>adata.obs</code> that contains treatment or condition information.</p> required <code>cell_type_to_predict</code> <code>str</code> <p>The cell type to be separated out for testing/prediction.</p> required <code>treatment_to_predict</code> <code>str</code> <p>The treatment or condition to be separated out for testing/prediction.</p> required <code>normalized</code> <code>bool</code> <p>Whether the data is already normalized. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>train_adata</code> <code>AnnData</code> <p>The training dataset, containing all cells except those specified by  <code>cell_type_to_predict</code> and <code>treatment_to_predict</code>.</p> <code>test_adata</code> <code>AnnData</code> <p>The test dataset, containing only the cells with the specified  <code>cell_type_to_predict</code> and <code>treatment_to_predict</code>.</p> Example <p>Create training and testing datasets from an AnnData object with cell type information in the  'celltype' column of adata.obs and dosing information in the 'dose' column of adata.obs. To select T-cells under a low-dose treatment as your testing set: </p> <pre><code>train_adata, test_adata = prepare_data(\n    adata, \n    cell_type_key='celltype', \n    treatment_key='dose', \n    cell_type_to_predict='T-cell', \n    treatment_to_predict='low', \n    normalized=False\n)\n</code></pre> <p>This will return two <code>AnnData</code> objects:  <code>test_adata</code> containing only T-cells under low-dose treatment,  and train_adata` containing all cells except T-cells under low-dose treatment,</p> Note <p>This preprocessing step assumes the data is in the format output by Cell Ranger and is not  logarithmized by default unless specified.</p> Source code in <code>vidr/utils.py</code> <pre><code>def prepare_data(\n    adata,\n    cell_type_key,\n    treatment_key,\n    cell_type_to_predict,\n    treatment_to_predict,\n    normalized=False,\n):\n    ''' Prepares training and testing data for analysis based on cell type and treatment conditions.\n\n    This function filters an `AnnData` object into train and test datasets. \n    The test set includes the specified cell type to predict and the treatment to predict.\n    The training set includes all other data.\n\n    cells of a specified type and treatment condition for prediction purposes. It also normalizes \n    the data if it's not already normalized, using the `normalize_data` function.\n\n    Args:\n        adata (AnnData): The AnnData object containing single-cell or similar biological data.\n        cell_type_key (str): The column name in `adata.obs` that contains cell type information.\n        treatment_key (str): The column name in `adata.obs` that contains treatment or condition information.\n        cell_type_to_predict (str): The cell type to be separated out for testing/prediction.\n        treatment_to_predict (str): The treatment or condition to be separated out for testing/prediction.\n        normalized (bool, optional): Whether the data is already normalized. Defaults to False.\n\n    Returns:\n        train_adata (AnnData): The training dataset, containing all cells except those specified by \n            `cell_type_to_predict` and `treatment_to_predict`.\n        test_adata (AnnData): The test dataset, containing only the cells with the specified \n            `cell_type_to_predict` and `treatment_to_predict`.\n\n    Example:\n        Create training and testing datasets from an AnnData object with cell type information in the \n        'celltype' column of adata.obs and dosing information in the 'dose' column of adata.obs.\n        To select T-cells under a low-dose treatment as your testing set: \n\n        ```python\n        train_adata, test_adata = prepare_data(\n            adata, \n            cell_type_key='celltype', \n            treatment_key='dose', \n            cell_type_to_predict='T-cell', \n            treatment_to_predict='low', \n            normalized=False\n        )\n        ```\n\n        This will return two `AnnData` objects:  `test_adata` containing only T-cells under low-dose treatment, \n        and train_adata` containing all cells except T-cells under low-dose treatment,\n\n    Note:\n        **This preprocessing step assumes the data is in the format output by Cell Ranger and is not \n        logarithmized by default unless specified.**\n    '''\n    if not normalized:\n        adata = normalize_data(adata)\n    train_adata = adata[\n        ~(\n            (adata.obs[cell_type_key] == cell_type_to_predict)\n            &amp; (adata.obs[treatment_key] == treatment_to_predict)\n        )\n    ]\n    test_adata = adata[\n        (\n            (adata.obs[cell_type_key] == cell_type_to_predict)\n            &amp; (adata.obs[treatment_key] == treatment_to_predict)\n        )\n    ]\n    train_adata = setup_anndata(\n        train_adata, copy=True, batch_key=treatment_key, labels_key=cell_type_key\n    )\n\n    return train_adata, test_adata\n</code></pre>"},{"location":"API/utils/#prepare_cont_data","title":"prepare_cont_data","text":""},{"location":"API/utils/#prepare_cont_data_1","title":"prepare_cont_data","text":"<p>Prepares training and testing data for analysis based on cell type and dose conditions.</p> <p>This function filters an <code>AnnData</code> object into train and test datasets.  The test set includes the specified cell type to predict and doses greater than the control dose. The training set includes all other data.</p> <p>The function also normalizes the data if it's not already normalized, using Scanpy's normalization functions.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>The AnnData object containing single-cell or similar biological data.</p> required <code>cell_type_key</code> <code>str</code> <p>The column name in <code>adata.obs</code> that contains cell type information.</p> required <code>treatment_key</code> <code>str</code> <p>The column name in <code>adata.obs</code> that contains treatment or condition information.</p> required <code>dose_key</code> <code>str</code> <p>The column name in <code>adata.obs</code> that contains dose information.</p> required <code>cell_type_to_predict</code> <code>str</code> <p>The cell type to be separated out for testing/prediction.</p> required <code>control_dose</code> <code>float</code> <p>The dose level used as a threshold for separating training and test data.</p> required <code>normalized</code> <code>bool</code> <p>Whether the data is already normalized. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>train_adata</code> <code>AnnData</code> <p>The training dataset, containing all cells except those with the specified <code>cell_type_to_predict</code> and doses greater than the <code>control_dose</code>.</p> <code>test_adata</code> <code>AnnData</code> <p>The test dataset, containing only the cells with the specified  <code>cell_type_to_predict</code> and doses greater than the <code>control_dose</code>.</p> Example <p>Create training and testing datasets from an AnnData object with cell type information in the  'cell_type' column of adata.obs and dose information in the 'dose' column of adata.obs. To select T-cells treated with doses greater than 100 as your testing set:</p> <pre><code>train_adata, test_adata = prepare_cont_data(\n    adata, \n    cell_type_key='cell_type', \n    treatment_key='treatment', \n    dose_key='dose', \n    cell_type_to_predict='T-cell', \n    control_dose=100, \n    normalized=False\n)\n</code></pre> <p>This will return two <code>AnnData</code> objects: <code>test_adata</code> containing only T-cells with doses greater than 100, and <code>train_adata</code> containing all other cells.</p> Note <p>This preprocessing step assumes the data is in the format output by Cell Ranger and is not  logarithmized by default unless specified.</p> Source code in <code>vidr/utils.py</code> <pre><code>def prepare_cont_data(\n    adata,\n    cell_type_key,\n    treatment_key,\n    dose_key,\n    cell_type_to_predict,\n    control_dose,\n    normalized=False,\n):\n    ''' Prepares training and testing data for analysis based on cell type and dose conditions.\n\n    This function filters an `AnnData` object into train and test datasets. \n    The test set includes the specified cell type to predict and doses greater than the control dose.\n    The training set includes all other data.\n\n    The function also normalizes the data if it's not already normalized, using Scanpy's normalization functions.\n\n    Args:\n        adata (AnnData): The AnnData object containing single-cell or similar biological data.\n        cell_type_key (str): The column name in `adata.obs` that contains cell type information.\n        treatment_key (str): The column name in `adata.obs` that contains treatment or condition information.\n        dose_key (str): The column name in `adata.obs` that contains dose information.\n        cell_type_to_predict (str): The cell type to be separated out for testing/prediction.\n        control_dose (float): The dose level used as a threshold for separating training and test data.\n        normalized (bool, optional): Whether the data is already normalized. Defaults to False.\n\n    Returns:\n        train_adata (AnnData): The training dataset, containing all cells except those with the specified\n            `cell_type_to_predict` and doses greater than the `control_dose`.\n        test_adata (AnnData): The test dataset, containing only the cells with the specified \n            `cell_type_to_predict` and doses greater than the `control_dose`.\n\n    Example:\n        Create training and testing datasets from an AnnData object with cell type information in the \n        'cell_type' column of adata.obs and dose information in the 'dose' column of adata.obs.\n        To select T-cells treated with doses greater than 100 as your testing set:\n\n        ```python\n        train_adata, test_adata = prepare_cont_data(\n            adata, \n            cell_type_key='cell_type', \n            treatment_key='treatment', \n            dose_key='dose', \n            cell_type_to_predict='T-cell', \n            control_dose=100, \n            normalized=False\n        )\n        ```\n\n        This will return two `AnnData` objects: `test_adata` containing only T-cells with doses greater than 100,\n        and `train_adata` containing all other cells.\n\n\n    Note:\n        **This preprocessing step assumes the data is in the format output by Cell Ranger and is not \n        logarithmized by default unless specified.**\n'''\n    if not normalized:\n        sc.pp.normalize_total(adata)\n        sc.pp.log1p(adata)\n        sc.pp.highly_variable_genes(adata, n_top_genes=5000)\n        adata = adata[:, adata.var.highly_variable]\n    train_adata = adata[\n        ~(\n            (adata.obs[cell_type_key] == cell_type_to_predict)\n            &amp; (adata.obs[dose_key] &gt; control_dose)\n        )\n    ]\n    test_adata = adata[\n        (\n            (adata.obs[cell_type_key] == cell_type_to_predict)\n            &amp; (adata.obs[dose_key] &gt; control_dose)\n        )\n    ]\n    train_adata = setup_anndata(\n        train_adata, copy=True, batch_key=treatment_key, labels_key=cell_type_key\n    )\n    return train_adata, test_adata\n</code></pre>"},{"location":"API/utils/#calculate_r2_singledose","title":"calculate_r2_singledose","text":""},{"location":"API/utils/#calculate_r2_singledose_1","title":"calculate_r2_singledose","text":"<p>Calculate R^2 values for single dose treatment and prediction.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Annotated data matrix.</p> required <code>cell</code> <code>str</code> <p>Cell type or identifier.</p> required <code>model</code> <code>str</code> <p>Model name or identifier.</p> required <code>condition_key</code> <code>str</code> <p>Key in <code>adata.obs</code> to distinguish conditions.</p> required <code>axis_keys</code> <code>dict</code> <p>Dictionary with keys \"x\" and \"y\" to specify conditions.</p> required <code>diff_genes</code> <code>list</code> <p>List of differentially expressed genes. Defaults to None.</p> <code>None</code> <code>random_sample_coef</code> <code>float</code> <p>Coefficient for random sampling. Defaults to None.</p> <code>None</code> <code>n_iter</code> <code>int</code> <p>Number of iterations for random sampling. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame containing R^2 values and corresponding gene sets.</p> Source code in <code>vidr/utils.py</code> <pre><code>def calculate_r2_singledose(\n    adata,\n    cell: str,\n    model: str,\n    condition_key: str,\n    axis_keys: dict,\n    diff_genes=None,\n    random_sample_coef=None,\n    n_iter: int = 1,\n):\n    '''    Calculate R^2 values for single dose treatment and prediction.\n\n    Args:\n        adata (AnnData): Annotated data matrix.\n        cell (str): Cell type or identifier.\n        model (str): Model name or identifier.\n        condition_key (str): Key in `adata.obs` to distinguish conditions.\n        axis_keys (dict): Dictionary with keys \"x\" and \"y\" to specify conditions.\n        diff_genes (list, optional): List of differentially expressed genes. Defaults to None.\n        random_sample_coef (float, optional): Coefficient for random sampling. Defaults to None.\n        n_iter (int, optional): Number of iterations for random sampling. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame containing R^2 values and corresponding gene sets.'''\n\n    # Densify sparse matrix\n    if sparse.issparse(adata.X):\n        adata.X = adata.X.A\n\n    # Treatment and Prediction\n    treat = adata[adata.obs[condition_key] == axis_keys[\"y\"]]\n    pred = adata[adata.obs[condition_key] == axis_keys[\"x\"]]\n\n    r2_values_dict = {\"R^2\": [], \"Gene Set\": []}\n    for i in range(n_iter):\n        if random_sample_coef is not None:\n            treat_idx = np.random.choice(\n                np.arange(0, treat.shape[0]), int(random_sample_coef * treat.shape[0])\n            )\n            pred_idx = np.random.choice(\n                np.arange(0, pred.shape[0]), int(random_sample_coef * pred.shape[0])\n            )\n            treat_samp = treat[treat_idx, :]\n            pred_samp = pred[pred_idx, :]\n\n        else:\n            treat_samp = treat\n            pred_samp = samp\n\n        if diff_genes is not None:\n            treat_diff = treat_samp[:, diff_genes]\n            pred_diff = pred_samp[:, diff_genes]\n\n            x_diff = np.average(pred_diff.X, axis=0)\n            y_diff = np.average(treat_diff.X, axis=0)\n            m, b, r_value_diff, p_value_diff, std_err_diff = stats.linregress(\n                x_diff, y_diff\n            )\n            r2_values_dict[\"R^2\"].append(r_value_diff**2)\n            r2_values_dict[\"Gene Set\"].append(\"DEGs\")\n\n        x = np.average(treat_samp.X, axis=0)\n        y = np.average(pred_samp.X, axis=0)\n\n        m, b, r_value, p_value, std_err = stats.linregress(x, y)\n        r2_values_dict[\"R^2\"].append(r_value**2)\n        r2_values_dict[\"Gene Set\"].append(\"All HVGs\")\n\n    r2_values_df = pd.DataFrame(r2_values_dict)\n    r2_values_df[\"Cell\"] = cell\n    r2_values_df[\"Model\"] = model\n\n    return r2_values_df\n</code></pre>"},{"location":"API/utils/#calculate_r2_multidose","title":"calculate_r2_multidose","text":""},{"location":"API/utils/#calculate_r2_multidose_1","title":"calculate_r2_multidose","text":"<p>Calculate R^2 values for multidose experiments.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Annotated data matrix.</p> required <code>cell</code> <code>str</code> <p>Cell type or identifier.</p> required <code>model</code> <code>str</code> <p>Model name or identifier.</p> required <code>condition_key</code> <code>str</code> <p>Key in <code>adata.obs</code> to distinguish conditions.</p> required <code>axis_keys</code> <code>dict</code> <p>Dictionary with keys \"x\" and \"y\" for conditions.</p> required <code>diff_genes</code> <code>list</code> <p>List of differentially expressed genes. Defaults to None.</p> <code>None</code> <code>random_sample_coef</code> <code>float</code> <p>Coefficient for random sampling. Defaults to None.</p> <code>None</code> <code>n_iter</code> <code>int</code> <p>Number of iterations for random sampling. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame containing R^2 values and associated metadata.</p> Source code in <code>vidr/utils.py</code> <pre><code>def calculate_r2_multidose(\n    adata,\n    cell: str,\n    model: str,\n    condition_key: str,\n    axis_keys: dict,\n    diff_genes=None,\n    random_sample_coef=None,\n    n_iter: int = 1,\n):\n    \"\"\"\n    Calculate R^2 values for multidose experiments.\n\n    Args:\n        adata (AnnData): Annotated data matrix.\n        cell (str): Cell type or identifier.\n        model (str): Model name or identifier.\n        condition_key (str): Key in `adata.obs` to distinguish conditions.\n        axis_keys (dict): Dictionary with keys \"x\" and \"y\" for conditions.\n        diff_genes (list, optional): List of differentially expressed genes. Defaults to None.\n        random_sample_coef (float, optional): Coefficient for random sampling. Defaults to None.\n        n_iter (int, optional): Number of iterations for random sampling. Defaults to 1.\n\n    Returns:\n        pd.DataFrame: DataFrame containing R^2 values and associated metadata.\n    \"\"\"\n\n    # Densify sparse matrix\n    if sparse.issparse(adata.X):\n        adata.X = adata.X.A\n\n    # Treatment and Prediction\n    treat = adata[adata.obs[condition_key] == axis_keys[\"y\"]]\n    pred = adata[adata.obs[condition_key] == axis_keys[\"x\"]]\n\n    r2_values_dict = {\"R^2\": [], \"Gene Set\": []}\n    for i in range(n_iter):\n        if random_sample_coef is not None:\n            treat_idx = np.random.choice(\n                np.arange(0, treat.shape[0]), int(random_sample_coef * treat.shape[0])\n            )\n            pred_idx = np.random.choice(\n                np.arange(0, pred.shape[0]), int(random_sample_coef * pred.shape[0])\n            )\n            treat_samp = treat[treat_idx, :]\n            pred_samp = pred[pred_idx, :]\n\n        else:\n            treat_samp = treat\n            pred_samp = samp\n\n        if diff_genes is not None:\n            treat_diff = treat_samp[:, diff_genes]\n            pred_diff = pred_samp[:, diff_genes]\n\n            x_diff = np.average(pred_diff.X, axis=0)\n            y_diff = np.average(treat_diff.X, axis=0)\n            m, b, r_value_diff, p_value_diff, std_err_diff = stats.linregress(\n                x_diff, y_diff\n            )\n            r2_values_dict[\"R^2\"].append(r_value_diff**2)\n            r2_values_dict[\"Gene Set\"].append(\"DEGs\")\n\n        x = np.average(treat_samp.X, axis=0)\n        y = np.average(pred_samp.X, axis=0)\n\n        m, b, r_value, p_value, std_err = stats.linregress(x, y)\n        r2_values_dict[\"R^2\"].append(r_value**2)\n        r2_values_dict[\"Gene Set\"].append(\"All HVGs\")\n\n    r2_values_df = pd.DataFrame(r2_values_dict)\n    r2_values_df[\"Cell\"] = cell\n    r2_values_df[\"Model\"] = model\n    r2_values_df[\"Dose\"] = axis_keys[\"y\"]\n    return r2_values_df\n</code></pre>"},{"location":"API/utils/#random_sample","title":"random_sample","text":""},{"location":"API/utils/#random_sample_1","title":"random_sample","text":"<p>Randomly samples and balances the populations of each cell group  based on the property of interest.</p> <p>This function randomly samples cells from groups defined by a specified key so that each group  has an equal number of cells. It can sample to match either the largest group size or the smallest  group size, with or without replacement.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>The AnnData object containing the data to balance.</p> required <code>key</code> <code>str</code> <p>The column in <code>adata.obs</code> representing the property used to group cells.</p> required <code>max_or_min</code> <code>str</code> <p>Whether to equalize the populations based on the maximum or minimum  group size. Defaults to \"max\".</p> <code>'max'</code> <code>replacement</code> <code>bool</code> <p>Whether to sample with replacement. If <code>max_or_min</code> is \"max\",  sampling will always be done with replacement. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>AnnData</code> <p>An AnnData object containing equal-sized populations for each group within the </p> <p>specified property.</p> Example <p>Create an AnnData object <code>adata</code> with cell type information in the 'cell_type' column  and sample the data so that all cell types are balanced to the size of the smallest group:</p> <pre><code>resampled_adata = random_sample(\n    adata, \n    key='cell_type', \n    max_or_min='min', \n    replacement=False\n)\n</code></pre> <p>In this example, <code>resampled_adata</code> will contain equal numbers of cells for each cell type,  with the smallest group size used for sampling. Sampling will be done without replacement.</p> Source code in <code>vidr/utils.py</code> <pre><code>def random_sample(adata, key, max_or_min=\"max\", replacement=True):\n    '''Randomly samples and balances the populations of each cell group \n    based on the property of interest.\n\n\n\n    This function randomly samples cells from groups defined by a specified key so that each group \n    has an equal number of cells. It can sample to match either the largest group size or the smallest \n    group size, with or without replacement.\n\n    Args:\n        adata (AnnData): The AnnData object containing the data to balance.\n        key (str): The column in `adata.obs` representing the property used to group cells.\n        max_or_min (str, optional): Whether to equalize the populations based on the maximum or minimum \n            group size. Defaults to \"max\".\n        replacement (bool, optional): Whether to sample with replacement. If `max_or_min` is \"max\", \n            sampling will always be done with replacement. Defaults to True.\n\n    Returns:\n        AnnData: An AnnData object containing equal-sized populations for each group within the \n        specified property.\n\n    Example:\n        Create an AnnData object `adata` with cell type information in the 'cell_type' column \n        and sample the data so that all cell types are balanced to the size of the smallest group:\n\n        ```python\n        resampled_adata = random_sample(\n            adata, \n            key='cell_type', \n            max_or_min='min', \n            replacement=False\n        )\n        ```\n\n        In this example, `resampled_adata` will contain equal numbers of cells for each cell type, \n        with the smallest group size used for sampling. Sampling will be done without replacement.\n    '''\n    # list of groups within property of interest and find their cell population sizes\n    pop_dict = Counter(adata.obs[key])\n    # Find whether we want to take the maximum or the minimum size of the population\n    eq = (\n        np.max(list(pop_dict.values()))\n        if max_or_min == \"max\"\n        else np.min(list(pop_dict.values()))\n    )\n    # replacement?\n    replacement = True if max_or_min == \"max\" else replacement\n    # Find the indexes for sampling\n    idxs = []\n    for group in pop_dict.keys():\n        group_bool = np.array(adata.obs[key] == group)\n        group_idx = np.nonzero(group_bool)[0]\n        group_idx_resampled = group_idx[\n            np.random.choice(len(group_idx), eq, replace=replacement)\n        ]\n        idxs.append(group_idx_resampled)\n\n    resampled_adata = adata[np.concatenate(idxs)].copy()\n    return resampled_adata\n</code></pre>"},{"location":"API/vidr_model/","title":"VIDRModel Class and Methods","text":""},{"location":"API/vidr_model/#vidrmodel","title":"VIDRModel","text":""},{"location":"API/vidr_model/#vidrmodel_1","title":"VIDRModel","text":"<p>               Bases: <code>BaseModuleClass</code></p> <p>Variational AutoEncoder for latent space arithmetic for perturbation prediction.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>Number of input genes.</p> required <code>hidden_dim</code> <code>int</code> <p>Number of nodes per hidden layer. Defaults to 800.</p> <code>800</code> <code>latent_dim</code> <code>int</code> <p>Dimensionality of the latent space. Defaults to 10.</p> <code>10</code> <code>n_hidden_layers</code> <code>int</code> <p>Number of hidden layers used for encoder and decoder NNs. Defaults to 2.</p> <code>2</code> <code>dropout_rate</code> <code>float</code> <p>Dropout rate for neural networks. Defaults to 0.1.</p> <code>0.1</code> <code>latent_distribution</code> <code>str</code> <p>Distribution of the latent space. Defaults to \"normal\".</p> <code>'normal'</code> <code>kl_weight</code> <code>float</code> <p>Weight for KL divergence. Defaults to 0.00005.</p> <code>5e-05</code> <code>linear_decoder</code> <code>bool</code> <p>Whether to use a linear decoder for a more interpretable model. Defaults to True.</p> <code>True</code> <code>nca_loss</code> <code>bool</code> <p>Whether to use NCA loss. Defaults to False.</p> <code>False</code> <code>dose_loss</code> <code>optional</code> <p>Dose loss. Defaults to None.</p> <code>None</code> Source code in <code>vidr/vidr_model.py</code> <pre><code>class VIDRModel(BaseModuleClass):\n    \"\"\"Variational AutoEncoder for latent space arithmetic for perturbation prediction.\n\n    Args:\n        input_dim (int): Number of input genes.\n        hidden_dim (int, optional): Number of nodes per hidden layer. Defaults to 800.\n        latent_dim (int, optional): Dimensionality of the latent space. Defaults to 10.\n        n_hidden_layers (int, optional): Number of hidden layers used for encoder and decoder NNs. Defaults to 2.\n        dropout_rate (float, optional): Dropout rate for neural networks. Defaults to 0.1.\n        latent_distribution (str, optional): Distribution of the latent space. Defaults to \"normal\".\n        kl_weight (float, optional): Weight for KL divergence. Defaults to 0.00005.\n        linear_decoder (bool, optional): Whether to use a linear decoder for a more interpretable model. Defaults to True.\n        nca_loss (bool, optional): Whether to use NCA loss. Defaults to False.\n        dose_loss (optional): Dose loss. Defaults to None.\n    \"\"\"\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int = 800,\n        latent_dim: int = 10,\n        n_hidden_layers: int = 2,\n        dropout_rate: float = 0.1,\n        latent_distribution: str = \"normal\",\n        kl_weight: float = 0.00005,\n        linear_decoder: bool = True,\n        nca_loss: bool = False,\n        dose_loss=None,\n    ):\n        super().__init__()\n        self.n_hidden_layers = n_hidden_layers\n        self.latent_dim = latent_dim\n        self.latent_distribution = \"normal\"\n        self.kl_weight = kl_weight\n        self.nca_loss = nca_loss\n        self.dose_loss = dose_loss\n\n        # Encoder\n        self.encoder = VIDREncoder(input_dim, latent_dim, hidden_dim, n_hidden_layers)\n\n        # Decoder\n        self.nonlin_decoder = VIDRDecoder(\n            input_dim, latent_dim, hidden_dim, n_hidden_layers\n        )\n\n        self.lin_decoder = torch.nn.Sequential(\n            nn.Linear(latent_dim, input_dim),\n            nn.BatchNorm1d(input_dim, momentum=0.01, eps=0.001),\n        )\n\n        self.decoder = self.lin_decoder if linear_decoder else self.nonlin_decoder\n\n    def _get_inference_input(self, tensors: dict) -&gt; dict:\n        \"\"\"\n        Prepares the input for the inference model.\n\n        Args:\n            tensors (dict): Dictionary of input tensors.\n\n        Returns:\n            dict: Dictionary containing the input for the inference model.\n        \"\"\"\n        x = tensors[_CONSTANTS.X_KEY]\n        input_dict = dict(x=x)\n        return input_dict\n\n    def _get_generative_input(self, tensors: dict, inference_outputs: dict) -&gt; dict:\n        \"\"\"\n        Prepares the input for the generative model.\n\n        Args:\n            tensors (dict): Dictionary of input tensors.\n            inference_outputs (dict): Dictionary of outputs from the inference model.\n\n        Returns:\n            dict: Dictionary containing the input for the generative model.\n        \"\"\"\n        z = inference_outputs[\"z\"]\n        input_dict = {\"z\": z}\n        return input_dict\n\n    @auto_move_data\n    def inference(self, x: torch.Tensor) -&gt; dict:\n        \"\"\"\n        High level inference method.\n        Runs the inference (encoder) model.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            dict: Dictionary containing the outputs of the inference model.\n        \"\"\"\n        mean, var, latent_rep = self.encoder(x)\n        outputs = dict(z=latent_rep, qz_m=mean, qz_v=var)\n        return outputs\n\n    @auto_move_data\n    def generative(self, z: torch.Tensor) -&gt; dict:\n        \"\"\"\n        Runs the generative model.\n\n        Args:\n            z (torch.Tensor): Latent space tensor.\n\n        Returns:\n            dict: Dictionary containing the outputs of the generative model.\n        \"\"\"\n        px = self.decoder(z)\n        return dict(px=px)\n\n    def loss(\n        self,\n        tensors: dict,\n        inference_outputs: dict,\n        generative_outputs: dict,\n    ) -&gt; LossRecorder:\n        \"\"\"\n        Computes the loss for the model.\n\n        Args:\n            tensors (dict): Dictionary of input tensors.\n            inference_outputs (dict): Dictionary of outputs from the inference model.\n            generative_outputs (dict): Dictionary of outputs from the generative model.\n\n        Returns:\n            LossRecorder: Object containing the computed loss.\n        \"\"\"\n        x = tensors[_CONSTANTS.X_KEY]\n        mean = inference_outputs[\"qz_m\"]\n        var = inference_outputs[\"qz_v\"]\n        x_hat = generative_outputs[\"px\"]\n\n        std = var.sqrt()\n\n        kld = kl(\n            Normal(mean, std),\n            Normal(0, 1),\n        ).sum(dim=1)\n\n        rl = self.get_reconstruction_loss(x, x_hat)\n        if self.nca_loss:\n            if np.any(self.dose_loss != None):\n                disc_labels = [tensors[\"labels\"]]\n                cont_inds = tensors[\"batch_indices\"].cpu().detach().numpy()\n                cont_labels = []\n                cont_labels.append(\n                    torch.tensor([[self.dose_loss[int(i[0])]] for i in cont_inds]).to(\n                        device\n                    )\n                )\n                ncal, disc_loss, cont_loss = self.get_nca_loss(\n                    mean, disc_labels, cont_labels\n                )\n            else:\n                disc_labels = [tensors[\"batch_indices\"], tensors[\"labels\"]]\n                cont_labels = None\n                ncal, disc_loss, cont_loss = self.get_nca_loss(\n                    mean, disc_labels, cont_labels\n                )\n        else:\n            ncal = torch.tensor(0, device=device)\n\n        loss = (0.5 * rl + 0.5 * (kld * self.kl_weight)).mean() - 10 * ncal\n        return LossRecorder(loss, rl, kld, kl_global=0.0)\n\n    @torch.no_grad()\n    def sample(\n        self,\n        tensors: dict,\n        n_samples: int = 1,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Generate observation samples from the posterior predictive distribution.\n        The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n        Args:\n            tensors (dict): Dictionary of input tensors.\n            n_samples (int, optional): Number of required samples for each cell. Defaults to 1.\n\n        Returns:\n            np.ndarray: Array with shape (n_cells, n_genes, n_samples) containing the generated samples.\n        \"\"\"\n        inference_kwargs = dict(n_samples=n_samples)\n        (\n            inference_outputs,\n            generative_outputs,\n        ) = self.forward(\n            tensors,\n            inference_kwargs=inference_kwargs,\n            compute_loss=False,\n        )\n        px = Normal(generative_outputs[\"px\"], 1).sample()\n        return px.cpu().numpy()\n\n    def get_reconstruction_loss(self, x: torch.Tensor, x_hat: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"\n        Computes the reconstruction loss.\n\n        Args:\n            x (torch.Tensor): Original input tensor.\n            x_hat (torch.Tensor): Reconstructed input tensor.\n\n        Returns:\n            torch.Tensor: Tensor containing the reconstruction loss.\n        \"\"\"\n        loss = ((x - x_hat) ** 2).sum(dim=1)\n        return loss\n\n    def get_nca_loss(self, z: torch.Tensor, disc: list, cont: list) -&gt; torch.Tensor:\n        \"\"\"\n        Computes the NCA loss.\n\n        Args:\n            z (torch.Tensor): Latent space tensor.\n            disc (list): List of discrete labels.\n            cont (list): List of continuous labels.\n\n        Returns:\n            torch.Tensor: Tensor containing the NCA loss.\n        \"\"\"\n        # losses list\n        losses = []\n\n        # Distance Matrix\n        d1 = z.clone()\n        d2 = z.clone()\n        dist = torch.cdist(d1, d2, p=2)\n        p = dist.clone()\n\n        # Set diagonal to inf\n        p.diagonal().copy_(np.inf * torch.ones(len(p)))\n        # Softmax\n        p = torch.softmax(-p, dim=1)\n\n        # Calculating Latent Loss for Discrete Labels\n        if disc is not None:\n            cells = len(disc[0])\n            masks = np.zeros((cells, cells))\n            maxVal = 0\n            for Y in disc:\n                Y = Y.cpu().detach().numpy()\n                Y = np.asarray([y[0] for y in Y])\n                counts = Counter(Y)\n                area_counts = {k: v for k, v in list(counts.items())}\n                m = Y[:, np.newaxis] == Y[np.newaxis, :]\n                # Count number of labels (for each unique label)\n                for k, v in list(area_counts.items()):\n                    if \"nan\" != str(k):\n                        maxVal += 1\n                        masks = masks + m * (Y == k) * (1 / v)\n            if maxVal != 0:\n                masks = masks * (1 / maxVal)\n\n            masks = torch.from_numpy(masks).float().to(device)\n\n            masked_p = p * masks\n            losses += [torch.sum(masked_p)]\n\n        else:\n            losses += [torch.tensor(0, device=device)]\n\n        if cont is not None:\n            cells = len(cont[0])\n            n_cont_weights = len(cont)\n\n            weights = torch.empty(\n                (cells, cells * len(cont)), dtype=torch.float, device=device\n            )\n            for n in range(n_cont_weights):\n                Y = cont[n]\n                Y1 = Y.clone()\n                Y2 = Y.clone()\n                dist = torch.cdist(Y1, Y2)  # Get distances between continuous labels\n                cont_dists = dist.clone()\n                cont_dists.diagonal().copy_(\n                    np.inf * torch.ones(len(cont_dists))\n                )  # Set diagonal to inf\n                cont_dists = torch.nan_to_num(\n                    cont_dists, nan=np.inf\n                )  # Use nans for data missing labels\n                cont_dists = torch.softmax(-cont_dists, dim=1)  # soft max\n                s = cells * n\n                e = cells * (n + 1)\n                weights[:, s:e] = cont_dists\n\n            for n in range(0, n_cont_weights):\n                s = cells * n\n                e = cells * (n + 1)\n                weight_calc = p * weights[:, s:e]\n                m, m_indexes = torch.max(weights[:, s:e], dim=1)\n                masked_p = weight_calc / torch.sum(m)\n                cont_max, inds = torch.max(masked_p, dim=1)\n                losses += [torch.sum(masked_p)]\n\n        lossVals = torch.stack(losses, dim=0)\n\n        scaled_losses = lossVals\n\n        disc_loss = torch.sum(scaled_losses[0])\n\n        if cont is not None:\n            cont_loss = torch.sum(*scaled_losses[1:])\n        else:\n            cont_loss = torch.tensor(0, device=device)\n\n        loss = disc_loss + cont_loss\n        return loss, disc_loss, cont_loss\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.generative","title":"<code>generative(z)</code>","text":"<p>Runs the generative model.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Tensor</code> <p>Latent space tensor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the outputs of the generative model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@auto_move_data\ndef generative(self, z: torch.Tensor) -&gt; dict:\n    \"\"\"\n    Runs the generative model.\n\n    Args:\n        z (torch.Tensor): Latent space tensor.\n\n    Returns:\n        dict: Dictionary containing the outputs of the generative model.\n    \"\"\"\n    px = self.decoder(z)\n    return dict(px=px)\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.get_nca_loss","title":"<code>get_nca_loss(z, disc, cont)</code>","text":"<p>Computes the NCA loss.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Tensor</code> <p>Latent space tensor.</p> required <code>disc</code> <code>list</code> <p>List of discrete labels.</p> required <code>cont</code> <code>list</code> <p>List of continuous labels.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Tensor containing the NCA loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def get_nca_loss(self, z: torch.Tensor, disc: list, cont: list) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the NCA loss.\n\n    Args:\n        z (torch.Tensor): Latent space tensor.\n        disc (list): List of discrete labels.\n        cont (list): List of continuous labels.\n\n    Returns:\n        torch.Tensor: Tensor containing the NCA loss.\n    \"\"\"\n    # losses list\n    losses = []\n\n    # Distance Matrix\n    d1 = z.clone()\n    d2 = z.clone()\n    dist = torch.cdist(d1, d2, p=2)\n    p = dist.clone()\n\n    # Set diagonal to inf\n    p.diagonal().copy_(np.inf * torch.ones(len(p)))\n    # Softmax\n    p = torch.softmax(-p, dim=1)\n\n    # Calculating Latent Loss for Discrete Labels\n    if disc is not None:\n        cells = len(disc[0])\n        masks = np.zeros((cells, cells))\n        maxVal = 0\n        for Y in disc:\n            Y = Y.cpu().detach().numpy()\n            Y = np.asarray([y[0] for y in Y])\n            counts = Counter(Y)\n            area_counts = {k: v for k, v in list(counts.items())}\n            m = Y[:, np.newaxis] == Y[np.newaxis, :]\n            # Count number of labels (for each unique label)\n            for k, v in list(area_counts.items()):\n                if \"nan\" != str(k):\n                    maxVal += 1\n                    masks = masks + m * (Y == k) * (1 / v)\n        if maxVal != 0:\n            masks = masks * (1 / maxVal)\n\n        masks = torch.from_numpy(masks).float().to(device)\n\n        masked_p = p * masks\n        losses += [torch.sum(masked_p)]\n\n    else:\n        losses += [torch.tensor(0, device=device)]\n\n    if cont is not None:\n        cells = len(cont[0])\n        n_cont_weights = len(cont)\n\n        weights = torch.empty(\n            (cells, cells * len(cont)), dtype=torch.float, device=device\n        )\n        for n in range(n_cont_weights):\n            Y = cont[n]\n            Y1 = Y.clone()\n            Y2 = Y.clone()\n            dist = torch.cdist(Y1, Y2)  # Get distances between continuous labels\n            cont_dists = dist.clone()\n            cont_dists.diagonal().copy_(\n                np.inf * torch.ones(len(cont_dists))\n            )  # Set diagonal to inf\n            cont_dists = torch.nan_to_num(\n                cont_dists, nan=np.inf\n            )  # Use nans for data missing labels\n            cont_dists = torch.softmax(-cont_dists, dim=1)  # soft max\n            s = cells * n\n            e = cells * (n + 1)\n            weights[:, s:e] = cont_dists\n\n        for n in range(0, n_cont_weights):\n            s = cells * n\n            e = cells * (n + 1)\n            weight_calc = p * weights[:, s:e]\n            m, m_indexes = torch.max(weights[:, s:e], dim=1)\n            masked_p = weight_calc / torch.sum(m)\n            cont_max, inds = torch.max(masked_p, dim=1)\n            losses += [torch.sum(masked_p)]\n\n    lossVals = torch.stack(losses, dim=0)\n\n    scaled_losses = lossVals\n\n    disc_loss = torch.sum(scaled_losses[0])\n\n    if cont is not None:\n        cont_loss = torch.sum(*scaled_losses[1:])\n    else:\n        cont_loss = torch.tensor(0, device=device)\n\n    loss = disc_loss + cont_loss\n    return loss, disc_loss, cont_loss\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.get_reconstruction_loss","title":"<code>get_reconstruction_loss(x, x_hat)</code>","text":"<p>Computes the reconstruction loss.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Original input tensor.</p> required <code>x_hat</code> <code>Tensor</code> <p>Reconstructed input tensor.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Tensor containing the reconstruction loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def get_reconstruction_loss(self, x: torch.Tensor, x_hat: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the reconstruction loss.\n\n    Args:\n        x (torch.Tensor): Original input tensor.\n        x_hat (torch.Tensor): Reconstructed input tensor.\n\n    Returns:\n        torch.Tensor: Tensor containing the reconstruction loss.\n    \"\"\"\n    loss = ((x - x_hat) ** 2).sum(dim=1)\n    return loss\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.inference","title":"<code>inference(x)</code>","text":"<p>High level inference method. Runs the inference (encoder) model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the outputs of the inference model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@auto_move_data\ndef inference(self, x: torch.Tensor) -&gt; dict:\n    \"\"\"\n    High level inference method.\n    Runs the inference (encoder) model.\n\n    Args:\n        x (torch.Tensor): Input tensor.\n\n    Returns:\n        dict: Dictionary containing the outputs of the inference model.\n    \"\"\"\n    mean, var, latent_rep = self.encoder(x)\n    outputs = dict(z=latent_rep, qz_m=mean, qz_v=var)\n    return outputs\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.loss","title":"<code>loss(tensors, inference_outputs, generative_outputs)</code>","text":"<p>Computes the loss for the model.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <code>inference_outputs</code> <code>dict</code> <p>Dictionary of outputs from the inference model.</p> required <code>generative_outputs</code> <code>dict</code> <p>Dictionary of outputs from the generative model.</p> required <p>Returns:</p> Name Type Description <code>LossRecorder</code> <code>LossRecorder</code> <p>Object containing the computed loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def loss(\n    self,\n    tensors: dict,\n    inference_outputs: dict,\n    generative_outputs: dict,\n) -&gt; LossRecorder:\n    \"\"\"\n    Computes the loss for the model.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n        inference_outputs (dict): Dictionary of outputs from the inference model.\n        generative_outputs (dict): Dictionary of outputs from the generative model.\n\n    Returns:\n        LossRecorder: Object containing the computed loss.\n    \"\"\"\n    x = tensors[_CONSTANTS.X_KEY]\n    mean = inference_outputs[\"qz_m\"]\n    var = inference_outputs[\"qz_v\"]\n    x_hat = generative_outputs[\"px\"]\n\n    std = var.sqrt()\n\n    kld = kl(\n        Normal(mean, std),\n        Normal(0, 1),\n    ).sum(dim=1)\n\n    rl = self.get_reconstruction_loss(x, x_hat)\n    if self.nca_loss:\n        if np.any(self.dose_loss != None):\n            disc_labels = [tensors[\"labels\"]]\n            cont_inds = tensors[\"batch_indices\"].cpu().detach().numpy()\n            cont_labels = []\n            cont_labels.append(\n                torch.tensor([[self.dose_loss[int(i[0])]] for i in cont_inds]).to(\n                    device\n                )\n            )\n            ncal, disc_loss, cont_loss = self.get_nca_loss(\n                mean, disc_labels, cont_labels\n            )\n        else:\n            disc_labels = [tensors[\"batch_indices\"], tensors[\"labels\"]]\n            cont_labels = None\n            ncal, disc_loss, cont_loss = self.get_nca_loss(\n                mean, disc_labels, cont_labels\n            )\n    else:\n        ncal = torch.tensor(0, device=device)\n\n    loss = (0.5 * rl + 0.5 * (kld * self.kl_weight)).mean() - 10 * ncal\n    return LossRecorder(loss, rl, kld, kl_global=0.0)\n</code></pre>"},{"location":"API/vidr_model/#vidr.vidr_model.VIDRModel.sample","title":"<code>sample(tensors, n_samples=1)</code>","text":"<p>Generate observation samples from the posterior predictive distribution. The posterior predictive distribution is written as :math:<code>p(\\hat{x} \\mid x)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <code>n_samples</code> <code>int</code> <p>Number of required samples for each cell. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array with shape (n_cells, n_genes, n_samples) containing the generated samples.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@torch.no_grad()\ndef sample(\n    self,\n    tensors: dict,\n    n_samples: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate observation samples from the posterior predictive distribution.\n    The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n        n_samples (int, optional): Number of required samples for each cell. Defaults to 1.\n\n    Returns:\n        np.ndarray: Array with shape (n_cells, n_genes, n_samples) containing the generated samples.\n    \"\"\"\n    inference_kwargs = dict(n_samples=n_samples)\n    (\n        inference_outputs,\n        generative_outputs,\n    ) = self.forward(\n        tensors,\n        inference_kwargs=inference_kwargs,\n        compute_loss=False,\n    )\n    px = Normal(generative_outputs[\"px\"], 1).sample()\n    return px.cpu().numpy()\n</code></pre>"},{"location":"API/vidr_model/#_get_inference_input","title":"_get_inference_input","text":""},{"location":"API/vidr_model/#_get_inference_input_1","title":"_get_inference_input","text":"<p>Prepares the input for the inference model.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the input for the inference model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def _get_inference_input(self, tensors: dict) -&gt; dict:\n    \"\"\"\n    Prepares the input for the inference model.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n\n    Returns:\n        dict: Dictionary containing the input for the inference model.\n    \"\"\"\n    x = tensors[_CONSTANTS.X_KEY]\n    input_dict = dict(x=x)\n    return input_dict\n</code></pre>"},{"location":"API/vidr_model/#_get_generative_input","title":"_get_generative_input","text":""},{"location":"API/vidr_model/#_get_generative_input_1","title":"_get_generative_input","text":"<p>Prepares the input for the generative model.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <code>inference_outputs</code> <code>dict</code> <p>Dictionary of outputs from the inference model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the input for the generative model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def _get_generative_input(self, tensors: dict, inference_outputs: dict) -&gt; dict:\n    \"\"\"\n    Prepares the input for the generative model.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n        inference_outputs (dict): Dictionary of outputs from the inference model.\n\n    Returns:\n        dict: Dictionary containing the input for the generative model.\n    \"\"\"\n    z = inference_outputs[\"z\"]\n    input_dict = {\"z\": z}\n    return input_dict\n</code></pre>"},{"location":"API/vidr_model/#inference","title":"inference","text":""},{"location":"API/vidr_model/#inference_1","title":"inference","text":"<p>High level inference method. Runs the inference (encoder) model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input tensor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the outputs of the inference model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@auto_move_data\ndef inference(self, x: torch.Tensor) -&gt; dict:\n    \"\"\"\n    High level inference method.\n    Runs the inference (encoder) model.\n\n    Args:\n        x (torch.Tensor): Input tensor.\n\n    Returns:\n        dict: Dictionary containing the outputs of the inference model.\n    \"\"\"\n    mean, var, latent_rep = self.encoder(x)\n    outputs = dict(z=latent_rep, qz_m=mean, qz_v=var)\n    return outputs\n</code></pre>"},{"location":"API/vidr_model/#generative","title":"generative","text":""},{"location":"API/vidr_model/#generative_1","title":"generative","text":"<p>Runs the generative model.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Tensor</code> <p>Latent space tensor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the outputs of the generative model.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@auto_move_data\ndef generative(self, z: torch.Tensor) -&gt; dict:\n    \"\"\"\n    Runs the generative model.\n\n    Args:\n        z (torch.Tensor): Latent space tensor.\n\n    Returns:\n        dict: Dictionary containing the outputs of the generative model.\n    \"\"\"\n    px = self.decoder(z)\n    return dict(px=px)\n</code></pre>"},{"location":"API/vidr_model/#loss","title":"loss","text":""},{"location":"API/vidr_model/#loss_1","title":"loss","text":"<p>Computes the loss for the model.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <code>inference_outputs</code> <code>dict</code> <p>Dictionary of outputs from the inference model.</p> required <code>generative_outputs</code> <code>dict</code> <p>Dictionary of outputs from the generative model.</p> required <p>Returns:</p> Name Type Description <code>LossRecorder</code> <code>LossRecorder</code> <p>Object containing the computed loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def loss(\n    self,\n    tensors: dict,\n    inference_outputs: dict,\n    generative_outputs: dict,\n) -&gt; LossRecorder:\n    \"\"\"\n    Computes the loss for the model.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n        inference_outputs (dict): Dictionary of outputs from the inference model.\n        generative_outputs (dict): Dictionary of outputs from the generative model.\n\n    Returns:\n        LossRecorder: Object containing the computed loss.\n    \"\"\"\n    x = tensors[_CONSTANTS.X_KEY]\n    mean = inference_outputs[\"qz_m\"]\n    var = inference_outputs[\"qz_v\"]\n    x_hat = generative_outputs[\"px\"]\n\n    std = var.sqrt()\n\n    kld = kl(\n        Normal(mean, std),\n        Normal(0, 1),\n    ).sum(dim=1)\n\n    rl = self.get_reconstruction_loss(x, x_hat)\n    if self.nca_loss:\n        if np.any(self.dose_loss != None):\n            disc_labels = [tensors[\"labels\"]]\n            cont_inds = tensors[\"batch_indices\"].cpu().detach().numpy()\n            cont_labels = []\n            cont_labels.append(\n                torch.tensor([[self.dose_loss[int(i[0])]] for i in cont_inds]).to(\n                    device\n                )\n            )\n            ncal, disc_loss, cont_loss = self.get_nca_loss(\n                mean, disc_labels, cont_labels\n            )\n        else:\n            disc_labels = [tensors[\"batch_indices\"], tensors[\"labels\"]]\n            cont_labels = None\n            ncal, disc_loss, cont_loss = self.get_nca_loss(\n                mean, disc_labels, cont_labels\n            )\n    else:\n        ncal = torch.tensor(0, device=device)\n\n    loss = (0.5 * rl + 0.5 * (kld * self.kl_weight)).mean() - 10 * ncal\n    return LossRecorder(loss, rl, kld, kl_global=0.0)\n</code></pre>"},{"location":"API/vidr_model/#sample","title":"sample","text":""},{"location":"API/vidr_model/#sample_1","title":"sample","text":"<p>Generate observation samples from the posterior predictive distribution. The posterior predictive distribution is written as :math:<code>p(\\hat{x} \\mid x)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>dict</code> <p>Dictionary of input tensors.</p> required <code>n_samples</code> <code>int</code> <p>Number of required samples for each cell. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array with shape (n_cells, n_genes, n_samples) containing the generated samples.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>@torch.no_grad()\ndef sample(\n    self,\n    tensors: dict,\n    n_samples: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate observation samples from the posterior predictive distribution.\n    The posterior predictive distribution is written as :math:`p(\\hat{x} \\mid x)`.\n\n    Args:\n        tensors (dict): Dictionary of input tensors.\n        n_samples (int, optional): Number of required samples for each cell. Defaults to 1.\n\n    Returns:\n        np.ndarray: Array with shape (n_cells, n_genes, n_samples) containing the generated samples.\n    \"\"\"\n    inference_kwargs = dict(n_samples=n_samples)\n    (\n        inference_outputs,\n        generative_outputs,\n    ) = self.forward(\n        tensors,\n        inference_kwargs=inference_kwargs,\n        compute_loss=False,\n    )\n    px = Normal(generative_outputs[\"px\"], 1).sample()\n    return px.cpu().numpy()\n</code></pre>"},{"location":"API/vidr_model/#get_reconstruction_loss","title":"get_reconstruction_loss","text":""},{"location":"API/vidr_model/#get_reconstruction_loss_1","title":"get_reconstruction_loss","text":"<p>Computes the reconstruction loss.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Original input tensor.</p> required <code>x_hat</code> <code>Tensor</code> <p>Reconstructed input tensor.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Tensor containing the reconstruction loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def get_reconstruction_loss(self, x: torch.Tensor, x_hat: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the reconstruction loss.\n\n    Args:\n        x (torch.Tensor): Original input tensor.\n        x_hat (torch.Tensor): Reconstructed input tensor.\n\n    Returns:\n        torch.Tensor: Tensor containing the reconstruction loss.\n    \"\"\"\n    loss = ((x - x_hat) ** 2).sum(dim=1)\n    return loss\n</code></pre>"},{"location":"API/vidr_model/#get_nca_loss","title":"get_nca_loss","text":""},{"location":"API/vidr_model/#get_nca_loss_1","title":"get_nca_loss","text":"<p>Computes the NCA loss.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Tensor</code> <p>Latent space tensor.</p> required <code>disc</code> <code>list</code> <p>List of discrete labels.</p> required <code>cont</code> <code>list</code> <p>List of continuous labels.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Tensor containing the NCA loss.</p> Source code in <code>vidr/vidr_model.py</code> <pre><code>def get_nca_loss(self, z: torch.Tensor, disc: list, cont: list) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the NCA loss.\n\n    Args:\n        z (torch.Tensor): Latent space tensor.\n        disc (list): List of discrete labels.\n        cont (list): List of continuous labels.\n\n    Returns:\n        torch.Tensor: Tensor containing the NCA loss.\n    \"\"\"\n    # losses list\n    losses = []\n\n    # Distance Matrix\n    d1 = z.clone()\n    d2 = z.clone()\n    dist = torch.cdist(d1, d2, p=2)\n    p = dist.clone()\n\n    # Set diagonal to inf\n    p.diagonal().copy_(np.inf * torch.ones(len(p)))\n    # Softmax\n    p = torch.softmax(-p, dim=1)\n\n    # Calculating Latent Loss for Discrete Labels\n    if disc is not None:\n        cells = len(disc[0])\n        masks = np.zeros((cells, cells))\n        maxVal = 0\n        for Y in disc:\n            Y = Y.cpu().detach().numpy()\n            Y = np.asarray([y[0] for y in Y])\n            counts = Counter(Y)\n            area_counts = {k: v for k, v in list(counts.items())}\n            m = Y[:, np.newaxis] == Y[np.newaxis, :]\n            # Count number of labels (for each unique label)\n            for k, v in list(area_counts.items()):\n                if \"nan\" != str(k):\n                    maxVal += 1\n                    masks = masks + m * (Y == k) * (1 / v)\n        if maxVal != 0:\n            masks = masks * (1 / maxVal)\n\n        masks = torch.from_numpy(masks).float().to(device)\n\n        masked_p = p * masks\n        losses += [torch.sum(masked_p)]\n\n    else:\n        losses += [torch.tensor(0, device=device)]\n\n    if cont is not None:\n        cells = len(cont[0])\n        n_cont_weights = len(cont)\n\n        weights = torch.empty(\n            (cells, cells * len(cont)), dtype=torch.float, device=device\n        )\n        for n in range(n_cont_weights):\n            Y = cont[n]\n            Y1 = Y.clone()\n            Y2 = Y.clone()\n            dist = torch.cdist(Y1, Y2)  # Get distances between continuous labels\n            cont_dists = dist.clone()\n            cont_dists.diagonal().copy_(\n                np.inf * torch.ones(len(cont_dists))\n            )  # Set diagonal to inf\n            cont_dists = torch.nan_to_num(\n                cont_dists, nan=np.inf\n            )  # Use nans for data missing labels\n            cont_dists = torch.softmax(-cont_dists, dim=1)  # soft max\n            s = cells * n\n            e = cells * (n + 1)\n            weights[:, s:e] = cont_dists\n\n        for n in range(0, n_cont_weights):\n            s = cells * n\n            e = cells * (n + 1)\n            weight_calc = p * weights[:, s:e]\n            m, m_indexes = torch.max(weights[:, s:e], dim=1)\n            masked_p = weight_calc / torch.sum(m)\n            cont_max, inds = torch.max(masked_p, dim=1)\n            losses += [torch.sum(masked_p)]\n\n    lossVals = torch.stack(losses, dim=0)\n\n    scaled_losses = lossVals\n\n    disc_loss = torch.sum(scaled_losses[0])\n\n    if cont is not None:\n        cont_loss = torch.sum(*scaled_losses[1:])\n    else:\n        cont_loss = torch.tensor(0, device=device)\n\n    loss = disc_loss + cont_loss\n    return loss, disc_loss, cont_loss\n</code></pre>"},{"location":"explanation/explanation-introduction/","title":"Explanation - Background information and conceptual discussions that provide context and illuminate topics more broadly.","text":""},{"location":"installation/getting-started/","title":"Installation","text":"<p>Please follow the guide below to install SCVIDR and its dependent software.</p>"},{"location":"installation/getting-started/#docker-image","title":"Docker Image","text":"<p>A pre-built Docker image is available through Docker Hub.</p> <p>This Docker image is built based on Mac and includes the SCVIDR software and its dependencies.</p>"},{"location":"installation/getting-started/#quick-start-with-docker","title":"Quick Start with Docker","text":"<p>In this section, we provide example commands for our SCVIDR Docker image. We assume you have basic knowledge of Docker. If not, we highly recommend learning about Docker first.</p>"},{"location":"installation/getting-started/#step-1-download-the-scvidr-docker-image","title":"Step 1: Download the SCVIDR Docker image","text":"<p>First, download the SCVIDR Docker image from Docker Hub:</p> <pre><code>docker pull bhattacharyalab/scvidr:with-data\n</code></pre> <p>This version includes the full SCVIDR setup along with the data/ folder.</p> <p>If you prefer a lighter version without the data/ folder, use:</p> <p><pre><code>docker pull bhattacharyalab/scvidr:no-data\n</code></pre> This version is smaller and suitable if you want to supply your own data separately.</p>"},{"location":"installation/getting-started/#step-2-create-and-run-a-docker-container","title":"Step 2: Create and run a Docker container","text":"<p>To run a Docker container with SCVIDR, you need to set up the ports for easy access. Here's how:</p> <ol> <li> <p>Run the Docker container:</p> <p>Use the following command to run the Docker container:</p> <pre><code>docker run -dit \\\n  --name scvidr_container \\\n  -p 8888:8988 \\\n  bhattacharyalab/scvidr:with-data\n</code></pre> <p>Here's what each part of the command does:</p> <ul> <li><code>docker run</code>: This command is used to create and start a new container from an image.</li> <li><code>-dit</code>: </li> <li><code>-d</code> (detached mode): Runs the container in the background.</li> <li><code>-i</code> (interactive): Keeps STDIN open, allowing interaction with the container.</li> <li><code>-t</code> (tty): Allocates a pseudo-terminal, allowing you to interact with the container's shell.</li> <li><code>--name scvidr_container</code>: Assigns a custom name (<code>scvidr_container</code>) to your running container so that it can be easily identified.</li> <li><code>-p 8988:8988</code>: Maps port 8988 on your local machine to port 8988 inside the Docker container. This allows you to access Jupyter Notebook running inside the container at <code>http://localhost:8988</code>. If port 8988 is already in use, replace the left side of the port mapping (e.g., <code>-p 8899:8988</code>) and access Jupyter at <code>http://localhost:8899</code>. Alternatively, you can copy the link provided in the terminal output after running the Jupyter Lab command inside the container, which includes the token for login.</li> <li><code>bhattacharyalab/scvidr:with-data</code>: Specifies the Docker image to use, in this case, the <code>scvidr</code> image from Docker Hub.</li> </ul> </li> </ol> <p>If you're using the <code>no-data</code> container, you can bind your local <code>data</code> folder to the container using <code>-v /full_data_path/data:/scVIDR/data</code>.</p>"},{"location":"installation/getting-started/#step-3-access-the-docker-container","title":"Step 3: Access the Docker container","text":"<p>To enter the Docker container, run the following command:</p> <pre><code>docker container exec -it scvidr_container /bin/bash\n</code></pre>"},{"location":"installation/getting-started/#step-4-start-jupyter-notebook","title":"Step 4: Start Jupyter Notebook","text":"<p>Once inside the Docker container, you can start Jupyter Notebook with the following commands:</p> <pre><code>jupyter lab --port=8988 --ip=0.0.0.0 --allow-root --no-browser\n</code></pre>"},{"location":"installation/getting-started/#adding-gpu-support","title":"Adding GPU Support","text":"<p>SCVIDR can be GPU-accelerated for faster training of models. GPU support is available on Linux and Windows (via WSL 2) systems with an NVIDIA GPU and proper drivers. Unfortunately, macOS does not support GPU passthrough for Docker containers.</p>"},{"location":"installation/getting-started/#gpu-setup-for-linux","title":"GPU Setup for Linux","text":"<ol> <li>Install the NVIDIA GPU drivers:</li> <li> <p>Ensure you have the latest NVIDIA drivers installed for your GPU.</p> </li> <li> <p>Install the NVIDIA Container Toolkit:    <pre><code>sudo apt-get update\nsudo apt-get install -y nvidia-container-toolkit\nsudo systemctl restart docker\n</code></pre></p> </li> <li> <p>Access the Docker container with GPUS:   <pre><code>docker run --gpus all -dit \\\n--name scvidr_gpu_container \\\n-p 8888:8988 \\\nbhattacharyalab/scvidr:with-data\n</code></pre> Note: Ensure that CUDA drivers are installed on the host machine if they aren\u2019t already. Refer to the CUDA Installation Guide for detailed instructions.</p> </li> <li> <p>Verify GPU access: You can verify that the GPU is accessible inside the container by running. <pre><code>docker exec -it scvidr_gpu_container /bin/bash\nnvidia-smi\n</code></pre></p> </li> </ol>"},{"location":"installation/getting-started/#gpu-support-not-available-on-macos","title":"GPU Support Not Available on macOS","text":"<ul> <li>macOS does not support GPU passthrough for Docker containers, meaning you cannot utilize GPUs for GPU-accelerated workloads on macOS.</li> <li>For GPU-accelerated SCVIDR usage, you\u2019ll need to use a Linux system or Windows with WSL 2.</li> </ul>"},{"location":"installation/getting-started/#running-scvidr-in-an-hpc-environment","title":"Running SCVIDR in an HPC Environment","text":"<p>For High-Performance Computing (HPC) environments, Docker is generally not supported due to security and permission limitations. Instead, it is recommended to use Singularity (Apptainer) to sandbox the Docker image for proper directory mapping and GPU support.</p> <p>Step 1: Convert Docker Image to Singularity Image</p> <p><pre><code>singularity pull docker://bhattacharyalab/scvidr:with-data\n</code></pre> Step 2: Create a Writable Sandbox</p> <p><pre><code>singularity build --sandbox scvidr_sandbox docker://bhattacharyalab/scvidr:with-data\n</code></pre> Step 3: Enable GPU Support and Start Jupyter Lab</p> <pre><code>singularity exec --nv --writable --pwd /scVIDR scvidr_sandbox jupyter lab --ip=0.0.0.0 --no-browser --allow-root --port=8988\n</code></pre> <p>Ensure that the HPC environment allows port forwarding and consult the respective HPC documentation or administrators to configure SSH tunnels or firewall rules properly for accessing the Jupyter Lab environment running inside the container. This may involve requesting specific ports to be opened or setting up SSH port forwarding commands to map the remote Jupyter Lab port to your local machine. Example below: <pre><code>ssh -L 8888:localhost:8988\n</code></pre></p> <p>If you're using the <code>no-data</code> container in Singularity, you can bind your local <code>data</code> directory by adding the <code>--bind /full_data_path/data:/scVIDR/data</code> option to your <code>singularity exec</code> command.</p>"},{"location":"installation/getting-started/#important-notes","title":"Important Notes","text":"<ul> <li>WSL Performance: If you're using Windows Subsystem for Linux (WSL), be aware that performance can be extremely slow. We don't recommend using Docker on Windows for SCVIDR.</li> <li>Resources: Ensure that your Docker container has enough memory to perform calculations smoothly.</li> <li>Bugs: If you encounter any bugs or errors with the Docker installation, please report them on the GitHub issue page.</li> </ul>"},{"location":"installation/getting-started/#docker-image-build-information","title":"Docker Image Build Information","text":"<p>We built our Docker image using Docker's automatic build function. The Dockerfile is available here, allowing you to create a custom image if needed.</p>"},{"location":"tutorials/Figure2/","title":"Prediction of In Vivo Single-Cell Gene Expression of Portal Hepatocytes","text":"<p>This demonstrates the application of scVIDR to predict gene expression changes in liver cell types, focusing on portal hepatocytes treated with 30 \u03bcg/kg TCDD. It includes UMAP visualizations of latent spaces, PCA comparisons, regression plots for predicted vs. observed gene expression, and performance evaluations using R\u00b2 scores across models and gene sets.</p>"},{"location":"tutorials/Figure2/#importing-required-libraries","title":"Importing Required Libraries","text":"<p>Essential libraries are imported for data handling, single-cell analysis, statistical computations, and visualization.</p> <pre><code>import sys\nsys.path.insert(1, '../vidr/')\n\n# Import the VIDR functions\nfrom vidr import VIDR\nfrom utils import *\n\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nimport gseapy as gp\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\n#For calculating statistical distance\nimport geomloss\nimport pykeops\nimport pykeops\npykeops.clean_pykeops()          # just in case old build files are still present\npykeops.test_numpy_bindings()    # perform the compilation\n\nimport scvi\nsc.set_figure_params(dpi = 150)\nsc.settings.figdir = \"../figures\"\nsns.set_style(\"dark\")\n</code></pre>"},{"location":"tutorials/Figure2/#loading-data","title":"Loading Data","text":"<p>The single-cell dataset is loaded in AnnData format.</p> <pre><code>adata = sc.read_h5ad(\"../data/nault2021_singleDose.h5ad\")\n</code></pre>"},{"location":"tutorials/Figure2/#data-preprocessing","title":"Data Preprocessing","text":"<p>Filters specific cell types, normalizes expression, selects the top 5000 highly variable genes, and formats dose information.</p> <pre><code>#Prepare Data Set\ncell_types_of_int = [\"Hepatocytes - central\", \"Hepatocytes - portal\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes=5000)\n\nadata.obs[\"dose\"] = [str(d) for d in adata.obs.Dose]\nadata = adata[:,adata.var.highly_variable]\n</code></pre>"},{"location":"tutorials/Figure2/#training-the-model","title":"Training the Model","text":"<p>Prepare data for training, instantiate the VIDR model, and load pre-trained weights.</p> <pre><code>#Training model\ncell = \"Hepatocytes - portal\"\ntrain_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\ntrain_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(train_adata.obs[\"Dose\"], train_adata.obs[\"celltype\"])]\nmodel = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\nvae = model.load(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n</code></pre>"},{"location":"tutorials/Figure2/#figure-2a-umap-projection-of-latent-space","title":"Figure 2A: UMAP Projection of Latent Space","text":"<p>UMAP visualization highlights the differences between control and treated samples in latent space.</p> <pre><code>#UMAP Projection of latent space\nlatent_X = vae.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\ncell_dose = [f\"{j}_{str(i)}\" for (i,j) in zip(adata.obs[\"Dose\"], adata.obs[\"celltype\"])]\ntraining = [\"Train\" if i != cell+\"_30\" else \"Test\" for i in cell_dose]\nlatent_adata.obs[\"Cell_Dose\"] = cell_dose\nlatent_adata.obs[\"Training Split\"] = training\n\nsc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n\nax = sc.pl.umap(latent_adata, color=['Cell_Dose'], frameon=True,palette = \"Paired\", save =\"2A1.svg\")\n</code></pre> <p></p> <pre><code>sc.pl.umap(latent_adata, color=['Training Split'], frameon=True,palette =\"Dark2\", save=\"2A2.svg\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure2/#figure-2b-pca-plots-comparing-prediction-models","title":"Figure 2B: PCA Plots Comparing Prediction Models","text":"<p>Predicts gene expression under treatment and control without regression, combines the data, visualizes it using PCA, identifies differentially expressed genes, and evaluates prediction accuracy using R\u00b2.</p> <pre><code>model = vae\npred, delta = model.predict(\nctrl_key=\"0\",\ntreat_key=\"30\",\ncell_type_to_predict=cell,\nregression = False)\npred.obs[\"dose\"] = 'pred'\nctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\ntreat_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\neval_adata1 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata1.obs[\"dose\"]:\n    if i == \"0\":\n        treatments.append(\"Control\")\n    elif i == \"30\":\n        treatments.append(\"TCDD\")\n    else:\n        treatments.append(\"VAEArith\")\neval_adata1.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata1)\nsc.pl.pca(eval_adata1, color = \"Treatment\", frameon = True, title = \"\", save = \"2B1.svg\")\nCD4T = adata[adata.obs[\"celltype\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\nr2_value = model.reg_mean_plot(\neval_adata1,\naxis_keys={\"x\": \"pred\", \"y\": \"30\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/2B2.svg\",\nshow=True,\nlegend=False, title = \"VAEArith\")\nprint(r2_value)\n</code></pre> <p></p> <p></p> <pre><code>(0.7412729808604916, 0.6055730593169139)\n</code></pre>"},{"location":"tutorials/Figure2/#figure-2c-regression-analysis-with-predicted-data","title":"Figure 2C: Regression Analysis with Predicted Data","text":"<p>Predicts gene expression under treatment and control using regression, combines predicted and real data, and visualizes the results with PCA and regression plots. It also identifies differentially expressed genes and evaluates model accuracy using the R\u00b2 value.</p> <pre><code>model = vae\npred, delta, reg = model.predict(\nctrl_key=\"0\",\ntreat_key=\"30\",\ncell_type_to_predict=cell,\nregression = True)\npred.obs[\"dose\"] = 'pred'\nctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\ntreat_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"dose\"]:\n    if i == \"0\":\n        treatments.append(\"Control\")\n    elif i == \"30\":\n        treatments.append(\"TCDD\")\n    else:\n        treatments.append(\"scVIDR\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"2C1.svg\")\nCD4T = adata[adata.obs[\"celltype\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\nr2_value = model.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": \"30\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/Figure2C2.svg\",\nshow=True,\nlegend=False, title = \"scVIDR\")\nprint(r2_value)\n</code></pre> <p></p> <p></p> <pre><code>(0.9331575277168523, 0.8371578892235645)\n</code></pre>"},{"location":"tutorials/Figure2/#figure-2d-comparison-of-gene-expression-across-treatments","title":"Figure 2D: Comparison of Gene Expression Across Treatments","text":"<p>Combining predicted and real data to compare gene expression across treatments and visualizes Cyp1a2 expression using a violin plot.</p> <pre><code>eval_adata = eval_adata1.concatenate(eval_adata2)\neval_adata.obs\n</code></pre> Dose batch celltype dose _scvi_batch _scvi_labels _scvi_local_l_mean _scvi_local_l_var cell_dose Treatment AAACCCACAGTTAGGG_1-0-0-0 0 0 Hepatocytes - portal 0 NaN NaN NaN NaN NaN Control AAACCCAGTGCCTGCA_1-0-0-0 0 0 Hepatocytes - portal 0 NaN NaN NaN NaN NaN Control AAACGAACATAGAATG_1-0-0-0 0 0 Hepatocytes - portal 0 NaN NaN NaN NaN NaN Control AAACGAAGTCGATTAC_1-0-0-0 0 0 Hepatocytes - portal 0 NaN NaN NaN NaN NaN Control AAACGCTTCGGCATCG_1-0-0-0 0 0 Hepatocytes - portal 0 NaN NaN NaN NaN NaN Control ... ... ... ... ... ... ... ... ... ... ... ATAGAGAAGGTCCCGT_3-0-0-2-1 0 1 Hepatocytes - portal pred 0.0 3.0 5.716166 0.067732 Hepatocytes - portal_0 scVIDR TTCCTTCTCTCCCAAC_3-0-0-2-1 0 1 Hepatocytes - portal pred 0.0 3.0 5.716166 0.067732 Hepatocytes - portal_0 scVIDR CAGCACGAGCTCCGAC_2-0-0-2-1 0 1 Hepatocytes - portal pred 0.0 3.0 5.716166 0.067732 Hepatocytes - portal_0 scVIDR AACCATGCAGGCCCTA_1-0-0-2-1 0 1 Hepatocytes - portal pred 0.0 3.0 5.716166 0.067732 Hepatocytes - portal_0 scVIDR CACGGGTTCGCACGAC_2-0-0-2-1 0 1 Hepatocytes - portal pred 0.0 3.0 5.716166 0.067732 Hepatocytes - portal_0 scVIDR <p>21902 rows \u00d7 10 columns</p> <pre><code>ax = sc.pl.violin(eval_adata, [\"Cyp1a2\"], groupby = \"Treatment\", rotation = 0, palette = \"tab10\", save = \"2D.svg\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure2/#figure-2e-comprehensive-analysis-of-gene-expression-predictions-across-cell-types","title":"Figure 2E: Comprehensive Analysis of Gene Expression Predictions Across Cell Types","text":"<p>Each cell type in the dataset is analyzed to predict gene expression changes between control and treated conditions. First, VIDR models are trained for each cell type, evaluated using non-regression-based predictions, and their performance is quantified. Next, pre-trained scVIDR models are used to make regression-based predictions for more precise analysis. Differentially expressed genes are identified for both approaches, and R\u00b2 metrics are calculated to assess the accuracy of predictions.</p> <pre><code>df_list = []\ncelltypes = np.unique(adata.obs[\"celltype\"])\nfor cell in celltypes:\n    print(cell)\n    train_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\n\n    model = VIDR(train_adata, linear_decoder = False)\n    model.train(\n    max_epochs=100,\n    batch_size=128,\n    early_stopping=True,\n    early_stopping_patience=25)\n\n    model.save(f\"../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\", overwrite = True)\n    model = model.load(f\"../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n\n    model_name = \"VAEArith\"\n\n    pred, delta = model.predict(\n    ctrl_key=\"0\",\n    treat_key=\"30\",\n    cell_type_to_predict=cell,\n    regression = False)\n\n    pred.obs[\"dose\"] = 'pred'\n    ctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\n    treat_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\n    eval_adata = ctrl_adata.concatenate(treat_adata, pred)\n\n    CD4T = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\n\n    r2_df = calculate_r2_singledose(\n        eval_adata, cell,\n        model_name, \n        \"dose\", \n        {\"x\":\"pred\", \"y\":\"30\"}, \n        diff_genes=diff_genes[:100], \n        random_sample_coef = 0.8,\n        n_iter = 500\n    )\n    df_list.append(r2_df)\n</code></pre> <pre><code>for cell in celltypes:\n    print(cell)\n    train_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\n\n    model = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n    model = model.load(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n\n    model_name = \"scVIDR\"\n\n    pred, delta, reg = model.predict(\n    ctrl_key=\"0\",\n    treat_key=\"30\",\n    cell_type_to_predict=cell,\n    regression = True)\n\n    pred.obs[\"dose\"] = 'pred'\n    ctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\n    treat_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\n    eval_adata = ctrl_adata.concatenate(treat_adata, pred)\n\n    CD4T = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\n\n    r2_df = calculate_r2_singledose(\n        eval_adata, cell,\n        model_name, \n        \"dose\", \n        {\"x\":\"pred\", \"y\":\"30\"}, \n        diff_genes=diff_genes[:100], \n        random_sample_coef = 0.8,\n        n_iter = 500\n    )\n    df_list.append(r2_df)\n</code></pre> <pre><code>r2_values_allCells_df = pd.concat(df_list)\n</code></pre> <pre><code>r2_values_allCells_df.to_csv(\"../data/SingleDose_Model_Results.csv\")\n</code></pre> <p>Comparing R<sup>2</sup> values of scVIDR and VAEArith across gene sets with statistical annotations.</p> <pre><code>order = ['scVIDR', 'VAEArith']\nhue_order = [\"All HVGs\", \"DEGs\"]\nax = sns.boxplot(x = \"Model\", y = \"R^2\",  data = r2_values_allCells_df, hue = \"Gene Set\", order = order, hue_order = hue_order)\npairs = [\n    (('scVIDR','All HVGs'), ('VAEArith', 'All HVGs')),\n    (('scVIDR','DEGs'), ('VAEArith', 'DEGs'))\n]\nannotator = Annotator(ax, pairs, data=r2_values_allCells_df, x=\"Model\", y=\"R^2\", hue = \"Gene Set\", order = order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.ylabel(r\"$R^2$\")\nplt.savefig(\"../figures/Figure2E.svg\", bbox_inches = \"tight\")\nplt.show()\n</code></pre> <p></p> <pre><code>df = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"DEGs\"]\n</code></pre> <p>Comparing R\u00b2 values of scVIDR and VAEArith across cell types using a bar plot.</p> <pre><code>order = ['scVIDR', 'VAEArith']\nhue_order = [\"All HVGs\", \"DEGs\"]\nax = sns.barplot(x = \"Cell\", y = \"R^2\",  data = r2_values_allCells_df, hue = \"Model\", hue_order=order)\nplt.ylabel(\"$R^2$ Top 100 DEGs\")\nplt.xticks(rotation = 90)\n</code></pre> <p></p> <p>Identifies differentially expressed genes (DEGs) between treatment groups for each cell type, performs KEGG pathway enrichment analysis, and visualizes enriched pathways with bar plots.</p> <pre><code>for cell in celltypes:\n    print(cell)\n\n    CD4T = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\n    glist = diff_genes[:100]\n    CD4T.\n</code></pre> <pre><code>for cell in celltypes:\n    print(cell)\n\n    CD4T = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\n    glist = diff_genes[:125]\n    print(glist[:10])\n    glist = glist.tolist()\n    enr = gp.enrichr(gene_list=glist,\n                     gene_sets=[\"KEGG_2019_Mouse\"],\n                     organism='Mouse', # don't forget to set organism to the one you desired! e.g. Yeast\n                     description='test_name',\n                     outdir='test/enrichr_kegg',\n                     # no_plot=True,\n                     cutoff=0.5 # test dataset, use lower value from range(0,1)\n                    )\n    gp.plot.barplot(enr.res2d, title = f\"{cell}\")\n    plt.show()\n</code></pre> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Identifies and visualizes differentially expressed genes (DEGs) across cell types within the treated group (dose=30) using a Wilcoxon rank-sum test.</p> <pre><code>CD4T = adata[adata.obs[\"dose\"] == \"30\"]\n</code></pre> <pre><code>sc.tl.rank_genes_groups(CD4T, groupby=\"celltype\", method=\"wilcoxon\", )\n</code></pre> <pre><code>diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"]\n</code></pre> <pre><code>sc.pl.rank_genes_groups(CD4T)\n</code></pre> <p></p> <p>Identifies and visualizes differentially expressed genes (DEGs) across cell types within the treated group (dose=30) using a Wilcoxon rank-sum test. differentially expressed genes (DEGs) between treatment groups for each cell type, performs WikiPathways enrichment analysis, and visualizes enriched pathways with bar plots.</p> <pre><code>for cell in cell_types_of_int:\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][cell]\n    glist = diff_genes[:100]\n    print(glist[:10])\n    glist = glist.tolist()\n    enr = gp.enrichr(gene_list=glist,\n                     gene_sets=[\"WikiPathways_2019_Mouse\"],\n                     organism='Mouse', # don't forget to set organism to the one you desired! e.g. Yeast\n                     description='test_name',\n                     outdir='test/enrichr_kegg',\n                     # no_plot=True,\n                     cutoff=0.5 # test dataset, use lower value from range(0,1)\n                    )\n    gp.plot.barplot(enr.res2d, title = f\"{cell}\")\n    plt.show()\n</code></pre> <pre><code>['Airn' 'Tbc1d16' 'Them7' 'Nfe2l2' 'Ugdh' 'Esrrg' 'Fmo3' 'Fabp12' 'Fbp1'\n 'Neat1']\n</code></pre> <p></p> <pre><code>['Cps1' 'Arg1' 'Slc7a2' 'Ass1' 'Gm26917' 'Itih2' 'Nr1i3' 'Neat1' 'Por'\n 'Sult5a1']\n</code></pre> <p></p> <pre><code>['Glis3' 'Pkhd1' 'Bicc1' 'Carmil1' 'Alcam' '2610035D17Rik' 'Naaladl2'\n 'Shank2' 'Erbb4' 'Pdgfd']\n</code></pre> <p></p> <pre><code>['Pde3a' 'Lhfp' 'Rbms3' 'Sox5' 'Zfpm2' 'Arhgap24' 'Gpc6' 'Cacnb2' 'Pde1a'\n 'Prkg1']\n</code></pre> <p></p> <pre><code>['Celf2' 'Mast4' 'Syne2' 'Efna5' 'Pcnx2' 'Thsd4' 'Wdr17' 'Gpm6a' 'Bnc2'\n 'Plxna4']\n</code></pre> <p></p> <pre><code>['Ptprb' 'St6galnac3' 'Plekhg1' 'Meis2' 'Plpp1' 'Arhgap31' 'Fbxl7' 'Fyn'\n 'Stab2' 'Tmem2']\n</code></pre> <p></p> <p>Calculates Jaccard similarity between top 50 DEGs of cell types, creates a similarity matrix, and visualizes it as a heatmap.</p> <pre><code>jaccard_sim = lambda x, y: len(set(x) &amp; set(y))/len(set(x) | set(y))\n</code></pre> <pre><code>jaccard_sim(CD4T.uns[\"rank_genes_groups\"][\"names\"][\"Portal Fibroblasts\"][:100], CD4T.uns[\"rank_genes_groups\"][\"names\"][\"Cholangiocytes\"][:100])\n</code></pre> <pre><code>0.09289617486338798\n</code></pre> <pre><code>N = len(cell_types_of_int)\ndist_mat = np.zeros([N, N])\nfor i in range(N):\n    for j in range(N):\n        cell_i = cell_types_of_int[i]\n        cell_j = cell_types_of_int[j]\n        diff_i = CD4T.uns[\"rank_genes_groups\"][\"names\"][cell_i][:50]\n        diff_j = CD4T.uns[\"rank_genes_groups\"][\"names\"][cell_j][:50]\n        dist_ij = jaccard_sim(diff_i, diff_j)\n        dist_mat[i, j] = dist_ij\n</code></pre> <pre><code>dist_df = pd.DataFrame(dist_mat, columns=cell_types_of_int, index = cell_types_of_int)\n</code></pre> <pre><code>sns.heatmap(dist_df, cmap = \"coolwarm\")\n</code></pre> <p></p> <pre><code>mmd = geomloss.SamplesLoss(\"sinkhorn\")\ncos = torch.nn.CosineSimilarity(dim = 1, eps = 1e-6)\n</code></pre> <pre><code>for cell in cell_types_of_int:\n    x = latent_adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\n    y = latent_adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\n    x_tensor = torch.Tensor(x.X)\n    y_tensor = torch.Tensor(y.X)\n    print(f\"{cell}: {mmd(x_tensor, y_tensor)}\")\n</code></pre> <pre><code>Hepatocytes - central: 267.10369873046875\n</code></pre>"},{"location":"tutorials/Figure3/","title":"Prediction of In Vivo Single-Cell TCDD Dose-Response Across Mouse Liver Cell Types","text":"<p>This study utilizes mouse liver snRNA-seq data across eight TCDD doses (0.01 to 30 \u03bcg/kg) and a control to evaluate scVIDR's ability to predict dose-response gene expression. The analysis highlights scVIDR's superior performance over scGen in predicting highly variable genes (HVGs) and differentially expressed genes (DEGs) across various doses. Key results include UMAP representations of latent spaces, dose-response predictions for Ahrr, and performance evaluations using R\u00b2 scores across liver cell types and doses.</p>"},{"location":"tutorials/Figure3/#importing-required-libraries","title":"Importing Required Libraries","text":"<p>Imports necessary libraries and functions for modeling, single-cell analysis, statistical evaluation, and visualization. Configures plotting parameters and suppresses warnings.</p> <pre><code>import sys\nsys.path.insert(1, '../vidr/')\n\n#Import VIDR functions\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\n#For calculating statistical distance\nimport geomloss\nimport pykeops\nimport pykeops\npykeops.clean_pykeops()          \npykeops.test_numpy_bindings() \n\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nsc.set_figure_params(dpi = 150, frameon = True)\nsns.set_style(\"dark\")\nsc.set_figure_params(dpi = 150)\nsc.settings.figdir = \"../figures\"\nsns.set_style(\"dark\")\n</code></pre>"},{"location":"tutorials/Figure3/#data-loading-and-preprocessing","title":"Data Loading and Preprocessing","text":"<p>Loads the multi-dose dataset, filters out immune cells to retain relevant liver cell types, normalizes and log-transforms the data, selects the top 5000 highly variable genes, and converts the dose information into a categorical variable.</p> <pre><code>#Import Data\nadata = sc.read_h5ad(\"../data/nault2021_multiDose.h5ad\")\n\n\n#Remove Immune Cells\ncell_types_of_int = [\"Hepatocytes - central\", \"Hepatocytes - portal\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\n#Preporces data\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes = 5000)\nadata = adata[:, adata.var.highly_variable]\n\n#Make dose categorical\nadata.obs[\"dose\"] = [str(i) for i in adata.obs[\"Dose\"]]\n</code></pre>"},{"location":"tutorials/Figure3/#loading-the-vidr-model","title":"Loading the VIDR Model","text":"<p>Prepares the training and testing datasets for portal hepatocytes across TCDD doses, initializes a VIDR model, and loads a pre-trained VIDR model specific to this cell type and dose-response data.</p> <pre><code>doses = [0.0,0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]\ncell = \"Hepatocytes - portal\"\nmodel_name = \"VAE\"\ntrain_adata, test_adata = prepare_cont_data(adata, \"celltype\", \"dose\", \"Dose\", cell, 0, normalized=True)\nmodel = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt\")\nmodel = model.load(f\"../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt\", train_adata)\n</code></pre> <p>Defines the range of TCDD doses (0.01 to 30 \u03bcg/kg) along with a control dose for dose-response analysis.</p> <pre><code>doses = [0.0,0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]\n</code></pre>"},{"location":"tutorials/Figure3/#regression-and-evaluation-across-tcdd-doses","title":"Regression and Evaluation Across TCDD Doses","text":"<p>Performs regression-based predictions of gene expression across multiple TCDD doses using the VIDR model. For each dose, differentially expressed genes are identified, and regression plots are generated to compare predicted and actual gene expression. R\u00b2 values are calculated to quantify the model's performance for all genes and the top 100 differentially expressed genes.</p> <pre><code>#Regression   \nregression = True\ndr_dict, delta, reg = model.predict(\n    ctrl_key='0.0',\n    treat_key='30.0',\n    cell_type_to_predict=cell,\n    regression = regression,\n    continuous = True,\n    doses = doses)\n\nfor key in dr_dict.keys():\n    dr_dict[key].obs[\"Dose\"] = f'{key} VIDR'\n\nctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == 0))]\neval_dict1 = {}\n\nfor d in doses[1:]:\n    stim_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == d))]\n    eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n    eval_dict1[d].obs[\"dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['Dose']]\n\nfor d in doses[1:]:\n    cell_adata = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(cell_adata, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n    print(f\"{d}\")\n    r2_value1 = model.reg_mean_plot(\n        eval_dict1[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"{d} VIDR\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=\"./reg_mean1.pdf\",\n        show=True,\n        legend=False)\n    r2_value2 = model.reg_mean_plot(\n        eval_dict1[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"0.0\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=\"./figures/reg_mean1.pdf\",\n        show=False,\n        legend=False)\n    print(f\"Model: {model_name}\\n Cell: {cell}\\n Regression: {regression} \\n Dose: {d} \\n R2 All: {r2_value1[0]/r2_value2[0]} \\n R2 Top 100: {r2_value1[1]/r2_value2[1]}\")\n</code></pre> <pre><code>Dose = 0.01\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.01 \n R2 All: 0.9998365886415364 \n R2 Top 100: 0.9996258058759293\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.03\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.03 \n R2 All: 0.9994310986600337 \n R2 Top 100: 1.0036983240887611\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.1\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.1 \n R2 All: 1.0017792971327764 \n R2 Top 100: 1.004977132859977\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.3\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.3 \n R2 All: 1.0005741023645782 \n R2 Top 100: 1.0003103972683154\n\n\n... storing 'dose' as categorical\n\n\nDose = 1.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 1.0 \n R2 All: 1.005549147681544 \n R2 Top 100: 1.016663184905941\n\n\n... storing 'dose' as categorical\n\n\nDose = 3.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 3.0 \n R2 All: 1.0401036100968821 \n R2 Top 100: 1.0038404243535974\n\n\n... storing 'dose' as categorical\n\n\nDose = 10.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 10.0 \n R2 All: 1.1961050842270327 \n R2 Top 100: 1.1112825896117045\n\n\n... storing 'dose' as categorical\n\n\nDose = 30.0\n</code></pre> <p></p> <pre><code>Model: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 30.0 \n R2 All: 1.465797262704612 \n R2 Top 100: 1.1896994357394821\n</code></pre> <p>Generates a UMAP projection of the latent space representation of the dataset using the VIDR model's embeddings.</p> <pre><code>latent_X = model.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X = latent_X, obs = adata.obs.copy())\nsc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <p>Assigns metadata to the latent dataset, including training/test splits, dose values, cell types, and combined cell-dose labels.</p> <pre><code>latent_adata.obs[\"Training Split\"] = [\"Test\" if ((i == \"Hepatocytes - portal\") &amp; (j &gt; 0)) else \"Train\" for (i, j) in zip(latent_adata.obs[\"celltype\"], latent_adata.obs[\"Dose\"])]\nlatent_adata.obs[\"Dose\"] = [float(i) for i in latent_adata.obs[\"dose\"]]\nlatent_adata.obs[\"Cell Type\"] = latent_adata.obs[\"celltype\"]\nlatent_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(latent_adata.obs[\"Dose\"], latent_adata.obs[\"celltype\"])]\n</code></pre> <p>Calculates centroids in the UMAP space for each unique cell-dose combination, including the control and highest-dose groups. <pre><code>centroids = {cell:np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"cell_dose\"] == cell], axis = 0) for cell in np.unique(latent_adata.obs[\"cell_dose\"])}\ncentroids[\"0\"] = np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"dose\"] == \"0.0\"], axis = 0)\ncentroids[\"30\"] = np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"dose\"] == \"30.0\"], axis = 0)\n</code></pre></p>"},{"location":"tutorials/Figure3/#figure-3a-umap-visualization-of-dose-response","title":"Figure 3A: UMAP Visualization of Dose-Response","text":"<p>This section visualizes the latent space representation of single-cell gene expression across TCDD doses using UMAP. The first plot highlights clustering by cell type, the second illustrates the train-test split for portal hepatocytes, and the third shows dose-response trajectories using arrows to represent changes in gene expression across doses in portal hepatocytes. The arrows are scaled based on the dose to depict the gradual transition in gene expression from control to the highest dose.</p> <pre><code>sc.pl.umap(latent_adata, color = [\"Cell Type\"], frameon=True, save =\"3A1.svg\")\n</code></pre> <p></p> <pre><code>sc.pl.umap(latent_adata, color = [\"Training Split\"], frameon=True,  palette= \"Dark2\", save = \"3A2.svg\")\n</code></pre> <p></p> <pre><code>from matplotlib import cm\n</code></pre> <pre><code>umap_delta = centroids[\"30\"]- centroids[\"0\"]\nax =sc.pl.umap(latent_adata, color = [\"Dose\"], frameon=True, return_fig = True, cmap = \"flare\")\nx = [i/30 for i in doses[::-1][:-1]]\ncolors = cm.get_cmap(sns.cm.flare)(x)[np.newaxis, :, :3]\nfor d, c in zip(doses[::-1][:-1], colors[0]):\n    plt.arrow(centroids[\"Hepatocytes - portal_0.0\"][0], centroids[\"Hepatocytes - portal_0.0\"][1], umap_delta[0]*(np.log1p(d)/np.log1p(30)), umap_delta[1]*(np.log1p(d)/np.log1p(30)), head_width = 0.7, edgecolor = \"black\", facecolor = c)\nplt.savefig(\"../figures/3A3.svg\", bbox_inches='tight')\nplt.show()\n</code></pre> <p></p> <pre><code># df_list = []\n# celltypes = np.unique(adata.obs[\"celltype\"])\n# regression = False\n# for cell in celltypes:\n#     print(cell)\n#     train_adata, test_adata = prepare_cont_data(adata, \"celltype\", \"dose\", \"Dose\", cell, 0, normalized=True)\n\n#     model = VIDR(train_adata, linear_decoder = False)\n# #     model.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n#     model = model.load(f\"../../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n\n#     model_name = \"VAEArith\"\n\n#     dr_dict, delta = model.predict(\n#         ctrl_key='0.0',\n#         treat_key='30.0',\n#         cell_type_to_predict=cell,\n#         regression = regression,\n#         continuous = True,\n#         doses = doses)\n#     for key in dr_dict.keys():\n#         dr_dict[key].obs[\"Dose\"] = f'{key} VAEArith'\n\n#     ctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == 0))]\n#     eval_dict1 = {}\n\n#     for d in doses[1:]:\n#         stim_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == d))]\n#         eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n#         eval_dict1[d].obs[\"dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['Dose']]\n\n#     for d in doses[1:]:\n#         cell_adata = adata[adata.obs[\"celltype\"] ==cell]\n#         sc.tl.rank_genes_groups(cell_adata, groupby=\"dose\", method=\"wilcoxon\")\n#         diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n\n#         r2_df = calculate_r2_multidose(\n#             eval_dict1[d], \n#             cell,\n#             model_name, \n#             \"dose\", \n#             {\"x\":f'{d} VAEArith', \"y\":f\"{d}\"}, \n#             diff_genes=diff_genes[:100], \n#             random_sample_coef = 0.8,\n#             n_iter = 500\n#         )\n#         df_list.append(r2_df)\n</code></pre> <pre><code># celltypes = np.unique(adata.obs[\"celltype\"])\n# regression = True\n# for cell in celltypes:\n#     print(cell)\n#     train_adata, test_adata = prepare_cont_data(adata, \"celltype\", \"dose\", \"Dose\", cell, 0, normalized=True)\n\n#     model = VIDR(train_adata, linear_decoder = False)\n# #     model.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n#     model = model.load(f\"../../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n\n#     model_name = \"scVIDR\"\n\n#     dr_dict, delta, reg = model.predict(\n#         ctrl_key='0.0',\n#         treat_key='30.0',\n#         cell_type_to_predict=cell,\n#         regression = regression,\n#         continuous = True,\n#         doses = doses)\n#     for key in dr_dict.keys():\n#         dr_dict[key].obs[\"Dose\"] = f'{key} VAEArith'\n\n#     ctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == 0))]\n#     eval_dict1 = {}\n\n#     for d in doses[1:]:\n#         stim_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == d))]\n#         eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n#         eval_dict1[d].obs[\"dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['Dose']]\n\n#     for d in doses[1:]:\n#         cell_adata = adata[adata.obs[\"celltype\"] ==cell]\n#         sc.tl.rank_genes_groups(cell_adata, groupby=\"dose\", method=\"wilcoxon\")\n#         diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n\n#         r2_df = calculate_r2_multidose(\n#             eval_dict1[d], \n#             cell,\n#             model_name, \n#             \"dose\", \n#             {\"x\":f'{d} VAEArith', \"y\":f\"{d}\"}, \n#             diff_genes=diff_genes[:100], \n#             random_sample_coef = 0.8,\n#             n_iter = 500\n#         )\n#         df_list.append(r2_df)\n</code></pre> <pre><code># r2_values_allCells_df = pd.concat(df_list)\n</code></pre> <pre><code># r2_values_allCells_df.to_csv(\"../../data/Continuous_Comparison_r2Values.csv\")\n</code></pre> <pre><code>r2_values_allCells_df = pd.read_csv(\"../data/Continuous_Comparison_r2Values.csv\")\n</code></pre> <pre><code>r2_values_allCells_df[\"Dose\"] = r2_values_allCells_df[\"Dose\"].astype(\"str\")\n</code></pre>"},{"location":"tutorials/Figure3/#figure-3c-dose-response-prediction-for-portal-hepatocytes","title":"Figure 3C: Dose-Response Prediction for Portal Hepatocytes","text":"<p>Bar plots compare the prediction performance of scVIDR and VAEArith across TCDD doses for portal hepatocytes. The first plot evaluates the mean expression of all highly variable genes (HVGs), while the second focuses on the top 100 differentially expressed genes (DEGs). Statistical significance is assessed using the Mann-Whitney U test, with annotations indicating differences between models at each dose.</p> <pre><code>cell = \"Hepatocytes - portal\"\ndf = r2_values_allCells_df.loc[((r2_values_allCells_df[\"Cell\"].values == cell) &amp; \n                                (r2_values_allCells_df[\"Gene Set\"] == \"All HVGs\"))]\norder = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.barplot(x = \"Dose\", y = \"R^2\",  data = df, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"0.01\", \"scVIDR\"),(\"0.01\", \"VAEArith\")),\n    ((\"0.03\", \"scVIDR\"),(\"0.03\", \"VAEArith\")),\n    ((\"0.1\", \"scVIDR\"),(\"0.1\", \"VAEArith\")),\n    ((\"0.3\", \"scVIDR\"),(\"0.3\", \"VAEArith\")),\n    ((\"1.0\", \"scVIDR\"),(\"1.0\", \"VAEArith\")),\n    ((\"3.0\", \"scVIDR\"),(\"3.0\", \"VAEArith\")),\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"30.0\", \"scVIDR\"),(\"30.0\", \"VAEArith\"))\n]\nannotator = Annotator(ax, pairs, data=df, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ All HVGs\")\nplt.savefig(\"../figures/3B1.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n0.03_scVIDR vs. 0.03_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=9.600e+04\n0.01_scVIDR vs. 0.01_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=8.816e+04\n0.1_scVIDR vs. 0.1_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=6.304e+04\n0.3_scVIDR vs. 0.3_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=1.015e+05\n1.0_scVIDR vs. 1.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:7.095e-83 U_stat=2.129e+05\n3.0_scVIDR vs. 3.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:3.109e-165 U_stat=2.500e+05\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.928e-165 U_stat=2.500e+05\n30.0_scVIDR vs. 30.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.928e-165 U_stat=2.500e+05\n</code></pre> <p></p> <pre><code>cell = \"Hepatocytes - portal\"\ndf = r2_values_allCells_df.loc[((r2_values_allCells_df[\"Cell\"].values == cell) &amp; \n                                (r2_values_allCells_df[\"Gene Set\"] == \"DEGs\"))]\norder = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.barplot(x = \"Dose\", y = \"R^2\",  data = df, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"0.01\", \"scVIDR\"),(\"0.01\", \"VAEArith\")),\n    ((\"0.03\", \"scVIDR\"),(\"0.03\", \"VAEArith\")),\n    ((\"0.1\", \"scVIDR\"),(\"0.1\", \"VAEArith\")),\n    ((\"0.3\", \"scVIDR\"),(\"0.3\", \"VAEArith\")),\n    ((\"1.0\", \"scVIDR\"),(\"1.0\", \"VAEArith\")),\n    ((\"3.0\", \"scVIDR\"),(\"3.0\", \"VAEArith\")),\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"30.0\", \"scVIDR\"),(\"30.0\", \"VAEArith\"))\n]\nannotator = Annotator(ax, pairs, data=df, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ Top 100 DEGs\")\nplt.savefig(\"../figures/3B2.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n0.03_scVIDR vs. 0.03_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=1.053e+05\n0.01_scVIDR vs. 0.01_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=6.812e+04\n0.1_scVIDR vs. 0.1_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=6.914e+04\n0.3_scVIDR vs. 0.3_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.868e-02 U_stat=1.337e+05\n1.0_scVIDR vs. 1.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.135e-162 U_stat=2.490e+05\n3.0_scVIDR vs. 3.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.928e-165 U_stat=2.500e+05\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.928e-165 U_stat=2.500e+05\n30.0_scVIDR vs. 30.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:7.951e-145 U_stat=2.419e+05\n</code></pre> <p></p>"},{"location":"tutorials/Figure3/#figure-3d-comparison-of-prediction-accuracy-across-all-cell-types","title":"Figure 3D: Comparison of Prediction Accuracy Across All Cell Types","text":"<p>Boxplots display the R<sup>2</sup> scores for scVIDR and VAEArith models in predicting gene expression across TCDD doses for all highly variable genes (HVGs) and the top 100 differentially expressed genes (DEGs). Statistical significance between models is determined using the Mann-Whitney U test, highlighting scVIDR's superior performance at higher doses.</p> <pre><code>df = r2_values_allCells_df.loc[(r2_values_allCells_df[\"Gene Set\"] == \"All HVGs\")]\norder = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.boxplot(x = \"Dose\", y = \"R^2\",  data = df, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"0.01\", \"scVIDR\"),(\"0.01\", \"VAEArith\")),\n    ((\"0.03\", \"scVIDR\"),(\"0.03\", \"VAEArith\")),\n    ((\"0.1\", \"scVIDR\"),(\"0.1\", \"VAEArith\")),\n    ((\"0.3\", \"scVIDR\"),(\"0.3\", \"VAEArith\")),\n    ((\"1.0\", \"scVIDR\"),(\"1.0\", \"VAEArith\")),\n    ((\"3.0\", \"scVIDR\"),(\"3.0\", \"VAEArith\")),\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"30.0\", \"scVIDR\"),(\"30.0\", \"VAEArith\"))\n]\nannotator = Annotator(ax, pairs, data=df, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ All HVGs\")\nplt.savefig(\"../figures/3D1.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n0.03_scVIDR vs. 0.03_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.369e-01 U_stat=4.511e+06\n0.01_scVIDR vs. 0.01_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.644e-01 U_stat=4.566e+06\n0.1_scVIDR vs. 0.1_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:3.197e-01 U_stat=4.531e+06\n0.3_scVIDR vs. 0.3_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.598e-01 U_stat=4.507e+06\n1.0_scVIDR vs. 1.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:9.423e-03 U_stat=4.658e+06\n3.0_scVIDR vs. 3.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:8.439e-02 U_stat=4.592e+06\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:3.547e-213 U_stat=6.589e+06\n30.0_scVIDR vs. 30.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.495e-244 U_stat=6.737e+06\n</code></pre> <p></p> <pre><code>df = r2_values_allCells_df.loc[(r2_values_allCells_df[\"Gene Set\"] == \"DEGs\")]\norder = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.boxplot(x = \"Dose\", y = \"R^2\",  data = df, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"0.01\", \"scVIDR\"),(\"0.01\", \"VAEArith\")),\n    ((\"0.03\", \"scVIDR\"),(\"0.03\", \"VAEArith\")),\n    ((\"0.1\", \"scVIDR\"),(\"0.1\", \"VAEArith\")),\n    ((\"0.3\", \"scVIDR\"),(\"0.3\", \"VAEArith\")),\n    ((\"1.0\", \"scVIDR\"),(\"1.0\", \"VAEArith\")),\n    ((\"3.0\", \"scVIDR\"),(\"3.0\", \"VAEArith\")),\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"30.0\", \"scVIDR\"),(\"30.0\", \"VAEArith\"))\n]\nannotator = Annotator(ax, pairs, data=df, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ Top 100 DEGs\")\nplt.savefig(\"../figures/3D2.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n0.03_scVIDR vs. 0.03_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.810e-01 U_stat=4.503e+06\n0.01_scVIDR vs. 0.01_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:6.014e-03 U_stat=4.668e+06\n0.1_scVIDR vs. 0.1_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.507e-01 U_stat=4.508e+06\n0.3_scVIDR vs. 0.3_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.661e-01 U_stat=4.506e+06\n1.0_scVIDR vs. 1.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.817e-05 U_stat=4.762e+06\n3.0_scVIDR vs. 3.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:8.736e-12 U_stat=4.951e+06\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.347e-141 U_stat=6.198e+06\n30.0_scVIDR vs. 30.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:3.526e-127 U_stat=6.108e+06\n</code></pre> <p></p>"},{"location":"tutorials/Figure3/#regression-analysis-of-predicted-gene-expression","title":"Regression Analysis of Predicted Gene Expression","text":"<p>Evaluates scVIDR's predictions of gene expression across TCDD doses for portal hepatocytes, comparing predicted vs. observed values and calculating R<sup>2</sup> for HVGs and DEGs. Results highlight prediction accuracy at each dose.</p> <pre><code>doses = [0.0,0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]\ncell = \"Hepatocytes - portal\"\nmodel_name = \"VAE\"\ntrain_adata, test_adata = prepare_cont_data(adata, \"celltype\", \"dose\", \"Dose\", cell, 0, normalized=True)\nmodel = VIDR(train_adata, linear_decoder = False)\nmodel = model.load(f\"../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt\", train_adata)\n</code></pre> <pre><code>#Regression   \nregression = True\ndr_dict, delta, reg = model.predict(\n    ctrl_key='0.0',\n    treat_key='30.0',\n    cell_type_to_predict=cell,\n    regression = regression,\n    continuous = True,\n    doses = doses)\n\nfor key in dr_dict.keys():\n    dr_dict[key].obs[\"Dose\"] = f'{key} scVIDR'\n\nctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == 0))]\neval_dict1 = {}\n\nfor d in doses[1:]:\n    stim_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == d))]\n    eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n    eval_dict1[d].obs[\"dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['Dose']]\n\nfor d in doses[1:]:\n    cell_adata = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(cell_adata, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n    print(f\"{d}\")\n    r2_value1 = model.reg_mean_plot(\n        eval_dict1[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"{d} scVIDR\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=f\"../figures/reg_mean_{cell}_{d}.pdf\",\n        show=True,\n        legend=False)\n    r2_value2 = model.reg_mean_plot(\n        eval_dict1[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"0.0\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=f\"../figures/reg_mean_{cell}_{d}.pdf\",\n        show=False,\n        legend=False)\n    print(f\"Model: {model_name}\\n Cell: {cell}\\n Regression: {regression} \\n Dose: {d} \\n R2 All: {r2_value1[0]/r2_value2[0]} \\n R2 Top 100: {r2_value1[1]/r2_value2[1]}\")\n</code></pre> <pre><code>Dose = 0.01\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.01 \n R2 All: 0.9999457303749192 \n R2 Top 100: 0.997904483025438\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.03\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.03 \n R2 All: 0.9995470052310267 \n R2 Top 100: 1.003360411585673\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.1\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.1 \n R2 All: 1.002212196243269 \n R2 Top 100: 1.0052698915631115\n\n\n... storing 'dose' as categorical\n\n\nDose = 0.3\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 0.3 \n R2 All: 1.0007125907375471 \n R2 Top 100: 1.0004166527429195\n\n\n... storing 'dose' as categorical\n\n\nDose = 1.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 1.0 \n R2 All: 1.006138743885212 \n R2 Top 100: 1.0167584924988595\n\n\n... storing 'dose' as categorical\n\n\nDose = 3.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 3.0 \n R2 All: 1.0419627325534038 \n R2 Top 100: 1.0038051916609956\n\n\n... storing 'dose' as categorical\n\n\nDose = 10.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 10.0 \n R2 All: 1.1981812903256035 \n R2 Top 100: 1.1105750475996488\n\n\n... storing 'dose' as categorical\n\n\nDose = 30.0\n</code></pre> <p></p> <pre><code>Model: VAE\n Cell: Hepatocytes - portal\n Regression: True \n Dose: 30.0 \n R2 All: 1.4652627386693178 \n R2 Top 100: 1.188529687020579\n</code></pre>"},{"location":"tutorials/Figure3/#non-regression-analysis-of-predicted-gene-expression-across-doses","title":"Non-Regression Analysis of Predicted Gene Expression Across Doses","text":"<p>Evaluates the VAEArith model's performance in predicting gene expression without using regression for portal hepatocytes across various TCDD doses. The predictions are compared with observed data, and R<sup>2</sup> metrics for all highly variable genes (HVGs) and the top 100 differentially expressed genes (DEGs) are calculated. Results are saved as regression plots to visualize prediction accuracy.</p> <pre><code>#Regression   \nregression = False\ndr_dict, delta = model.predict(\n    ctrl_key='0.0',\n    treat_key='30.0',\n    cell_type_to_predict=cell,\n    regression = regression,\n    continuous = True,\n    doses = doses)\n\nfor key in dr_dict.keys():\n    dr_dict[key].obs[\"Dose\"] = f'{key} VAEArith'\n\nctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == 0))]\neval_dict2 = {}\n\nfor d in doses[1:]:\n    stim_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs['Dose'] == d))]\n    eval_dict2[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n    eval_dict2[d].obs[\"dose\"] = [str(i) if type(i) == float else i for i in eval_dict2[d].obs['Dose']]\n\nfor d in doses[1:]:\n    cell_adata = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(cell_adata, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n    print(f\"{d}\")\n    r2_value1 = model.reg_mean_plot(\n        eval_dict2[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"{d} VAEArith\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=f\"../figures/reg_mean_{cell}_{d}.pdf\",\n        show=True,\n        legend=False)\n    r2_value2 = model.reg_mean_plot(\n        eval_dict2[d],\n        condition_key = \"dose\",\n        cell_type_key = \"celltype\",\n        axis_keys={\"x\": f\"0.0\", \"y\": f\"{d}\"},\n        gene_list=diff_genes[:10],\n        top_100_genes = diff_genes[:25],\n        labels={\"x\": \"predicted\", \"y\": \"ground truth\"},\n        path_to_save=f\"../figures/reg_mean_{cell}_{d}.pdf\",\n        show=False,\n        legend=False)\n    print(f\"Model: {model_name}\\n Cell: {cell}\\n Regression: {regression} \\n Dose: {d} \\n R2 All: {r2_value1[0]/r2_value2[0]} \\n R2 Top 100: {r2_value1[1]/r2_value2[1]}\")\n</code></pre> <pre><code>0.01\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 0.01 \n R2 All: 0.999860680974945 \n R2 Top 100: 0.9998531915824196\n\n\n... storing 'dose' as categorical\n\n\n0.03\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 0.03 \n R2 All: 1.000127275652056 \n R2 Top 100: 1.003498742714365\n\n\n... storing 'dose' as categorical\n\n\n0.1\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 0.1 \n R2 All: 1.0012026534483665 \n R2 Top 100: 1.0030401145406367\n\n\n... storing 'dose' as categorical\n\n\n0.3\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 0.3 \n R2 All: 0.9998907869784612 \n R2 Top 100: 1.0003652504181646\n\n\n... storing 'dose' as categorical\n\n\n1.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 1.0 \n R2 All: 1.0052199473007544 \n R2 Top 100: 1.013195643706713\n\n\n... storing 'dose' as categorical\n\n\n3.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 3.0 \n R2 All: 1.0321257864685958 \n R2 Top 100: 1.0055961384731964\n\n\n... storing 'dose' as categorical\n\n\n10.0\n</code></pre> <p></p> <pre><code>Trying to set attribute `.obs` of view, copying.\n\n\nModel: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 10.0 \n R2 All: 1.1629921565058632 \n R2 Top 100: 1.0781834668700891\n\n\n... storing 'dose' as categorical\n\n\n30.0\n</code></pre> <p></p> <pre><code>Model: VAE\n Cell: Hepatocytes - portal\n Regression: False \n Dose: 30.0 \n R2 All: 1.298013701649475 \n R2 Top 100: 1.1335553287004891\n</code></pre>"},{"location":"tutorials/Figure3/#figure-3b-dose-response-prediction-for-ahrr-gene","title":"Figure 3B: Dose-Response Prediction for Ahrr Gene","text":"<p>This analysis compares the predicted expression levels of the Ahrr gene by scVIDR and VAEArith across various TCDD doses to the real observed values. It calculates Sinkhorn distances to quantify discrepancies between the predicted and actual gene expression distributions. The results include a line plot illustrating Ahrr expression across log doses and a bar plot of Sinkhorn distances, highlighting prediction accuracy for both models.</p> <p><pre><code>eval_dict = {d:eval_dict1[d].concatenate(eval_dict2[d][[\"VAEArith\" in i for i in eval_dict2[d].obs[\"dose\"]]]) for d in doses[1:]}\n</code></pre> <pre><code>eval_adata = eval_dict[0.01].concatenate([eval_dict[d] for d in doses[2:]])\n</code></pre></p> <pre><code>response = []\nfor i in eval_adata.obs.dose:\n    if \"scVIDR\" in i:\n        response.append(\"scVIDR\")\n    elif \"VAEArith\" in i:\n        response.append(\"VAEArith\")\n    else:\n        response.append(\"Real Expression\")\neval_adata.obs[\"Response\"] = response\n</code></pre> <pre><code>df = eval_adata.obs[[\"Dose\", \"Response\"]]\ndf[\"Ahrr\"] = eval_adata[:, \"Ahrr\"].X\ndf[\"Dose\"] = [float(i.split(\" \")[0]) if type(i) == str else i for i in df[\"Dose\"]]\ndf[\"Log Dose\"] = [np.log1p(i) for i in df[\"Dose\"]]\n</code></pre> <pre><code>df_dict = {\"Model\":[], \"Log Dose\":[], \"Sinkhorn Distance\":[]}\nmmd = geomloss.SamplesLoss(\"sinkhorn\")\nlog_dose = df[\"Log Dose\"].unique()\nfor dose in log_dose[1:]:\n    df_dose = df[df[\"Log Dose\"] == dose]\n    real_ahrr = df_dose[df_dose.Response == \"Real Expression\"].Ahrr.values\n    scVIDR_ahrr = df_dose[df_dose.Response == \"scVIDR\"].Ahrr.values\n    VAEArith_ahrr = df_dose[df_dose.Response == \"VAEArith\"].Ahrr.values\n    real_tensor = torch.Tensor([real_ahrr]).T\n    scVIDR_tensor = torch.Tensor([scVIDR_ahrr]).T\n    VAEArith_tensor = torch.Tensor([VAEArith_ahrr]).T\n    stat_dist = mmd(real_tensor, scVIDR_tensor).numpy().tolist()\n    df_dict[\"Log Dose\"].append(f'{dose:.{3}f}')\n    df_dict[\"Model\"].append(\"scVIDR\")\n    df_dict[\"Sinkhorn Distance\"].append(stat_dist)\n    print(f\"scVIDR {dose}: {stat_dist}\")\n\n    stat_dist = mmd(real_tensor, VAEArith_tensor).numpy().tolist()\n    df_dict[\"Log Dose\"].append(f'{dose:.{3}f}')\n    df_dict[\"Model\"].append(\"VAEArith\")\n    df_dict[\"Sinkhorn Distance\"].append(stat_dist)\n    print(f\"VAEArith {dose}: {stat_dist}\")\n</code></pre> <pre><code>scVIDR 0.009950330853168083: 7.731077494099736e-05\nVAEArith 0.009950330853168083: 6.842056609457359e-05\nscVIDR 0.0295588022415444: 7.848521636333317e-05\nVAEArith 0.0295588022415444: 6.754948844900355e-05\nscVIDR 0.09531017980432487: 8.383345266338438e-05\nVAEArith 0.09531017980432487: 6.348206079564989e-05\nscVIDR 0.26236426446749106: 0.0006527944933623075\nVAEArith 0.26236426446749106: 0.0006179206538945436\nscVIDR 0.6931471805599453: 0.02270549163222313\nVAEArith 0.6931471805599453: 0.025518372654914856\nscVIDR 1.3862943611198906: 0.07207520306110382\nVAEArith 1.3862943611198906: 0.09400059282779694\nscVIDR 2.3978952727983707: 0.13831457495689392\nVAEArith 2.3978952727983707: 0.20426848530769348\nscVIDR 3.4339872044851463: 0.10823146998882294\nVAEArith 3.4339872044851463: 0.10162720084190369\n</code></pre> <pre><code>fig, ax = plt.subplots()\nax2 = ax.twinx()\nsns.lineplot(x = \"Log Dose\", y = \"Ahrr\", hue = \"Response\", data = df, err_style=\"bars\", ax = ax)\nplt.setp(ax.get_legend().get_texts(), fontsize='10') # for legend text\nplt.setp(ax.get_legend().get_title(), fontsize='10') # for legend title\nplt.savefig(\"../figures/3C.svg\")\nplt.show()\n</code></pre> <p></p> <pre><code>from matplotlib import cm\n</code></pre> <pre><code>cm.tab10.colors[1:]\n</code></pre> <pre><code>((1.0, 0.4980392156862745, 0.054901960784313725),\n (0.17254901960784313, 0.6274509803921569, 0.17254901960784313),\n (0.8392156862745098, 0.15294117647058825, 0.1568627450980392),\n (0.5803921568627451, 0.403921568627451, 0.7411764705882353),\n (0.5490196078431373, 0.33725490196078434, 0.29411764705882354),\n (0.8901960784313725, 0.4666666666666667, 0.7607843137254902),\n (0.4980392156862745, 0.4980392156862745, 0.4980392156862745),\n (0.7372549019607844, 0.7411764705882353, 0.13333333333333333),\n (0.09019607843137255, 0.7450980392156863, 0.8117647058823529))\n</code></pre> <pre><code>df_dists = pd.DataFrame(df_dict)\nsns.barplot(x = \"Log Dose\", y = \"Sinkhorn Distance\", hue = \"Model\", data = df_dists, palette=cm.tab10.colors[1:])\nplt.xticks(rotation = 45)\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/Figure4/","title":"Interrogation of VAE Using Ridge Regression in Portal Hepatocyte Response Prediction","text":"<p>This analysis utilizes a trained scVIDR model to investigate portal hepatocyte responses to TCDD by calculating gene scores through ridge regression on latent dimensions. Genes with high scores indicate significant transcriptomic changes under increasing doses. Enrichr analysis highlights pathways involved in TCDD-induced hepatotoxicity, including cytochrome P450 and fatty acid oxidation. A sigmoid function models the relationship between pathway scores and doses, showing a strong dose-response relationship.</p>"},{"location":"tutorials/Figure4/#importing-required-libraries-and-functions","title":"Importing Required Libraries and Functions","text":"<p>Imports the necessary libraries and modules for processing single-cell gene expression data, model implementation, statistical analysis, and interpretation. It includes tools for machine learning, visualization, statistical tests, and pathway enrichment analysis to facilitate the analysis of scVIDR models and ridge regression.</p> <pre><code>import sys\nsys.path.insert(1, '../vidr/')\nfrom matplotlib import pyplot as plt\n\n#Import VIDR functions\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\n\n#Interpetation of model\nfrom sklearn.linear_model import ElasticNet, Lars, Ridge, LinearRegression\nfrom sklearn.metrics import mean_absolute_error\nimport gseapy as gp\n</code></pre>"},{"location":"tutorials/Figure4/#data-loading-and-preprocessing","title":"Data Loading and Preprocessing","text":"<p>Loads single-cell gene expression data, filters out immune cells to retain specific liver cell types of interest, and preprocesses the dataset. Preprocessing steps include normalizing gene expression, applying a logarithmic transformation, and identifying the top 5,000 highly variable genes for further analysis. Finally, it converts the dose values into categorical strings to facilitate downstream analyses.</p> <pre><code>doses = [0, 0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30]\nadata = sc.read_h5ad(\"../data/nault2021_multiDose.h5ad\")\n\n#Remove Immune Cells\ncell_types_of_int = [\"Hepatocytes - central\", \"Hepatocytes - portal\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\n#Preporces data\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes = 5000)\nadata = adata[:, adata.var.highly_variable]\n\n#Make dose categorical\nadata.obs[\"dose\"] = [str(i) for i in adata.obs[\"Dose\"]]\n</code></pre>"},{"location":"tutorials/Figure4/#training-and-loading-the-vae-model-for-portal-hepatocyte-dose-response-prediction","title":"Training and Loading the VAE Model for Portal Hepatocyte Dose-Response Prediction","text":"<p>Prepares data specific to portal hepatocytes, a cell type of interest, by splitting it into training and test sets. It initializes and optionally trains a Variational Autoencoder (VAE) model to predict gene expression changes in response to TCDD doses. The trained model is then loaded for further analysis.</p> <pre><code>model_name = \"VAE\"\ncelltypes = np.unique(adata.obs[\"celltype\"])\ncell = 'Hepatocytes - portal'\ntrain_adata, test_adata = prepare_cont_data(adata, \"celltype\", \"dose\", \"Dose\", cell, 0, normalized=True)\nprint(f\"\\n Predicting {cell} Dioxin Dose Response\\n\")\nmodel = VIDR(train_adata, linear_decoder = False)\n# model.train(\n# max_epochs=100,\n# batch_size=128,\n# early_stopping=True,\n# early_stopping_patience=25)\n# model.save(f\"../../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt/\", overwrite = True)\nmodel = model.load(f\"../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n</code></pre>"},{"location":"tutorials/Figure4/#ridge-regression-analysis-on-latent-representations","title":"Ridge Regression Analysis on Latent Representations","text":"<p>This series of steps leverages the trained model to predict the dose-response, generate synthetic samples, and apply ridge regression.</p> <p>Generates dose-response predictions for the specified cell type and doses, with delta capturing the response vector. <pre><code>regression = True\ndr_dict, delta, reg = model.predict(\n    ctrl_key=\"0.0\",\n    treat_key=\"30.0\",\n    cell_type_to_predict=cell,\n    regression = regression,\n    continuous = False,\n    doses = doses)\n</code></pre></p> <p>Extracts latent space representations, identifies the range for each dimension, and creates random samples within this range. <pre><code>latent = model.get_latent_representation()\nmins = np.min(latent, axis = 0)\nmaxes = np.max(latent, axis = 0)\nrand_samp = []\nfor (mn,mx) in zip(mins, maxes):\n    rand_samp += [np.random.uniform(mn,mx,  size = (100000))]\nrand_samp = np.array(rand_samp).T\n</code></pre></p> <p>Simulates gene expression data using the model's generative module from the random samples in latent space. <pre><code>device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ngen_samp = model.module.generative(torch.from_numpy(rand_samp).float())[\"px\"].cpu().detach().numpy()\n</code></pre></p> <p>Calculates weights for each sample based on cosine similarity to the delta vector, emphasizing samples aligned with the dose-response. <pre><code>weights = []\nfor i in range(rand_samp.shape[0]):\n    weights += [1/spatial.distance.cosine(rand_samp[i, :], delta)]\n</code></pre></p> <p>Fits a ridge regression model to predict the generative outputs using the latent space samples and their weights. <pre><code>reg = Ridge()\nreg.fit(rand_samp, gen_samp, sample_weight=weights)\n</code></pre></p> <p>Generates new random samples within the latent space range for testing the ridge regression model. <pre><code>test_samp = []\nfor (mn,mx) in zip(mins, maxes):\n    test_samp += [np.random.uniform(mn,mx,  size = (20000))]\ntest_samp = np.array(test_samp).T\n</code></pre></p> <p>Uses the generative module to simulate gene expression data for the test samples. <pre><code>device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\ntest_gen_samp = model.module.generative(torch.from_numpy(test_samp).float())[\"px\"].cpu().detach().numpy()\n</code></pre></p> <p>Evaluates the ridge regression model's performance on the test samples by calculating the R<sup>2</sup> score. <pre><code>reg.score(test_samp,test_gen_samp)\n</code></pre></p> <pre><code>0.6035409897482676\n</code></pre> <p>Calculates normalized gene weights by dividing the regression coefficients by their L2 norms to scale the impact of each gene. <pre><code>gene_weights = reg.coef_\ngene_norms = linalg.norm(reg.coef_, axis = 0)\ngene_weights_norm = gene_weights / gene_norms\n</code></pre> Computes the importance of each feature (gene) by projecting the normalized gene weights onto the delta vector.</p> <pre><code>feature_importance = np.abs(np.dot(gene_weights_norm, delta[:, np.newaxis])).squeeze()\n</code></pre> <p>Identifies the top 100 genes contributing to the dose-response, sorted by their calculated feature importance. <pre><code>train_adata.var_names[np.argsort(feature_importance)[::-1]][:100]\n</code></pre></p> <pre><code>Index(['Egfr', 'Ttc39c', 'Ghr', 'Cps1', 'Kynu', 'Slco1b2', 'Cdh18', 'Fmo3',\n       'Cyp3a25', 'Cyp7b1', 'Nrg1', 'Mug2', 'Aass', 'Ldb2', 'Dlc1', 'Cyp1a1',\n       'Ankrd44', 'Airn', 'Il1r1', 'Reln', '9030622O22Rik', 'Slc7a2', 'Nfe2l2',\n       'Esrrg', 'Meis2', 'Pvt1', '4930578G10Rik', 'Gab2', 'Cyp2c29', 'Pde4d',\n       'Cyp2e1', 'Gm20663', 'Mecom', 'Gm2163', 'Fli1', 'Aox3', 'Heg1', 'Cfh',\n       'Tiparp', 'Cyp1a2', 'Gfra1', 'Sdk1', 'Pck1', 'Slc16a10', 'Auts2',\n       'Camk2d', 'Cyp3a11', 'Robo1', 'Ehd3', 'Plpp1', 'Prkg1', 'Rnf213',\n       'Col4a1', 'Acsl1', 'Col4a2', 'Nrp1', 'Uox', 'Slc8a1', 'Apbb2', 'Tmcc3',\n       'Prickle1', 'Car3', 'Tcf4', 'Gm26917', 'Rnf125', 'Pitpnc1', 'Samd4',\n       'B3galt1', 'Slc38a4', 'Palld', 'Bmp6', 'Mrc1', 'Hao1', 'Maf', 'Jam2',\n       'Fam129b', 'Tshz2', 'Jak1', 'Syne1', 'Abcc4', 'Prex2', 'Tead1', 'Hmcn1',\n       'Abi1', 'C9', 'Adamts9', 'Fkbp5', 'F8', 'Eng', 'Tmem51', 'Plxna4',\n       'Ces3b', 'Dapk2', 'Fndc3b', 'Rftn1', 'Kcnb1', 'Ahrr', 'Maml2', 'Malat1',\n       'Selenop'],\n      dtype='object')\n</code></pre>"},{"location":"tutorials/Figure4/#figure-4b-visualization-of-top-gene-scores","title":"Figure 4B: Visualization of Top Gene Scores","text":"<p>Creates a bar plot showing the top 20 genes with the highest scVIDR gene scores, emphasizing their contribution to the dose-response prediction. The genes are displayed in descending order of importance.</p> <pre><code>plt.figure(dpi = 300)\nplt.bar(train_adata.var_names[np.argsort(feature_importance)][-20:][::-1], feature_importance[np.argsort(feature_importance)][-20:][::-1])\nplt.xticks(rotation = 90, fontsize = 12)\nplt.ylabel(r\"scVIDR Gene Score\", fontsize = 18)\nplt.savefig(\"../figures/4B.svg\", bbox_inches = \"tight\")\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/Figure4/#figure-4c-gene-enrichment-analysis-and-visualization","title":"Figure 4C: Gene Enrichment Analysis and Visualization","text":"<p>Identifies the top 100 genes based on their scores, performs an Enrichr pathway enrichment analysis using the WikiPathways 2019 Mouse database, and visualizes the top 15 enriched pathways with significant adjusted p-values. The bar plot highlights pathways critical to TCDD response.</p> <pre><code>glist = train_adata.var_names[np.argsort(feature_importance)][-100:][::-1]\nglist = glist.tolist()\nenr = gp.enrichr(gene_list=glist,\n                 gene_sets=[\"WikiPathways_2019_Mouse\"],\n                 organism='Mouse', # don't forget to set organism to the one you desired! e.g. Yeast\n                 description='test_name',\n                 outdir='test/enrichr_kegg',\n                 # no_plot=True,\n                 cutoff=0.5 # test dataset, use lower value from range(0,1)\n                )\n</code></pre> <pre><code>enr.results.head(15)\n</code></pre> Gene_set Term Overlap P-value Adjusted P-value Old P-value Old Adjusted P-value Odds Ratio Combined Score Genes 0 WikiPathways_2019_Mouse Tryptophan metabolism WP79 5/44 0.000003 0.000140 0 0 26.802969 344.396446 KYNU;CYP1A2;CYP1A1;CYP2E1;CYP7B1 1 WikiPathways_2019_Mouse Fatty Acid Omega Oxidation WP33 3/7 0.000004 0.000140 0 0 153.835052 1905.147874 CYP1A2;CYP1A1;CYP2E1 2 WikiPathways_2019_Mouse Oxidation by Cytochrome P450 WP1274 4/40 0.000047 0.001046 0 0 22.990741 229.196526 CYP1A2;CYP1A1;CYP2E1;CYP7B1 3 WikiPathways_2019_Mouse Metapathway biotransformation WP1251 5/141 0.000714 0.011957 0 0 7.648607 55.412606 CYP1A2;CYP1A1;FMO3;CYP2E1;CYP7B1 4 WikiPathways_2019_Mouse Ethanol metabolism resulting in production of ... 2/10 0.001085 0.014540 0 0 50.744898 346.391772 CYP2E1;NFE2L2 5 WikiPathways_2019_Mouse Estrogen metabolism WP1264 2/14 0.002166 0.019906 0 0 33.823129 207.504274 CYP1A2;CYP1A1 6 WikiPathways_2019_Mouse Keap1-Nrf2 WP1245 2/14 0.002166 0.019906 0 0 33.823129 207.504274 MAF;NFE2L2 7 WikiPathways_2019_Mouse Focal Adhesion WP85 5/185 0.002377 0.019906 0 0 5.766082 34.838505 RELN;COL4A2;COL4A1;SELENOP;EGFR 8 WikiPathways_2019_Mouse Complement and Coagulation Cascades WP449 3/62 0.003704 0.027578 0 0 10.400664 58.225148 F8;CFH;C9 9 WikiPathways_2019_Mouse Focal Adhesion-PI3K-Akt-mTOR-signaling pathway... 6/324 0.005757 0.038573 0 0 3.930550 20.271055 GHR;RELN;COL4A2;COL4A1;EGFR;JAK1 10 WikiPathways_2019_Mouse MicroRNAs in Cardiomyocyte Hypertrophy WP1560 3/82 0.008073 0.049173 0 0 7.759755 37.395832 CAMK2D;NRG1;PRKG1 11 WikiPathways_2019_Mouse Nuclear receptors in lipid metabolism and toxi... 2/30 0.009829 0.054876 0 0 14.483965 66.951564 CYP1A2;CYP2E1 12 WikiPathways_2019_Mouse EGFR1 Signaling Pathway WP572 4/178 0.012269 0.063234 0 0 4.723659 20.787206 ABI1;GAB2;EGFR;JAK1 13 WikiPathways_2019_Mouse ESC Pluripotency Pathways WP339 3/118 0.021399 0.099196 0 0 5.320932 20.455914 SELENOP;EGFR;JAK1 14 WikiPathways_2019_Mouse ErbB signaling pathway WP1261 2/46 0.022208 0.099196 0 0 9.209647 35.063898 NRG1;EGFR <pre><code>gp.plot.barplot(enr.results,title='Enrichr Analysis of Gene Scores',fs = 8, top_term = 15)\nplt.savefig(\"../figures/4C.svg\", bbox_inches = \"tight\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure4/#figure-4d-gene-enrichment-analysis-and-visualization","title":"Figure 4D: Gene Enrichment Analysis and Visualization","text":"<p>Calculates pathway scores for portal hepatocytes using the genes identified from the enrichment analysis. The results are visualized through PCA projections, highlighting the pathway score and log dose relationships, and saved as figures for further analysis.</p> <pre><code>sc.set_figure_params(dpi = 300)\nsns.set_style(\"dark\")\n</code></pre> <pre><code>hep_adata = adata[adata.obs[\"celltype\"] == \"Hepatocytes - portal\"]\ntop_gs = enr.results[\"Genes\"][1].split(\";\")\npathway = \" \".join(enr.results[\"Term\"][1].split()[:-1])\ntop_gs = [i.lower().capitalize() for i in top_gs]\nsc.tl.score_genes(hep_adata, top_gs)\nhep_adata.obs[\"Log Dose\"] = [np.log1p(d) for d in hep_adata.obs[\"Dose\"]]\n# sc.tl.pca(hep_adata)\n# sc.pl.pca(hep_adata, color = \"score\", color_map = \"flare\", title = \"AHR Pathway Score\")\n# sc.pl.pca(hep_adata, color = \"Log Dose\", color_map = \"flare\")\n</code></pre> <pre><code>sc.tl.pca(hep_adata)\n</code></pre> <p><pre><code>hep_adata.obs[\"Log Score\"] = np.log1p(hep_adata.obs[\"score\"].values)\n</code></pre> Generates a PCA plot of single-cell expression data for portal hepatocytes, colored by fatty acid oxidation pathway scores.</p> <pre><code>sc.pl.pca(hep_adata, color = \"score\", color_map = \"flare\", title = pathway)\nplt.savefig(\"../Figures/Figure3D2.svg\")\n</code></pre> <p></p> <p>Creates a PCA plot of portal hepatocytes colored by log-transformed TCDD dose values. <pre><code>sc.pl.pca(hep_adata, color = \"Log Dose\", color_map = \"flare\")\nplt.savefig(\"../Figures/Figure3D1.svg\")\n</code></pre></p> <p></p>"},{"location":"tutorials/Figure4/#figure-4e-logistic-fit-of-median-pathway-scores","title":"Figure 4E: Logistic Fit of Median Pathway Scores","text":"<p>A logistic curve is fitted to the median pathway scores of fatty acid oxidation across doses, and the Mean Absolute Error (MAE) is calculated to evaluate the fit. The visualization highlights the dose-dependent response in portal hepatocytes.</p> <pre><code>sns.set_style(\"darkgrid\")\n</code></pre> <pre><code>def sigmoid(x, L, k, x0, b):\n    y = L / (1 + np.exp(-k*(x-x0)))+b\n    return (y)\n</code></pre> <pre><code>from scipy.optimize import curve_fit\n</code></pre> <pre><code>df = pd.DataFrame({pathway:hep_adata.obs[\"score\"], \"Dose\":hep_adata.obs[\"Dose\"]})\nx = df[\"Dose\"].unique()\ny = [df[df[\"Dose\"] == d][pathway].median() for d in x]\n</code></pre> <pre><code>df[\"Log Dose\"] = np.log1p(df[\"Dose\"])\ndf[\"Log Score\"] = np.log1p(df[pathway])\nax = sns.scatterplot(x = \"Dose\", y = pathway, data = df, s = 1)\nbounds = ((1., 0., 0.,-5.), (15.,50., 30., 5.))\np0 = [1., 1., 1., 1.]\npopt, pcov = curve_fit(sigmoid, x, y, p0, method='trf', maxfev = 10000, bounds = bounds)\nr2 = mean_absolute_error(y, sigmoid(x, *popt))\nsns.lineplot(x = x, y = sigmoid(x, *popt))\nplt.annotate(f\"MAE = {r2:.{2}}\", (20, 1.7))\nplt.ylabel(f\"{pathway} Score\")\nplt.savefig(\"../Figures/Figure3E.svg\", bbox_inches = \"tight\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure5/","title":"Pseudo-Dose Analysis of Hepatocytes in TCDD Response","text":"<p>This section explores the assignment of pseudo-dose values to hepatocytes by projecting them onto a pseudo-dose axis derived from the latent space of scVIDR. The analysis investigates the relationship between pseudo-dose and real dose, expression of key genes, and liver zonation. It demonstrates how pseudo-dose values correlate with administered doses and differentiate between central and portal hepatocytes, revealing insights into the metabolic and transcriptomic responses to TCDD exposure.</p>"},{"location":"tutorials/Figure5/#importing-required-libraries","title":"Importing Required Libraries","text":"<p>Essential libraries and VIDR functions are imported for single-cell data analysis, statistical computation, and high-quality visualization. </p> <pre><code>import sys\nsys.path.insert(1, '../vidr/')\n\n#Import VIDR functions\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nsc.set_figure_params(dpi = 300, frameon = True)\nsns.set_style(\"dark\")\n</code></pre>"},{"location":"tutorials/Figure5/#data-preparation-for-pseudo-dose-analysis","title":"Data Preparation for Pseudo-Dose Analysis","text":"<p>Loads single-cell data, filters for relevant cell types, and processes the data for pseudo-dose analysis. Cell types are categorized into broader groups (e.g., grouping hepatocytes), doses are made categorical, and the data is normalized, log-transformed, and reduced to the top 5000 highly variable genes.</p> <pre><code>doses = [0, 0.01, 0.03, 0.1, 0.3, 1, 3, 10, 30]\nadata = sc.read_h5ad(\"../data/nault2021_multiDose.h5ad\")\ncell_types_of_int = [\"Hepatocytes - central\", \"Hepatocytes - portal\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\ndef is_hepatocyte(x:str):\n    if \"Hepatocytes\" in x:\n        return \"Hepatocytes\"\n    else:\n        return x\n\nv_isHepatocyte = np.vectorize(is_hepatocyte)\n\ncelltypes = adata.obs[\"celltype\"]\nadata.obs[\"celltype2\"] = celltypes\nadata.obs[\"celltype\"] = v_isHepatocyte(celltypes)\n\nadata.obs[\"dose\"] = [str(i) for i in adata.obs[\"Dose\"]]\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes=5000)\nadata = adata[:, adata.var.highly_variable]\n</code></pre>"},{"location":"tutorials/Figure5/#training-vidr-model-for-hepatocyte-dose-response-prediction","title":"Training VIDR Model for Hepatocyte Dose Response Prediction","text":"<p>This code prepares training data by filtering for hepatocytes and structuring the dataset. It then initializes and trains a VIDR model to predict the dose-response of hepatocytes to dioxin exposure, using 100 epochs and early stopping with a patience of 25.</p> <pre><code>doses = [0.0,0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]\n\nmodel_name = \"VAE\"\n\ncell = \"Hepatocytes\"\n\ntrain_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30.0\", normalized = True)\ntrain_adata = setup_anndata(adata, copy = True, batch_key = \"dose\", labels_key=\"celltype\")\nprint(f\"\\n Predicting {cell} Dioxin Dose Response\\n\")\n\nmodel = VIDR(train_adata, linear_decoder = False, nca_loss = False)\n\nmodel.train(\nmax_epochs=100,\nbatch_size=128,\nearly_stopping=True,\nearly_stopping_patience=25)\n</code></pre> <p>Saves the trained VIDR model for hepatocyte dose-response prediction and reloads it for further analysis. <pre><code>model.save(f\"../data/Continuous_Dioxin_VAE_{cell}.pt\", overwrite = True)\nmodel = model.load(f\"../data/VAE_Cont_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n</code></pre></p> <p>Creates latent space representations of the training data using the VIDR model, stored in an AnnData object.</p> <pre><code>latent_data = model.get_latent_representation()\nlatent_adata = sc.AnnData(X=latent_data , obs=train_adata.obs.copy(),)\n</code></pre> <p>Calculates nearest neighbors and applies UMAP dimensionality reduction on the latent data for visualization.</p> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <p>Plots UMAP projections of the latent space, coloring the data points by celltype, dose, and Dose.</p> <pre><code>sc.pl.umap(latent_adata, color = [\"celltype\", \"dose\", \"Dose\"])\n</code></pre> <p></p>"},{"location":"tutorials/Figure5/#calculating-pseudodose-and-preparing-pca-data","title":"Calculating Pseudodose and Preparing PCA Data","text":"<p>Filters the latent data to include only hepatocyte observations.</p> <p><pre><code>hep_latent_adata = latent_adata[latent_adata.obs[\"celltype\"] == \"Hepatocytes\"]\n</code></pre> Calculates the delta vector by finding the difference between the mean latent representations of treated (30.0) and control (0.0) hepatocytes.</p> <pre><code>mean_treat = np.average(hep_latent_adata[((hep_latent_adata.obs[\"celltype\"] == \"Hepatocytes\") &amp; (hep_latent_adata.obs[\"Dose\"] == 30.0))].X, axis = 0)\nmean_ctrl = np.average(hep_latent_adata[((hep_latent_adata.obs[\"celltype\"] == \"Hepatocytes\") &amp; (hep_latent_adata.obs[\"Dose\"] == 0))].X, axis = 0)\ndelta = mean_treat - mean_ctrl\n</code></pre> <pre><code>delta\n</code></pre> <pre><code>ArrayView([-1.5908594 , -0.7789223 , -1.6158879 , -1.4761918 ,\n            7.473415  ,  5.559472  ,  6.484432  ,  0.3703618 ,\n            0.02829731, -5.4236245 ,  5.7453275 ,  2.2943373 ,\n           -0.93482494, -0.368765  ,  2.5927205 ,  5.6672025 ,\n            1.2594086 ,  0.36797523, -2.1124659 ,  1.5700024 ,\n           -2.5969675 , -4.3866515 ,  1.2291341 ,  5.048762  ,\n            0.46821594, -3.1810694 , -3.713352  ,  0.10406089,\n            1.9408138 , -1.2964935 , -5.362129  , -9.050259  ,\n           -6.3919587 , -2.5839808 , -0.11159652,  2.0792854 ,\n            2.0623562 , -1.2838833 , -0.62048364, -2.535976  ,\n            4.378879  , -0.04124534, -3.584529  , -0.20999141,\n            1.2496918 ,  8.430087  ,  1.4514724 ,  5.211666  ,\n            0.16987807,  2.827426  , -2.9365125 ,  4.2647195 ,\n            0.01951849, -0.24185073, -2.3631287 ,  0.25263762,\n           -0.99487025, -3.020894  , -3.471105  , -1.5591799 ,\n            1.1599275 ,  4.625957  , -0.7811835 , -0.452767  ,\n            0.6537703 , -0.4849658 , -0.47182906,  1.1258912 ,\n           -1.8161821 , -3.1695158 , -3.2429376 , -3.956285  ,\n           -0.62378955, -2.4152884 ,  1.3758457 ,  0.5753751 ,\n            0.27406073,  2.6183238 , -3.5305314 ,  0.9863534 ,\n            0.450068  , -4.164974  ,  0.764345  ,  1.9108295 ,\n           -1.2980747 , -3.2957888 ,  1.0901201 , -0.13923624,\n            0.7284215 , -0.08666986, -6.043189  ,  2.0565515 ,\n           -0.18138188, -0.11264582,  2.3790174 , -1.2957791 ,\n            4.2633057 , -1.8532457 ,  3.4937444 , -1.0702866 ],\n          dtype=float32)\n</code></pre> <p>Calculates the pseudodose for each hepatocyte by projecting its latent vector onto the delta vector. <pre><code>pt_values = []\nfor i in hep_latent_adata.X:\n    pt_value = np.dot(i,delta)/np.dot(delta,delta)\n    pt_values.append(pt_value)\n\npseudodose = np.array(pt_values)\n</code></pre> <pre><code>hep_latent_adata.obs[\"pseudodose\"] = pseudodose\n# meta = pd.read_csv(\"../data/dose-response.metadata.txt\", sep = '\\t')\n# meta.index = np.concatenate([[i+dose_ids[d] for i in meta[meta['Dose']==d].index]  for d in doses])\n</code></pre></p> <p>Performs PCA on hepatocyte latent representations, storing the first two components for visualization, and projects the delta vector onto the PCA space to calculate the pseudo-dose axis.</p> <pre><code>hep_latent_adata.obs[\"Log Dose\"] = np.log1p(hep_latent_adata.obs[\"Dose\"])\n</code></pre> <pre><code>from sklearn.decomposition import PCA\npca = PCA(n_components = 2, svd_solver = 'arpack')\npca_mod = pca.fit(hep_latent_adata.X)\nhep_latent_adata.obsm[\"X_pca\"] = pca_mod.transform(hep_latent_adata.X)\ncoef = np.linspace(-0.5, 2.5, 1000)\ndelta_points = np.array([i*delta for i in coef])\ndelta_pca = pca_mod.transform(delta_points)\n</code></pre>"},{"location":"tutorials/Figure5/#figure-5a-orthogonal-projection-of-hepatocytes-onto-the-pseudo-dose-axis","title":"Figure 5A: Orthogonal Projection of Hepatocytes onto the Pseudo-Dose Axis","text":"<p>Hepatocytes are projected onto the pseudo-dose axis in PCA space, visualizing their alignment along the treatment effect trajectory (delta_c). Random hepatocytes are shown with projections highlighted by red arrows, and pseudo-doses are added to capture their treatment response.</p> <pre><code>np.random.seed(15)\nrand_samp = hep_latent_adata[np.random.randint(0, hep_latent_adata.shape[0], size = (25))]\nax = sc.pl.pca(rand_samp,  frameon=False, return_fig=True, title = [None], size=75, add_outline = True)\n\nv = pca_mod.transform(delta[np.newaxis, :])[0]\nplt.annotate('',xy=(v[0]*0.95, v[1]*0.95),\n             xycoords='data',\n             xytext=(v[0]*-0.85, v[1]*-0.85),\n             textcoords='data',\n             arrowprops=dict(arrowstyle= '-|&gt;',\n                             color='black',\n                             lw=2.5,\n                             ),\n           )\nfor x in rand_samp.obsm[\"X_pca\"]:\n    orth_proj  = (np.dot(v, x)/np.dot(v, v)) * v\n    plt.annotate('',xy=(orth_proj[0], orth_proj[1]),\n             xycoords='data',\n             xytext=(x[0], x[1]),\n             textcoords='data',\n             arrowprops=dict(arrowstyle= '-|&gt;',\n                             color='red',\n                             lw=1,\n                             )\n           )\nplt.title(r\"Orthogonal Projection To $\\delta_c$\")\nplt.savefig(\"../figures/5A.svg\")\nplt.show()\n</code></pre> <p></p> <pre><code>hep_adata = adata[adata.obs.celltype == \"Hepatocytes\"]\n</code></pre> <pre><code>hep_adata.obs[\"pseudo-dose\"] = pseudodose\n</code></pre> <pre><code>pca = PCA(n_components = 2, svd_solver = 'arpack')\npca_mod = pca.fit(hep_adata.X)\nhep_adata.obsm[\"X_pca\"] = pca_mod.transform(hep_adata.X)\ncoef = np.linspace(min(pseudodose)-2.5, max(pseudodose), 100)\ndelta_points = np.array([i*delta for i in coef])\nproj_delta = model.module.generative(torch.Tensor(delta_points))[\"px\"].cpu().detach().numpy()\ndelta_pca = pca_mod.transform(proj_delta)\n</code></pre>"},{"location":"tutorials/Figure5/#figure-5b-pseudo-dose-visualization-in-pca-space","title":"Figure 5B: Pseudo-Dose Visualization in PCA Space","text":"<p>Visualizes hepatocytes in PCA space, colored by their assigned pseudo-dose values. The pseudo-dose axis is overlaid using delta projections, with different doses represented along the axis. Additionally, hepatocyte zones are assigned as \"Central\" or \"Portal\" based on their lobular position.</p> <pre><code>ax = sc.pl.pca(hep_adata, color=['pseudo-dose'], wspace=0.4, frameon=True, return_fig=True, cmap=\"flare\", title = \"\")\nplt.scatter(delta_pca[:, 0], delta_pca[:, 1], s = 25, marker = \"s\", c = \"black\")\nplt.scatter(delta_pca[:, 0], delta_pca[:, 1], s = 15, marker = \"s\", c = \"white\")\nplt.scatter(delta_pca[:, 0], delta_pca[:, 1], s = 5, marker = \"s\", label = \"pseudo-dose axis\", c = [min(pseudodose) if i &lt; min(pseudodose) else i for i in coef], cmap = \"flare\")\nplt.legend()\nplt.savefig(\"../figures/5B.svg\")\nplt.show()\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Zones' as categorical\n</code></pre> <p></p> <pre><code>hep_adata.obs[\"Zones\"] = [\"Central\" if i == \"Hepatocytes - central\" else \"Portal\" for i in hep_adata.obs[\"celltype2\"]]\n</code></pre> <pre><code>hep_adata.obs[\"Log Dose\"] = np.log1p(hep_adata.obs[\"Dose\"])\n</code></pre> <pre><code>ax = sc.pl.pca(hep_adata, color=['Log Dose'], wspace=0.4, frameon=True, return_fig=True, cmap=\"flare\")\n#plt.savefig(\"../figures/5C.svg\")\n</code></pre> <p></p> <pre><code>sns.set_style(\"darkgrid\")\n</code></pre> <pre><code>def sigmoid(x, L, k, x0, b):\n    y = L / (1 + np.exp(-k*(x-x0)))+b\n    return (y)\n</code></pre> <pre><code>from scipy.optimize import curve_fit\nfrom sklearn.metrics import mean_absolute_error\n</code></pre> <pre><code>top_lin_genes = adata.var_names[np.argsort(pt_r2_scores)[::-1]][:100]\n</code></pre> <pre><code>top_gene = 'Fmo3'\n</code></pre> <pre><code>df = pd.DataFrame({\"Dose\":hep_adata.obs[\"Dose\"].values, \"Pseudodose\":hep_adata.obs[\"pseudo-dose\"].values,  \n                   \"Hepatocyte Zones\":hep_adata.obs[\"Zones\"].values, top_gene:hep_adata[:, top_gene].X.squeeze()})\nx = df[\"Pseudodose\"].values\ny = df[top_gene].values\n</code></pre> <pre><code>bounds = ((1., 0., min(pseudodose),-5.), (15.,50.,max(pseudodose), 5.))\np0 = [1.0, 1.0, 1.0, 1.0]\npopt, pcov = curve_fit(sigmoid, x, y, p0, method='trf', \n                       maxfev = 10000, bounds = bounds)\n</code></pre> <pre><code>popt\n</code></pre> <pre><code>array([ 1.9149075 , 14.82530381,  0.3509117 , -0.02009366])\n</code></pre>"},{"location":"tutorials/Figure5/#figure-5d-pseudo-dose-vs-fmo3-expression","title":"Figure 5D: Pseudo-Dose vs. Fmo3 Expression","text":"<p>This plot demonstrates the relationship between pseudo-dose values and the expression of the Fmo3 gene. A logistic fit (solid blue line) is applied to show the sigmoidal trend, and the Mean Absolute Error (MAE) is annotated. The data points are color-coded by hepatocyte zones, highlighting central and portal regions.</p> <pre><code>df = pd.DataFrame({\"Dose\":hep_adata.obs[\"Dose\"].values, \"Pseudodose\":hep_adata.obs[\"pseudo-dose\"].values,  \n                   \"Hepatocyte Zones\":hep_adata.obs[\"Zones\"].values, top_gene:hep_adata[:, top_gene].X.squeeze()})\nax = sns.scatterplot(x = \"Pseudodose\", y = top_gene, hue = \"Hepatocyte Zones\", data = df, s = 1)\nr2 = stats.linregress(x = df[\"Pseudodose\"], y = df[top_gene])\nr2 = mean_absolute_error(y, sigmoid(x, *popt))\nsns.lineplot(x = x, y = sigmoid(x, *popt))\nplt.ylim(min(df[top_gene]), max(df[top_gene]))\nplt.xlim(min(df[\"Pseudodose\"]), max(df[\"Pseudodose\"]))\nplt.xlabel(\"pseudo-dose\")\nplt.annotate(f\"MAE = {r2:.{2}}\", (0.6, 4))\nplt.savefig(\"../figures/5D.svg\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure5/#figure-5c-pseudo-dose-vs-log-dose","title":"Figure 5C: Pseudo-Dose vs. Log Dose","text":"<p>The plot visualizes the relationship between the pseudo-dose values and log-transformed real dose values, highlighting hepatocyte zones (portal and central). A linear regression line with the corresponding R<sup>2</sup>value demonstrates the fit between pseudo-dose and log dose.</p> <pre><code>df = pd.DataFrame({\"Log Dose\":hep_adata.obs[\"Log Dose\"].values, \"Pseudodose\":hep_adata.obs[\"pseudo-dose\"].values,  \n                   \"Hepatocyte Zones\":hep_adata.obs[\"Zones\"].values, top_gene:hep_adata[:, top_gene].X.squeeze()})\n\nx = df[\"Log Dose\"].values\ny = df[\"Pseudodose\"].values\n\nax = sns.scatterplot(x = \"Log Dose\", y = \"Pseudodose\", hue = \"Hepatocyte Zones\", data = df, s = 1)\nm, b, r, p, _ = stats.linregress(x =x, y =y)\nsns.lineplot(x = x, y = x*m+b)\nplt.annotate(f\"$R^2$ = {r**2:.{2}}\", (0.5, 0.75))\nplt.ylabel(\"pseudo-dose\")\nplt.savefig(\"../figures/5C.svg\")\n</code></pre> <p></p>"},{"location":"tutorials/Figure5/#figure-5e-pca-of-hepatocyte-zones","title":"Figure 5E: PCA of Hepatocyte Zones","text":"<p>A PCA plot of hepatocytes is color-coded by their respective zones (portal and central) in the liver lobule, visually distinguishing the distribution of hepatocytes across the latent space.</p> <pre><code>ax = sc.pl.pca(hep_adata, color = ['Zones'], frameon=True, return_fig=True, title = [\"Hepatocyte Zones\"])\nplt.legend(loc = 'lower right')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/Figure5/#figure-5f-pseudo-dose-distribution-across-hepatocyte-zones","title":"Figure 5F: Pseudo-Dose Distribution Across Hepatocyte Zones","text":"<p>The violin plot illustrates the distribution of pseudo-dose values across central and portal hepatocyte zones. Central hepatocytes show a significantly higher pseudo-dose compared to portal hepatocytes, as confirmed by a Mann-Whitney U test.</p> <pre><code>df = hep_adata.obs\npairs = [('Central', 'Portal')]\nax  = sns.violinplot(x = \"Zones\", y = \"pseudo-dose\", data = df)\nannotator = Annotator(ax, pairs, data=df, x=\"Zones\", y=\"pseudo-dose\")\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.savefig(\"../figures/5F.svg\")\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\nCentral vs. Portal: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=7.984e+08\n</code></pre> <p></p>"},{"location":"tutorials/SupplementalFigure2/","title":"SupplementalFigure2","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\nfrom matplotlib import cm\n\nimport scvi\nsc.set_figure_params(dpi = 150)\nsns.set_style(\"dark\")\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/numba/np/ufunc/parallel.py:365: NumbaWarning: \u001b[1mThe TBB threading layer requires TBB version 2019.5 or later i.e., TBB_INTERFACE_VERSION &gt;= 11005. Found TBB_INTERFACE_VERSION = 6103. The TBB threading layer is disabled.\u001b[0m\n  warnings.warn(problem)\nOMP: Info #273: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</code></pre> <pre><code>#Prepare Data Set\nadata = sc.read_h5ad(\"../data/nault2021_singleDose.h5ad\")\ncell_types_of_int = [\"Hepatocytes - portal\", \"Hepatocytes - central\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\nadata.obs[\"dose\"] = [str(i) for i in adata.obs[\"Dose\"]]\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes=5000)\n\nadata = adata[:,adata.var.highly_variable]\n</code></pre> <pre><code>Trying to set attribute `.obs` of view, copying.\n</code></pre> <pre><code>#Training model\ncell = \"Hepatocytes - portal\"\ntrain_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\ntrain_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(train_adata.obs[\"Dose\"], train_adata.obs[\"celltype\"])]\nmodel = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\nvae = model.load(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17791\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                          \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17791\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre> <pre><code>#UMAP Projection of latent space\nlatent_X = vae.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\ncell_dose = [f\"{j}_{str(i)}\" for (i,j) in zip(adata.obs[\"Dose\"], adata.obs[\"celltype\"])]\ntraining = [\"Train\" if i != cell+\"_30\" else \"Test\" for i in cell_dose]\nlatent_adata.obs[\"Cell_Dose\"] = cell_dose\nlatent_adata.obs[\"Training Split\"] = training\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre> <pre><code>from umap import UMAP\nfrom sklearn.decomposition import PCA\n</code></pre> <pre><code>delta_dict = {\"celltype\":[], \"pca_coords\":[], \"pca_delta\":[],\"delta\":[],\n              \"angle\":[], \"magnitude\":[]}\n\nct_labels = adata.obs[\"celltype\"]\ndose_labels = adata.obs[\"Dose\"]\n\nct = \"Average\"\nct_ctrl = latent_adata[(dose_labels == 0)]\nct_treat = latent_adata[(dose_labels == 30)]\n\nctrl_mean = np.average(ct_ctrl.X, axis = 0)\ntreat_mean = np.average(ct_treat.X, axis = 0)\n\ndelta = treat_mean - ctrl_mean\n\navg_delta = delta\n\ndelta_dict[\"celltype\"].append(ct)\n# delta_dict[\"umap_coords\"].append(ct_ctrl.obsm[\"X_umap\"].mean(0))\ndelta_dict[\"delta\"].append(delta)\n# delta_dict[\"umap_delta\"].append(umap_model.transform([delta]).squeeze())\ndelta_dict[\"magnitude\"].append(np.linalg.norm(delta))\ndelta_dict[\"angle\"].append(0)\n</code></pre> <pre><code>cell_types_of_int = [\"Hepatocytes - portal\", \"Hepatocytes - central\", \"Cholangiocytes\",\n                     \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\ncell_types_of_int = sorted(cell_types_of_int)\nfor ct in cell_types_of_int:\n    ct_ctrl = latent_adata[((ct_labels == ct) &amp; (dose_labels == 0))]\n    ct_treat = latent_adata[((ct_labels == ct) &amp; (dose_labels == 30))]\n\n    ctrl_mean = np.average(ct_ctrl.X, axis = 0)\n    treat_mean = np.average(ct_treat.X, axis = 0)\n\n    delta = treat_mean - ctrl_mean\n\n    delta_dict[\"celltype\"].append(ct)\n#     delta_dict[\"umap_coords\"].append(ct_ctrl.obsm[\"X_umap\"].mean(0))\n#     delta_dict[\"umap_delta\"].append(umap_model.transform([delta]).squeeze())\n    delta_dict[\"magnitude\"].append(np.linalg.norm(delta))\n    delta_dict[\"delta\"].append(delta)\n    delta_dict[\"angle\"].append(spatial.distance.cosine(avg_delta, delta))\n</code></pre> <pre><code>all_data = np.concatenate([latent_X, np.array(delta_dict[\"delta\"])])\n</code></pre> <pre><code>pca_model = PCA(n_components=2).fit(all_data)\nX_pca = pca_model.transform(latent_X)\ndelta_pca = pca_model.transform(np.array(delta_dict[\"delta\"]))\n</code></pre> <pre><code>latent_adata.obsm[\"X_pca\"] = X_pca\n</code></pre> <pre><code>ct_ctrl = latent_adata[(dose_labels == 0)]\nct_treat = latent_adata[(dose_labels == 30)]\ndelta_dict[\"pca_coords\"].append(ct_ctrl.obsm[\"X_pca\"].mean(0))\n</code></pre> <pre><code>for ct in cell_types_of_int:\n    ct_ctrl = latent_adata[((ct_labels == ct) &amp; (dose_labels == 0))]\n    ct_treat = latent_adata[((ct_labels == ct) &amp; (dose_labels == 30))]\n    delta_dict[\"pca_coords\"].append(ct_ctrl.obsm[\"X_pca\"].mean(0))\n</code></pre> <pre><code>delta_dict[\"pca_delta\"] = [i.squeeze() for i in delta_pca]\n</code></pre> <pre><code>delta_dict[\"pca_delta\"]\n</code></pre> <pre><code>[array([13.414213 , -1.9513074], dtype=float32),\n array([-7.2149463,  0.8025388], dtype=float32),\n array([ 33.189255, -10.649511], dtype=float32),\n array([-15.064152, -11.30965 ], dtype=float32),\n array([-12.964495 ,  -4.2303033], dtype=float32),\n array([-6.2385263, -0.5436661], dtype=float32),\n array([-4.191285 , -0.9070153], dtype=float32)]\n</code></pre>"},{"location":"tutorials/SupplementalFigure2/#supplemental-figure-2a","title":"Supplemental Figure 2A","text":"<pre><code>fig = plt.figure(dpi = 150)\nx,y = zip(*delta_dict[\"pca_coords\"])\ndx, dy = zip(*delta_dict[\"pca_delta\"])\nfor i in range(len(x)):\n    if i == 0:\n        plt.arrow(x[i],y[i],dx[i],dy[i], color = \"white\", width = 0.25, head_width = 0.75, )\n        plt.arrow(x[i],y[i],dx[i],dy[i], color = cm.tab10.colors[i], width = 0.03, head_width = 0.5, label = delta_dict[\"celltype\"][i])\n    else:\n        plt.arrow(x[i],y[i],dx[i],dy[i], color = \"white\", width = 0.25, head_width = 0.75)\n        plt.arrow(x[i],y[i],dx[i],dy[i], color = cm.tab10.colors[i], width = 0.03, head_width = 0.5, label = delta_dict[\"celltype\"][i])\nplt.title(\"Cell Type $\\delta$\")\nplt.xlabel(\"PCA1\")\nplt.ylabel(\"PCA2\")\nplt.legend(title='Cell Type',title_fontsize=10,loc='center left', bbox_to_anchor=(1, 0.5))\nplt.show()\nplt.savefig(\"../figures/SF2A.svg\", bbox_inches=\"tight\")\n</code></pre> <pre><code>&lt;Figure size 600x600 with 0 Axes&gt;\n</code></pre>"},{"location":"tutorials/SupplementalFigure2/#supplemental-figure-2b","title":"Supplemental Figure 2B","text":"<pre><code>delta_df = pd.DataFrame(delta_dict)\nsns.barplot(x = \"celltype\", y = \"magnitude\", data = delta_df)\nplt.xticks(rotation = 90)\nplt.ylabel(r\"Magnitude of $\\delta$\")\nplt.savefig(\"../figures/SF2B1.svg\", bbox_inches=\"tight\")\n</code></pre> <pre><code>\n</code></pre> <pre><code>delta_df = pd.DataFrame(delta_dict)\nsns.barplot(x = \"celltype\", y = \"angle\", data = delta_df)\nplt.xticks(rotation = 90)\nplt.ylabel(r\"Cosine Distance\")\nplt.savefig(\"../figures/SF2B2.svg\", bbox_inches=\"tight\")\n</code></pre> <pre><code>delat\n</code></pre>"},{"location":"tutorials/SupplementalFigure3/","title":"SupplementalFigure3","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nimport scvi\nsc.set_figure_params(dpi = 150)\nsc.settings.figdir = \"../figures/\"\nsns.set_style(\"dark\")\n</code></pre> <pre><code>adata = sc.read(\"../data/kang2018.h5ad\")\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/compat/__init__.py:180: FutureWarning: Moving element from .uns['neighbors']['distances'] to .obsp['distances'].\n\nThis is where adjacency matrices should go now.\n  warn(\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/compat/__init__.py:180: FutureWarning: Moving element from .uns['neighbors']['connectivities'] to .obsp['connectivities'].\n\nThis is where adjacency matrices should go now.\n  warn(\n</code></pre> <pre><code>#Training model\ncell = \"B\"\ntrain_adata, test_adata = prepare_data(adata, \"cell_type\", \"condition\", cell, \"stimulated\", normalized = True)\nmodel = VIDR(train_adata, linear_decoder = False)\ntrain_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(train_adata.obs[\"condition\"], train_adata.obs[\"cell_type\"])]\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\nvae = model.load(f\"../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt/\", train_adata)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre>"},{"location":"tutorials/SupplementalFigure3/#supplemental-figure-3-a","title":"Supplemental Figure 3 A","text":"<pre><code>#UMAP Projection of latent space\nlatent_X = vae.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\ncell_condition = [f\"{j}_{str(i)}\" for (i,j) in zip(adata.obs[\"condition\"], adata.obs[\"cell_type\"])]\ntraining = [\"Train\" if i != cell+\"_stimulated\" else \"Test\" for i in cell_condition]\nlatent_adata.obs[\"Cell_Condition\"] = cell_condition\nlatent_adata.obs[\"Training Split\"] = training\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16893\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16893 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 100 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['cell_type'], frameon=True,palette = \"tab10\", save =\"S3A1.svg\", title = \"Cell Type\")\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Cell_Condition' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Training Split' as categorical\n\n\nWARNING: saving figure to file ../figures/umapS3A1.svg\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['condition'], frameon=True, save =\"Sup3A2.svg\", title = \"Condition\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/umapSup3A2.svg\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['Training Split'], frameon=True,palette=\"Dark2\", save =\"S3A3.svg\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/umapS3A3.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure3/#supplemental-figure-3b","title":"Supplemental Figure 3B","text":"<pre><code>model = vae\npred, delta = model.predict(\nctrl_key=\"control\",\ntreat_key=\"stimulated\",\ncell_type_to_predict=cell,\nregression = False)\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\ntreat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\neval_adata1 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata1.obs[\"condition\"]:\n    if i == \"control\":\n        treatments.append(\"Control\")\n    elif i == \"stimulated\":\n        treatments.append(r\"IFN$\\beta$\")\n    else:\n        treatments.append(\"VAEArith\")\neval_adata1.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata1)\nsc.pl.pca(eval_adata1, color = \"Treatment\", frameon = True, title = \"\", save = \"sup3B1.svg\")\nCD4T = adata[adata.obs[\"cell_type\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\nr2_value = model.reg_mean_plot(\neval_adata1,\naxis_keys={\"x\": \"pred\", \"y\": r\"stimulated\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/S3B1.svg\",\nshow=True,\nlegend=False, title = \"VAEArith\")\nprint(r2_value)\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'condition' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'cell_type' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'cell_dose' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Treatment' as categorical\n\n\nWARNING: saving figure to file ../figures/pcasup3B1.svg\n</code></pre> <pre><code>Trying to set attribute `.uns` of view, copying.\n</code></pre> <pre><code>(0.9172625485786251, 0.8659317378695021)\n</code></pre> <pre><code>model = vae\npred, delta, reg = model.predict(\nctrl_key=\"control\",\ntreat_key=\"stimulated\",\ncell_type_to_predict=cell,\nregression = True)\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\ntreat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"condition\"]:\n    if i == \"control\":\n        treatments.append(\"Control\")\n    elif i == \"stimulated\":\n        treatments.append(r\"IFN$\\beta$\")\n    else:\n        treatments.append(\"scVIDR\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"sup3C1.svg\")\nCD4T = adata[adata.obs[\"cell_type\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\nr2_value = model.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": r\"stimulated\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/S3B2.svg\",\nshow=True,\nlegend=False, title = \"scVIDR\")\nprint(r2_value)\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'condition' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'cell_type' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'cell_dose' as categorical\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Treatment' as categorical\n\n\nWARNING: saving figure to file ../figures/pcasup3C1.svg\n</code></pre> <pre><code>Trying to set attribute `.uns` of view, copying.\n</code></pre> <pre><code>(0.9658647952933983, 0.9605801751642429)\n</code></pre>"},{"location":"tutorials/SupplementalFigure3/#supplemental-figure-3c","title":"Supplemental Figure 3C","text":"<pre><code>eval_adata = eval_adata1.concatenate(eval_adata2)\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n</code></pre> <pre><code>sc.tl.pca(eval_adata)\nsc.pl.pca(eval_adata, color = \"Treatment\", frameon = True, title = \"\", save = \"S3C.svg\")\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n... storing 'Treatment' as categorical\n\n\nWARNING: saving figure to file ../figures/pcaS3C.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure3/#supplemental-figure-3e","title":"Supplemental Figure 3E","text":"<pre><code>df_list = []\ncell_types = np.unique(adata.obs[\"cell_type\"])\nfor cell in cell_types:\n    print(cell)\n    train_adata, test_adata = prepare_data(adata, \"cell_type\", \"condition\", cell, \"stimulated\", normalized = True)\n\n    model = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt\")\n    model = model.load(f\"../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt/\", train_adata)\n\n    model_name = \"VAEArith\"\n\n    pred, delta = model.predict(\n    ctrl_key=\"control\",\n    treat_key=\"stimulated\",\n    cell_type_to_predict=cell,\n    regression = False)\n\n    pred.obs[\"condition\"] = 'pred'\n    ctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\n    treat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\n    eval_adata = ctrl_adata.concatenate(treat_adata, pred)\n\n    CD4T = adata[adata.obs[\"cell_type\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\n\n    r2_df = calculate_r2_singledose(\n        eval_adata, cell,\n        model_name, \n        \"condition\", \n        {\"x\":\"pred\", \"y\":\"stimulated\"}, \n        diff_genes=diff_genes[:100], \n        random_sample_coef = 0.8,\n        n_iter = 500\n    )\n    df_list.append(r2_df)\n</code></pre> <pre><code>B\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD14+Mono\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16278\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16278 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16278\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16278 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD4T\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m13766\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 13766 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m13766\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 13766 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2109\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2109 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15006\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15006 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15006\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15006 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD8T\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16352\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16352 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16352\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16352 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nDendritic\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16430\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16430 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16430\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16430 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nFCGR3A+Mono\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m14392\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 14392 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m14392\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 14392 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nNK\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16247\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16247 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16247\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16247 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17059\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 17059 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n</code></pre> <pre><code>cell_types = np.unique(adata.obs[\"cell_type\"])\nfor cell in cell_types:\n    print(cell)\n    train_adata, test_adata = prepare_data(adata, \"cell_type\", \"condition\", cell, \"stimulated\", normalized = True)\n\n    model = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt\")\n    model = model.load(f\"../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt/\", train_adata)\n\n    model_name = \"scVIDR\"\n\n    pred, delta, reg = model.predict(\n    ctrl_key=\"control\",\n    treat_key=\"stimulated\",\n    cell_type_to_predict=cell,\n    regression = True)\n\n    pred.obs[\"condition\"] = 'pred'\n    ctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\n    treat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\n    eval_adata = ctrl_adata.concatenate(treat_adata, pred)\n\n    CD4T = adata[adata.obs[\"cell_type\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\n\n    r2_df = calculate_r2_singledose(\n        eval_adata, cell,\n        model_name, \n        \"condition\", \n        {\"x\":\"pred\", \"y\":\"stimulated\"}, \n        diff_genes=diff_genes[:100], \n        random_sample_coef = 0.8,\n        n_iter = 500\n    )\n    df_list.append(r2_df)\n</code></pre> <pre><code>B\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m15900\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 15900 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD14+Mono\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16278\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16278 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16278\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16278 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD4T\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m13766\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 13766 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m13766\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 13766 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2138\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2138 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m30012\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 30012 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nCD8T\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16352\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16352 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16352\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16352 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nDendritic\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16430\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16430 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16430\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16430 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nFCGR3A+Mono\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m14392\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 14392 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m14392\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 14392 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n\n\nNK\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using batches from adata.obs[\"condition\"]\n\n\n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Using labels from adata.obs[\"cell_type\"]\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16247\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16247 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nINFO:scvi.data._anndata:Please do not further modify adata until model is trained.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16247\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 16247 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nINFO:scvi.model.base._base_model:Received view of anndata, making copy.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2437\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 2437 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nINFO:scvi.model.base._base_model:Input adata not setup with scvi. attempting to transfer anndata setup\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X\n\n\nINFO:scvi.data._anndata:Using data from adata.X\n\n\n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\nINFO:scvi.data._anndata:Computing library size prior per batch\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m\n\n\nINFO:scvi.data._anndata:Registered keys:['X', 'batch_indices', 'local_l_mean', 'local_l_var', 'labels']\n\n\n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m7\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nINFO:scvi.data._anndata:Successfully registered anndata object containing 34118 cells, 6998 vars, 2 batches, 7 labels, and 0 proteins. Also registered 0 extra categorical covariates and 0 extra continuous covariates.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.uns` of view, copying.\n</code></pre> <pre><code>r2_values_allCells_df = pd.concat(df_list)\n</code></pre> <pre><code>r2_values_allCells_df.to_csv(\"../data/IFNB_Model_Results.csv\")\n</code></pre> <pre><code>order = ['scVIDR', 'VAEArith']\nhue_order = [\"All HVGs\", \"DEGs\"]\nax = sns.boxplot(x = \"Model\", y = \"R^2\",  data = r2_values_allCells_df, hue = \"Gene Set\", order = order, hue_order = hue_order)\npairs = [\n    (('scVIDR','All HVGs'), ('VAEArith', 'All HVGs')),\n    (('scVIDR','DEGs'), ('VAEArith', 'DEGs'))\n]\nannotator = Annotator(ax, pairs, data=r2_values_allCells_df, x=\"Model\", y=\"R^2\", hue = \"Gene Set\", order = order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.ylabel(r\"$R^2$\")\nplt.savefig(\"../figures/S3E.svg\", bbox_inches = \"tight\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\nscVIDR_All HVGs vs. VAEArith_All HVGs: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=1.222e+07\nscVIDR_DEGs vs. VAEArith_DEGs: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=1.224e+07\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure4/","title":"SupplementalFigure4","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nsc.set_figure_params(dpi = 150, frameon = True)\nsns.set_style(\"dark\")\nsc.settings.figdir = \"../figures\"\n</code></pre> <pre><code>adata = sc.read_h5ad(\"../data/srivatsan2020.h5ad\")\n</code></pre> <pre><code>adata.obs[\"drug_dose\"] = [f\"{i}_{j}\" for (i, j) in zip(adata.obs[\"product_name\"], adata.obs[\"dose\"])]\n</code></pre> <pre><code>adata = setup_anndata(adata, copy = True, batch_key =\"drug_dose\", labels_key=\"cell_type\")\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"drug_dose\"\u001b[0m\u001b[1m]\u001b[0m                                           \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m                                            \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m680685\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n</code></pre> <pre><code># drug_list = adata[~(adata.obs[\"product_name\"] == \"Vehicle\")].obs[\"product_name\"].unique()\n</code></pre> <pre><code># np.savetxt(\"../../data/sciplex3_drug_list.txt\", drug_list, delimiter=\" \", fmt=\"%s\")\n</code></pre> <pre><code># np.random.seed(42)\n</code></pre> <pre><code># ind = np.random.choice(len(drug_list), int(len(drug_list)/5))\n</code></pre> <pre><code># test_drug_list = drug_list[ind]\n</code></pre> <pre><code># np.savetxt(\"../../data/sciplex3_test_drug_list.txt\", test_drug_list, delimiter=\" \", fmt=\"%s\")\n</code></pre> <pre><code>test_drugs = np.loadtxt(\"../data/srivatsan2020_testDrugList.txt\", dtype = str, delimiter=\"\\t\")\n</code></pre> <pre><code>test_drugs.shape\n</code></pre> <pre><code>(37,)\n</code></pre> <pre><code>train_adata = adata[~((adata.obs[\"product_name\"].isin(test_drugs)) &amp; (adata.obs[\"cell_type\"] == \"A549\"))]\n</code></pre> <pre><code>model = VIDR(train_adata.copy(), linear_decoder = False)\n</code></pre> <pre><code>None\n</code></pre> <pre><code># model.train(\n# max_epochs=100,\n# batch_size=256,\n# early_stopping=True,\n# early_stopping_patience=25,\n# train_size=0.8\n# )\n</code></pre> <pre><code># model.save(f\"../../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt\")\n</code></pre> <pre><code>model =  model.load(\"../data/VAE_Cont_Prediction_sciplex3_80perDrug_24hours_Dela549.pt/\", train_adata)\n</code></pre> <pre><code>Trying to set attribute `.uns` of view, copying.\n\n\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n</code></pre> <pre><code>latent_X = model.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X = latent_X, obs = adata.obs.copy())\n</code></pre> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 100 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>latent_adata.obs[\"Training Split\"] = [\"Test\" if ((i == \"A549\") &amp; (j in test_drugs)) else \"Train\" for (i, j) in zip(latent_adata.obs[\"cell_type\"], latent_adata.obs[\"product_name\"])]\n</code></pre> <pre><code>latent_adata.obs[\"Cell Type\"] = latent_adata.obs[\"cell_type\"]\n</code></pre> <pre><code>latent_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(latent_adata.obs[\"dose\"], latent_adata.obs[\"cell_type\"])]\n</code></pre> <pre><code>centroids = {cell:np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"cell_dose\"] == cell], axis = 0) for cell in np.unique(latent_adata.obs[\"cell_dose\"])}\ncentroids[\"0\"] = np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"dose\"] == \"0.0\"], axis = 0)\ncentroids[\"30\"] = np.average(latent_adata.obsm[\"X_umap\"][latent_adata.obs[\"dose\"] == \"30.0\"], axis = 0)\n</code></pre>"},{"location":"tutorials/SupplementalFigure4/#supplemental-figure-4a","title":"Supplemental Figure 4A","text":"<pre><code>ax = sc.pl.umap(latent_adata, color = [\"Cell Type\"], frameon=True, return_fig=True)\nplt.savefig(\"../figures/S4A1.svg\", bbox_inches='tight')\n</code></pre> <pre><code>... storing 'drug_dose' as categorical\n... storing 'Training Split' as categorical\n... storing 'cell_dose' as categorical\n</code></pre> <pre><code>ax =sc.pl.umap(latent_adata[latent_adata.obs[\"cell_type\"] == \"A549\"], color = [\"Training Split\"], frameon=False, return_fig = True, palette= \"coolwarm\")\nplt.title(\"Training Split: A549 Cells\")\n\nplt.savefig(\"../figures/S4A2.svg\", bbox_inches='tight')\n</code></pre> <pre><code>Trying to set attribute `.uns` of view, copying.\n</code></pre> <pre><code>ax =sc.pl.umap(latent_adata, color = [\"dose\"], frameon=True, return_fig = True, cmap = \"flare\")\nplt.title(\"Dose\")\n\nplt.savefig(\"../figures/S4A3.svg\", bbox_inches='tight')\n</code></pre> <pre><code># def calculate_r2(\n#     adata,\n#     cell: str,\n#     model: str,\n#     condition_key: str,\n#     axis_keys:dict,\n#     diff_genes = None,\n#     random_sample_coef = None,\n#     n_iter: int = 1,\n# ):\n#     #Set condition key\n\n#     #Densify sparse matrix\n#     if sparse.issparse(adata.X):\n#         adata.X = adata.X.A\n\n#     #Treatment and Prediction\n#     treat = adata[adata.obs[condition_key] == axis_keys[\"y\"]] \n#     pred = adata[adata.obs[condition_key] == axis_keys[\"x\"]]\n\n#     r2_values_dict = {\"R^2\":[], \"Gene Set\":[]}\n#     for i in range(n_iter):\n\n#         if random_sample_coef is not None:\n#             treat_idx = np.random.choice(np.arange(0, treat.shape[0]), int(random_sample_coef*treat.shape[0]))\n#             pred_idx = np.random.choice(np.arange(0, pred.shape[0]), int(random_sample_coef*pred.shape[0]))\n#             treat_samp = treat[treat_idx, :]\n#             pred_samp = pred[pred_idx, :]\n\n#         else:\n#             treat_samp = treat\n#             pred_samp = samp\n\n#         if diff_genes is not None:\n#             treat_diff = treat_samp[:, diff_genes]\n#             pred_diff = pred_samp[:, diff_genes]\n\n#             x_diff = np.average(pred_diff.X, axis=0)\n#             y_diff = np.average(treat_diff.X, axis = 0)\n#             m, b, r_value_diff, p_value_diff, std_err_diff = stats.linregress(\n#                 x_diff, y_diff\n#             )\n#             r2_values_dict[\"R^2\"].append(r_value_diff ** 2)\n#             r2_values_dict[\"Gene Set\"].append(\"DEGs\")\n\n\n#         x = np.average(treat_samp.X, axis = 0)\n#         y = np.average(pred_samp.X, axis = 0)\n#         m, b, r_value, p_value, std_err = stats.linregress(x, y)\n#         r2_values_dict[\"R^2\"].append(r_value ** 2)\n#         r2_values_dict[\"Gene Set\"].append(\"All HVGs\")\n\n#     r2_values_df = pd.DataFrame(r2_values_dict)\n#     r2_values_df[\"Cell\"] = cell\n#     r2_values_df[\"Model\"] = model\n#     r2_values_df[\"Dose\"] = axis_keys[\"y\"]\n#     return r2_values_df\n</code></pre> <pre><code># df_list = []\n# regression = False\n# cell = \"A549\"\n# for idx, drug in enumerate(test_drugs):\n#     print(idx)\n#     print(drug)\n#     model = VIDR(train_adata, linear_decoder = False)\n# #     model.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n#     model = model.load(f\"../../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\n#     train_adata_drug = adata[adata.obs.product_name == drug]\n#     model_name = \"VAEArith\"\n\n#     max_dose = train_adata_drug.obs.dose.max()\n#     min_dose = train_adata_drug.obs.dose.min()\n#     doses = np.sort(train_adata_drug.obs.dose.unique())\n\n#     ctrl_x = train_adata[train_adata.obs[\"product_name\"] == \"Vehicle\", :]\n#     treat_x = train_adata[(train_adata.obs[\"product_name\"] == drug) &amp; (train_adata.obs[\"dose\"] == 10000)]\n#     ctrl_x = random_sample(ctrl_x, \"cell_type\")\n#     treat_x = random_sample(treat_x, \"cell_type\")\n#     new_adata = ctrl_x.concatenate(treat_x)\n#     new_adata = random_sample(new_adata, \"dose\", max_or_min = \"min\", replacement = False)\n\n#     if sparse.issparse(new_adata.X):\n#             new_adata.X = new_adata.X.A\n\n#     ctrl_data = new_adata[(new_adata.obs[\"cell_type\"] == \"A549\") &amp; (new_adata.obs[\"product_name\"] == \"Vehicle\")]\n#     latent_cd = model.get_latent_representation(ctrl_data)\n#     ctrl_x = new_adata[new_adata.obs[\"dose\"] == 0].copy()\n#     treat_x = new_adata[new_adata.obs[\"dose\"] == 10000].copy()\n\n#     #Compress data to latent space and then calculate the delta\n#     latent_ctrl = np.average(model.get_latent_representation(ctrl_x), axis = 0)\n#     latent_treat = np.average(model.get_latent_representation(treat_x), axis = 0)\n#     delta = latent_treat - latent_ctrl\n#     doses = adata.obs.dose.unique()\n#     doses.sort()\n#     treat_pred_dict = {d:delta*(np.log1p(d)/np.log1p(max(doses))) + latent_cd  for d in doses if d &gt; min(doses)}\n#     predicted_cells_dict = {d:model.module.generative(torch.Tensor(treat_pred_dict[d]))[\"px\"].cpu().detach().numpy() for d in doses if d &gt; min(doses)}\n#     dr_dict = {d:sc.AnnData(X=predicted_cells_dict[d], obs=ctrl_data.obs.copy(), var=ctrl_data.var.copy(),obsm=ctrl_data.obsm.copy(),) for d in doses if d &gt; min(doses)}\n\n#     for key in dr_dict.keys():\n#         dr_dict[key].obs[\"dose\"] = f'{key} VAEArith'\n\n#     ctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == 0))]\n#     eval_dict1 = {}\n\n#     for d in doses[1:]:\n#         stim_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == d))]\n#         eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n#         eval_dict1[d].obs[\"Dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['dose']]\n\n#     cell_adata = adata[(adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==drug)]\n#     cell_adata.obs[\"Dose\"] = [str(i) for i in cell_adata.obs[\"dose\"]]\n#     sc.tl.rank_genes_groups(cell_adata, groupby=\"Dose\", method=\"wilcoxon\")\n#     print(\"..Finished Differential Expression\")\n#     for d in doses[1:]:\n#         print(d)\n#         diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n#         print(eval_dict1[d].obs.Dose.unique())\n#         r2_df = calculate_r2(\n#             eval_dict1[d], \n#             cell,\n#             model_name, \n#             \"Dose\", \n#             {\"x\":f'{d} VAEArith', \"y\":f\"{d}\"}, \n#             diff_genes=diff_genes[:100], \n#             random_sample_coef = 0.8,\n#             n_iter = 100\n#         )\n#         r2_df.to_csv(f\"../../data/Sciplex3_VAEArith_{d}_{drug}.csv\")\n#     print(f\"...Finished {drug}\")\n</code></pre> <pre><code>0\nTGX-221\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m298\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m888\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m888\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished TGX-221\n1\nCrizotinib (PF-02341066)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m215\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m620\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m620\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Crizotinib (PF-02341066)\n2\nTranylcypromine (2-PCPA) HCl\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m382\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1120\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1120\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Tranylcypromine (2-PCPA) HCl\n3\nXAV-939\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m254\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m792\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m792\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished XAV-939\n4\nDecitabine\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m294\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m908\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m908\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Decitabine\n5\nPirarubicin\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m148\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m466\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m466\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Pirarubicin\n6\nTemsirolimus (CCI-779, NSC 683864)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m251\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m764\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m764\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Temsirolimus (CCI-779, NSC 683864)\n7\nSB431542\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m300\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m902\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m902\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished SB431542\n8\nCarmofur\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m291\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m854\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m854\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Carmofur\n9\nBelinostat (PXD101)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m338\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1020\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1020\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Belinostat (PXD101)\n10\nAnacardic Acid\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m303\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m974\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m974\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Anacardic Acid\n11\nAMG-900\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m254\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m824\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m824\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished AMG-900\n12\nIniparib (BSI-201)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m330\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1012\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1012\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Iniparib (BSI-201)\n13\nRaltitrexed\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m251\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m734\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m734\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Raltitrexed\n14\nIvosidenib (AG-120)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m239\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m712\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m712\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Ivosidenib (AG-120)\n15\nNintedanib (BIBF 1120)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m131\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m434\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m434\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Nintedanib (BIBF 1120)\n16\nNilotinib (AMN-107)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m319\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m888\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m888\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Nilotinib (AMN-107)\n17\nAlendronate sodium trihydrate\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m211\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m646\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m646\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Alendronate sodium trihydrate\n18\nPD173074\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m263\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m742\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m742\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished PD173074\n19\nBarasertib (AZD1152-HQPA)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m264\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m804\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m804\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Barasertib (AZD1152-HQPA)\n20\nZileuton\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m303\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m960\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m960\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Zileuton\n21\nSL-327\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m234\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m738\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m738\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished SL-327\n22\nUNC0379\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m192\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m576\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m576\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished UNC0379\n23\nTacedinaline (CI994)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m380\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1082\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1082\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Tacedinaline (CI994)\n24\nGlesatinib?(MGCD265)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m219\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m606\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m606\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Glesatinib?(MGCD265)\n25\nOfloxacin\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m393\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1134\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1134\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Ofloxacin\n26\nStreptozotocin (STZ)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m351\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1016\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1016\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Streptozotocin (STZ)\n27\nResminostat\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m295\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m900\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m900\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Resminostat\n28\nResveratrol\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m387\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1066\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1066\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Resveratrol\n29\nBelinostat (PXD101)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m338\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1020\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1020\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Belinostat (PXD101)\n30\nAG-490 (Tyrphostin B42)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m341\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1024\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1024\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished AG-490 (Tyrphostin B42)\n31\nUNC1999\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m340\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1076\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1076\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished UNC1999\n32\nTrametinib (GSK1120212)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m262\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m808\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m808\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Trametinib (GSK1120212)\n33\nENMD-2076\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m177\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m540\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m540\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished ENMD-2076\n34\nBusulfan \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m332\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m986\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m986\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Busulfan \n35\nTrametinib (GSK1120212)\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m270\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m808\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m808\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished Trametinib (GSK1120212)\n36\nTMP195\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m310\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m936\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m936\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 VAEArith']\n100.0\n['0.0' '100.0' '100.0 VAEArith']\n1000.0\n['0.0' '1000.0' '1000.0 VAEArith']\n10000.0\n['0.0' '10000.0' '10000.0 VAEArith']\n...Finished TMP195\n</code></pre> <pre><code># regression = True\n# cell = \"A549\"\n# for idx, drug in list(enumerate(test_drugs))[31:]:\n#     print(drug, idx)\n#     model = VIDR(train_adata.copy(), linear_decoder = False)\n# #     model.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n#     model = model.load(f\"../../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\n#     train_adata_drug = adata[adata.obs.product_name == drug]\n#     model_name = \"scVIDR\"\n\n#     max_dose = train_adata_drug.obs.dose.max()\n#     min_dose = train_adata_drug.obs.dose.min()\n#     doses = np.sort(train_adata_drug.obs.dose.unique())\n\n#     ctrl_x = train_adata[train_adata.obs[\"product_name\"] == \"Vehicle\", :]\n#     treat_x = train_adata[(train_adata.obs[\"product_name\"] == drug) &amp; (train_adata.obs[\"dose\"] == max_dose)]\n#     ctrl_x = random_sample(ctrl_x, \"cell_type\")\n#     treat_x = random_sample(treat_x, \"cell_type\")\n#     new_adata = ctrl_x.concatenate(treat_x)\n#     new_adata = random_sample(new_adata, \"dose\", max_or_min = \"min\", replacement = False)\n#     if sparse.issparse(new_adata.X):\n#             new_adata.X = new_adata.X.A\n#     ctrl_data = new_adata[(new_adata.obs[\"cell_type\"] == \"A549\") &amp; (new_adata.obs[\"product_name\"] == \"Vehicle\")]\n#     latent_cd = model.get_latent_representation(ctrl_data)\n#     #Regression on latent space\n#     latent_X =  model.get_latent_representation(new_adata)\n#     latent_adata = sc.AnnData(X=latent_X, obs = new_adata.obs.copy())\n#     #Get deltas and control centroids for each cell tpye in the training dataset\n#     deltas = []\n#     latent_centroids = []\n#     cell_types = np.unique(latent_adata.obs[\"cell_type\"])\n#     for cell_type in cell_types:\n#         if cell_type != \"A549\":\n#             latent_ctrl = latent_adata[(latent_adata.obs[\"cell_type\"] == cell_type) &amp; (latent_adata.obs[\"dose\"] == 0)]\n#             latent_treat = latent_adata[(latent_adata.obs[\"cell_type\"] == cell_type) &amp; (latent_adata.obs[\"dose\"] == 10000)]\n#             ctrl_centroid = np.average(latent_ctrl.X, axis = 0)\n#             treat_centroid = np.average(latent_treat.X, axis = 0)\n#             delta = np.average(latent_treat.X, axis = 0) - np.average(latent_ctrl.X, axis = 0)\n#             deltas.append(delta)\n#             latent_centroids.append(ctrl_centroid)\n#     lr = LinearRegression()\n#     reg = lr.fit(latent_centroids, deltas)\n#     delta = reg.predict([np.average(latent_cd, axis = 0)])[0]\n#     doses = adata.obs.dose.unique()\n#     doses.sort()\n#     treat_pred_dict = {d:delta*(np.log1p(d)/np.log1p(max(doses))) + latent_cd  for d in doses if d &gt; min(doses)}\n#     predicted_cells_dict = {d:model.module.generative(torch.Tensor(treat_pred_dict[d]))[\"px\"].cpu().detach().numpy() for d in doses if d &gt; min(doses)}\n#     dr_dict = {d:sc.AnnData(X=predicted_cells_dict[d], obs=ctrl_data.obs.copy(), var=ctrl_data.var.copy(),obsm=ctrl_data.obsm.copy(),) for d in doses if d &gt; min(doses)}\n#     for key in dr_dict.keys():\n#         dr_dict[key].obs[\"dose\"] = f'{key} scVIDR'\n\n#     ctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == 0))]\n#     eval_dict1 = {}\n\n#     for d in doses[1:]:\n#         stim_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == d))]\n#         eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n#         eval_dict1[d].obs[\"Dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['dose']]\n\n#     cell_adata = adata[(adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==drug)]\n#     cell_adata.obs[\"Dose\"] = [str(i) for i in cell_adata.obs[\"dose\"]]\n#     sc.tl.rank_genes_groups(cell_adata, groupby=\"Dose\", method=\"wilcoxon\")\n#     print(\"..Finished Differential Expression\")\n#     for d in doses[1:]:\n#         print(d)\n#         diff_genes = cell_adata.uns[\"rank_genes_groups\"][\"names\"][str(d)]\n#         print(eval_dict1[d].obs.Dose.unique())\n#         r2_df = calculate_r2(\n#             eval_dict1[d], \n#             cell,\n#             model_name, \n#             \"Dose\", \n#             {\"x\":f'{d} scVIDR', \"y\":f\"{d}\"}, \n#             diff_genes=diff_genes[:100], \n#             random_sample_coef = 0.8,\n#             n_iter = 100\n#         )\n#         r2_df.to_csv(f\"../../data/Sciplex3_scVIDR_{d}_{drug}.csv\")\n#     print(f\"...Finished {drug}\")\n</code></pre> <pre><code>UNC1999 31\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m381\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2152\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\nTrametinib (GSK1120212) 32\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m263\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1616\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\nENMD-2076 33\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m190\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1080\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\nBusulfan  34\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m306\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1972\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\nTrametinib (GSK1120212) 35\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m273\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1616\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\nTMP195 36\nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m651019\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m      \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.                                                  \nNone\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m336\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m batches,\n         \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m1872\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m753\u001b[0m        \n         batches, \u001b[1;36m3\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates   \n         and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n... storing 'drug_dose' as categorical\n... storing 'Dose' as categorical\n\n\n..Finished Differential Expression\n10.0\n['0.0' '10.0' '10.0 scVIDR']\n100.0\n['0.0' '100.0' '100.0 scVIDR']\n1000.0\n['0.0' '1000.0' '1000.0 scVIDR']\n10000.0\n['0.0' '10000.0' '10000.0 scVIDR']\n...Finished {drug}\n</code></pre> <pre><code>df_list = []\ndoses = [0.0, 10.0, 100.0, 1000.0, 10000.0]\nfor idx, drug in enumerate(test_drugs):\n    for d in doses[1:]:\n        df = pd.read_csv(f\"../data/Sciplex3_VAEArith_{d}_{drug}.csv\")\n        df[\"drug\"] = drug\n        df_list.append(df)\nfor idx, drug in enumerate(test_drugs):\n    for d in doses[1:]:\n        df = pd.read_csv(f\"../data/Sciplex3_scVIDR_{d}_{drug}.csv\")\n        df[\"drug\"] = drug\n        df_list.append(df)\n</code></pre> <pre><code>df_full = pd.concat(df_list)\n</code></pre> <pre><code>df_full[\"Dose\"] = df_full[\"Dose\"].astype(str)\n</code></pre> <pre><code>pathway_dict = {drug:pathway for drug, pathway in zip(adata.obs[\"product_name\"], adata.obs[\"pathway\"])}\n</code></pre> <pre><code>df_full[\"pathway\"] = df_full[\"drug\"].apply(pathway_dict.get)\n</code></pre> <pre><code>df_hvg = df_full[df_full[\"Gene Set\"] == \"All HVGs\"]\n</code></pre> <pre><code>pathways = sorted(df_hvg.pathway.unique())\n</code></pre> <pre><code>Counter(df_hvg.pathway)\n</code></pre> <pre><code>Counter({'PI3K/Akt/mTOR': 1600,\n         'Protein Tyrosine Kinase': 3200,\n         'Epigenetics': 8800,\n         'Stem Cells &amp;  Wnt': 800,\n         'DNA Damage': 5600,\n         'TGF-beta/Smad': 800,\n         'Cell Cycle': 1600,\n         'Metabolism': 1600,\n         'Angiogenesis': 2400,\n         'Others': 800,\n         'MAPK': 2400})\n</code></pre>"},{"location":"tutorials/SupplementalFigure4/#supplemental-figure-4d1","title":"Supplemental Figure 4D1","text":"<pre><code>order = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.boxplot(x = \"Dose\", y = \"R^2\",  data = df_hvg, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"100.0\", \"scVIDR\"),(\"100.0\", \"VAEArith\")),\n    ((\"1000.0\", \"scVIDR\"),(\"1000.0\", \"VAEArith\")),\n    ((\"10000.0\", \"scVIDR\"),(\"10000.0\", \"VAEArith\")),\n]\nannotator = Annotator(ax, pairs, data=df_hvg, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ All HVGs\")\nplt.savefig(\"../figures/SF4D1.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n100.0_scVIDR vs. 100.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=1.058e+07\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.404e-165 U_stat=9.361e+06\n1000.0_scVIDR vs. 1000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=1.176e+07\n10000.0_scVIDR vs. 10000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:0.000e+00 U_stat=1.206e+07\n</code></pre> <pre><code>df_deg = df_full[df_full[\"Gene Set\"] == \"DEGs\"]\n</code></pre>"},{"location":"tutorials/SupplementalFigure4/#supplemental-figure-4c","title":"Supplemental Figure 4C","text":"<pre><code>drug = \"Belinostat (PXD101)\"\ndf = df_deg[df_deg.drug == drug]\norder = [str(i) for i in doses][1:]\nhue_order = [\"scVIDR\", \"VAEArith\"]\nax = sns.barplot(x = \"Dose\", y = \"R^2\",  data = df, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"100.0\", \"scVIDR\"),(\"100.0\", \"VAEArith\")),\n    ((\"1000.0\", \"scVIDR\"),(\"1000.0\", \"VAEArith\")),\n    ((\"10000.0\", \"scVIDR\"),(\"10000.0\", \"VAEArith\")),\n]\nannotator = Annotator(ax, pairs, data=df, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(f\"$R^2$ Top 100 DEGs for {drug}\", fontsize = 10)\nplt.savefig(f'../figures/SF4C_{drug.replace(\"/\", \"_\")}.svg')\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n100.0_scVIDR vs. 100.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.409e-67 U_stat=4.000e+04\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.409e-67 U_stat=4.000e+04\n1000.0_scVIDR vs. 1000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.409e-67 U_stat=4.000e+04\n10000.0_scVIDR vs. 10000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:2.409e-67 U_stat=4.000e+04\n</code></pre>"},{"location":"tutorials/SupplementalFigure4/#supplementary-figure-4d2","title":"Supplementary Figure 4D2","text":"<pre><code>order = [str(i) for i in doses][1:]\nhue_order = ['scVIDR', 'VAEArith']\nax = sns.boxplot(x = \"Dose\", y = \"R^2\",  data = df_deg, hue = \"Model\", order = order, hue_order = hue_order)\npairs = [\n    ((\"10.0\", \"scVIDR\"),(\"10.0\", \"VAEArith\")),\n    ((\"100.0\", \"scVIDR\"),(\"100.0\", \"VAEArith\")),\n    ((\"1000.0\", \"scVIDR\"),(\"1000.0\", \"VAEArith\")),\n    ((\"10000.0\", \"scVIDR\"),(\"10000.0\", \"VAEArith\")),\n]\nannotator = Annotator(ax, pairs, data=df_deg, x=\"Dose\", y=\"R^2\", hue = \"Model\", order = order, hue_order=hue_order)\nannotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\nannotator.apply_and_annotate()\nplt.xticks(fontsize = 10)\nplt.ylabel(r\"$R^2$ Top 100 DEGs\")\nplt.savefig(\"../figures/SF4D2.svg\")\nplt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\n100.0_scVIDR vs. 100.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.435e-90 U_stat=8.696e+06\n10.0_scVIDR vs. 10.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:4.757e-51 U_stat=8.222e+06\n1000.0_scVIDR vs. 1000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:1.602e-245 U_stat=9.918e+06\n10000.0_scVIDR vs. 10000.0_VAEArith: Mann-Whitney-Wilcoxon test greater, P_val:9.229e-265 U_stat=1.004e+07\n</code></pre> <pre><code>df_list = []\nregression = True\ncell = \"A549\"\ndrug = \"Belinostat (PXD101)\"\nmodel = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\nmodel = model.load(f\"../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\ntrain_adata_drug = adata[adata.obs.product_name == drug]\nmodel_name = \"scVIDR\"\n\nmax_dose = train_adata_drug.obs.dose.max()\nmin_dose = train_adata_drug.obs.dose.min()\ndoses = np.sort(train_adata_drug.obs.dose.unique())\n\nctrl_x = train_adata[train_adata.obs[\"product_name\"] == \"Vehicle\", :]\ntreat_x = train_adata[(train_adata.obs[\"product_name\"] == drug) &amp; (train_adata.obs[\"dose\"] == 10000)]\nctrl_x = random_sample(ctrl_x, \"cell_type\")\ntreat_x = random_sample(treat_x, \"cell_type\")\nnew_adata = ctrl_x.concatenate(treat_x)\nnew_adata = random_sample(new_adata, \"dose\", max_or_min = \"min\", replacement = False)\n\nif sparse.issparse(new_adata.X):\n        new_adata.X = new_adata.X.A\n\nctrl_data = new_adata[(new_adata.obs[\"cell_type\"] == \"A549\") &amp; (new_adata.obs[\"product_name\"] == \"Vehicle\")]\nlatent_cd = model.get_latent_representation(ctrl_data)\nctrl_x = new_adata[new_adata.obs[\"dose\"] == 0].copy()\ntreat_x = new_adata[new_adata.obs[\"dose\"] == 10000].copy()\n\n#Get deltas and control centroids for each cell tpye in the training dataset\ndeltas = []\nlatent_centroids = []\ncell_types = np.unique(latent_adata.obs[\"cell_type\"])\nfor cell_type in cell_types:\n    if cell_type != \"A549\":\n        latent_ctrl = latent_adata[(latent_adata.obs[\"cell_type\"] == cell_type) &amp; (latent_adata.obs[\"dose\"] == 0)]\n        latent_treat = latent_adata[(latent_adata.obs[\"cell_type\"] == cell_type) &amp; (latent_adata.obs[\"dose\"] == 10000)]\n        ctrl_centroid = np.average(latent_ctrl.X, axis = 0)\n        treat_centroid = np.average(latent_treat.X, axis = 0)\n        delta = np.average(latent_treat.X, axis = 0) - np.average(latent_ctrl.X, axis = 0)\n        deltas.append(delta)\n        latent_centroids.append(ctrl_centroid)\nlr = LinearRegression()\nreg = lr.fit(latent_centroids, deltas)\ndelta = reg.predict([np.average(latent_cd, axis = 0)])[0]\ndoses = adata.obs.dose.unique()\ndoses.sort()\ntreat_pred_dict = {d:delta*(np.log1p(d)/np.log1p(max(doses))) + latent_cd  for d in doses if d &gt; min(doses)}\npredicted_cells_dict = {d:model.module.generative(torch.Tensor(treat_pred_dict[d]))[\"px\"].cpu().detach().numpy() for d in doses if d &gt; min(doses)}\ndr_dict = {d:sc.AnnData(X=predicted_cells_dict[d], obs=ctrl_data.obs.copy(), var=ctrl_data.var.copy(),obsm=ctrl_data.obsm.copy(),) for d in doses if d &gt; min(doses)}\nfor key in dr_dict.keys():\n    dr_dict[key].obs[\"dose\"] = f'{key} scVIDR'\n\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == 0))]\neval_dict1 = {}\n\nfor d in doses[1:]:\n    stim_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == d))]\n    eval_dict1[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n    eval_dict1[d].obs[\"Dose\"] = [str(i) if type(i) == float else i for i in eval_dict1[d].obs['dose']]\n\ncell_adata = adata[(adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==drug)]\ncell_adata.obs[\"Dose\"] = [str(i) for i in cell_adata.obs[\"dose\"]]\n</code></pre> <pre><code>None\n\n\n\n---------------------------------------------------------------------------\n\nOSError                                   Traceback (most recent call last)\n\n/tmp/local/64407813/ipykernel_13651/2266383417.py in &lt;cell line: 13&gt;()\n     11 \n     12 #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n---&gt; 13 model = model.load(f\"../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\n     14 train_adata_drug = adata[adata.obs.product_name == drug]\n     15 model_name = \"scVIDR\"\n\n\n~/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py in load(cls, dir_path, adata, use_gpu)\n    329             model_state_dict,\n    330             new_adata,\n--&gt; 331         ) = _load_saved_files(dir_path, load_adata, map_location=device)\n    332         adata = new_adata if new_adata is not None else adata\n    333\n\n\n~/miniconda3/lib/python3.9/site-packages/scvi/model/base/_utils.py in _load_saved_files(dir_path, load_adata, map_location)\n     35         adata = None\n     36 \n---&gt; 37     var_names = np.genfromtxt(varnames_path, delimiter=\",\", dtype=str)\n     38 \n     39     with open(setup_dict_path, \"rb\") as handle:\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/npyio.py in genfromtxt(fname, dtype, comments, delimiter, skip_header, skip_footer, converters, missing_values, filling_values, usecols, names, excludelist, deletechars, replace_space, autostrip, case_sensitive, defaultfmt, unpack, usemask, loose, invalid_raise, max_rows, encoding, like)\n   1791             fname = os_fspath(fname)\n   1792         if isinstance(fname, str):\n-&gt; 1793             fid = np.lib._datasource.open(fname, 'rt', encoding=encoding)\n   1794             fid_ctx = contextlib.closing(fid)\n   1795         else:\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/_datasource.py in open(path, mode, destpath, encoding, newline)\n    191 \n    192     ds = DataSource(destpath)\n--&gt; 193     return ds.open(path, mode, encoding=encoding, newline=newline)\n    194 \n    195\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/_datasource.py in open(self, path, mode, encoding, newline)\n    531                                       encoding=encoding, newline=newline)\n    532         else:\n--&gt; 533             raise IOError(\"%s not found.\" % path)\n    534 \n    535\n\n\nOSError: ../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/var_names.csv not found.\n</code></pre> <pre><code>df_list = []\nregression = False\ncell = \"A549\"\ndrug = \"Belinostat (PXD101)\"\nmodel = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\nmodel = model.load(f\"../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\ntrain_adata_drug = adata[adata.obs.product_name == drug]\nmodel_name = \"VAEArith\"\n\nmax_dose = train_adata_drug.obs.dose.max()\nmin_dose = train_adata_drug.obs.dose.min()\ndoses = np.sort(train_adata_drug.obs.dose.unique())\n\nctrl_x = train_adata[train_adata.obs[\"product_name\"] == \"Vehicle\", :]\ntreat_x = train_adata[(train_adata.obs[\"product_name\"] == drug) &amp; (train_adata.obs[\"dose\"] == 10000)]\nctrl_x = random_sample(ctrl_x, \"cell_type\")\ntreat_x = random_sample(treat_x, \"cell_type\")\nnew_adata = ctrl_x.concatenate(treat_x)\nnew_adata = random_sample(new_adata, \"dose\", max_or_min = \"min\", replacement = False)\n\nif sparse.issparse(new_adata.X):\n        new_adata.X = new_adata.X.A\n\nctrl_data = new_adata[(new_adata.obs[\"cell_type\"] == \"A549\") &amp; (new_adata.obs[\"product_name\"] == \"Vehicle\")]\nlatent_cd = model.get_latent_representation(ctrl_data)\nctrl_x = new_adata[new_adata.obs[\"dose\"] == 0].copy()\ntreat_x = new_adata[new_adata.obs[\"dose\"] == 10000].copy()\n\n#Compress data to latent space and then calculate the delta\nlatent_ctrl = np.average(model.get_latent_representation(ctrl_x), axis = 0)\nlatent_treat = np.average(model.get_latent_representation(treat_x), axis = 0)\ndelta = latent_treat - latent_ctrl\ndoses = adata.obs.dose.unique()\ndoses.sort()\n</code></pre> <pre><code>None\n\n\n\n---------------------------------------------------------------------------\n\nOSError                                   Traceback (most recent call last)\n\n/tmp/local/64407813/ipykernel_13651/4273628666.py in &lt;cell line: 13&gt;()\n     11 \n     12 #     model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\")\n---&gt; 13 model = model.load(f\"../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/\", train_adata)\n     14 train_adata_drug = adata[adata.obs.product_name == drug]\n     15 model_name = \"VAEArith\"\n\n\n~/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py in load(cls, dir_path, adata, use_gpu)\n    329             model_state_dict,\n    330             new_adata,\n--&gt; 331         ) = _load_saved_files(dir_path, load_adata, map_location=device)\n    332         adata = new_adata if new_adata is not None else adata\n    333\n\n\n~/miniconda3/lib/python3.9/site-packages/scvi/model/base/_utils.py in _load_saved_files(dir_path, load_adata, map_location)\n     35         adata = None\n     36 \n---&gt; 37     var_names = np.genfromtxt(varnames_path, delimiter=\",\", dtype=str)\n     38 \n     39     with open(setup_dict_path, \"rb\") as handle:\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/npyio.py in genfromtxt(fname, dtype, comments, delimiter, skip_header, skip_footer, converters, missing_values, filling_values, usecols, names, excludelist, deletechars, replace_space, autostrip, case_sensitive, defaultfmt, unpack, usemask, loose, invalid_raise, max_rows, encoding, like)\n   1791             fname = os_fspath(fname)\n   1792         if isinstance(fname, str):\n-&gt; 1793             fid = np.lib._datasource.open(fname, 'rt', encoding=encoding)\n   1794             fid_ctx = contextlib.closing(fid)\n   1795         else:\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/_datasource.py in open(path, mode, destpath, encoding, newline)\n    191 \n    192     ds = DataSource(destpath)\n--&gt; 193     return ds.open(path, mode, encoding=encoding, newline=newline)\n    194 \n    195\n\n\n~/miniconda3/lib/python3.9/site-packages/numpy/lib/_datasource.py in open(self, path, mode, encoding, newline)\n    531                                       encoding=encoding, newline=newline)\n    532         else:\n--&gt; 533             raise IOError(\"%s not found.\" % path)\n    534 \n    535\n\n\nOSError: ../data/models/Continuous_VAE_sciplex3_80perDrug_24hours_DelA549.pt/var_names.csv not found.\n</code></pre> <pre><code>treat_pred_dict = {d:delta*(np.log1p(d)/np.log1p(max(doses))) + latent_cd  for d in doses if d &gt; min(doses)}\npredicted_cells_dict = {d:model.module.generative(torch.Tensor(treat_pred_dict[d]))[\"px\"].cpu().detach().numpy() for d in doses if d &gt; min(doses)}\ndr_dict = {d:sc.AnnData(X=predicted_cells_dict[d], obs=ctrl_data.obs.copy(), var=ctrl_data.var.copy(),obsm=ctrl_data.obsm.copy(),) for d in doses if d &gt; min(doses)}\n\nfor key in dr_dict.keys():\n    dr_dict[key].obs[\"dose\"] = f'{key} VAEArith'\n\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == 0))]\neval_dict2 = {}\n\nfor d in doses[1:]:\n    stim_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs['dose'] == d))]\n    eval_dict2[d] = ctrl_adata.concatenate(stim_adata, dr_dict[d])\n    eval_dict2[d].obs[\"Dose\"] = [str(i) if type(i) == float else i for i in eval_dict2[d].obs['dose']]\n\ncell_adata = adata[(adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==drug)]\ncell_adata.obs[\"Dose\"] = [str(i) for i in cell_adata.obs[\"dose\"]]\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nTrying to set attribute `.obs` of view, copying.\n</code></pre> <pre><code>eval_dict = {d:eval_dict1[d].concatenate(eval_dict2[d][[\"VAEArith\" in i for i in eval_dict2[d].obs[\"Dose\"]]]) for d in doses[1:]}\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n</code></pre> <pre><code>eval_adata = eval_dict[10].concatenate([eval_dict[d] for d in doses[2:]])\n</code></pre> <pre><code>Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n</code></pre> <pre><code>bool_array = ((adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==drug)) | ((adata.obs[\"cell_type\"] ==cell) &amp; (adata.obs[\"product_name\"] ==\"Vehicle\"))\ncell_adata = adata[bool_array]\ncell_adata = cell_adata[(cell_adata.obs.dose == 0) |  (cell_adata.obs.dose == 10000)]\ncell_adata.obs[\"Dose\"] = [str(i) for i in cell_adata.obs[\"dose\"]]\n</code></pre> <pre><code>Trying to set attribute `.obs` of view, copying.\n</code></pre> <pre><code>response = []\nfor i in eval_adata.obs.Dose:\n    if \"scVIDR\" in i:\n        response.append(\"scVIDR\")\n    elif \"VAEArith\" in i:\n        response.append(\"VAEArith\")\n    else:\n        response.append(\"Real Expression\")\neval_adata.obs[\"Response\"] = response\n</code></pre> <pre><code>gene = \"MALAT1\"\ndf = eval_adata.obs[[\"Dose\", \"Response\"]]\neval_adata.var.index = eval_adata.var[\"gene_short_name\"]\ndf[gene] = eval_adata[:, gene].X.A.squeeze()\ndf[\"Dose\"] = [float(i.split(\" \")[0]) if type(i) == str else i for i in df[\"Dose\"]]\ndf[\"Log Dose\"] = [np.log1p(i) for i in df[\"Dose\"]]\n</code></pre> <pre><code>ax = sns.lineplot(x = \"Log Dose\", y = gene, hue = \"Response\", data = df, err_style=\"bars\")\nplt.setp(ax.get_legend().get_texts(), fontsize='10') # for legend text\nplt.setp(ax.get_legend().get_title(), fontsize='11') # for legend title\nplt.savefig(\"../Figures/SF4C.svg\")\nplt.show()\n</code></pre> <pre><code>#For calculating statistical distance\nimport geomloss\nimport pykeops\nimport pykeops\npykeops.clean_pykeops()          # just in case old build files are still present\npykeops.test_numpy_bindings()    # perform the compilation\n</code></pre> <pre><code>[KeOps] /mnt/home/kanaomar/.cache/keops2.0/build_CUDA_VISIBLE_DEVICES_0_1_2_3 has been cleaned.\n[KeOps] Compiling cuda jit compiler engine ... OK\n[pyKeOps] Compiling nvrtc binder for python ... OK\n[KeOps] Generating code for formula Sum_Reduction((Var(0,3,0)-Var(1,3,1))|(Var(0,3,0)-Var(1,3,1)),1) ... OK\npyKeOps with numpy bindings is working!\n</code></pre> <pre><code>df_dict = {\"Model\":[], \"Log Dose\":[], \"Sinkhorn Distance\":[]}\nmmd = geomloss.SamplesLoss(\"sinkhorn\")\nlog_dose = df[\"Log Dose\"].unique()\nfor dose in log_dose[1:]:\n    df_dose = df[df[\"Log Dose\"] == dose]\n    real_ahrr = df_dose[df_dose.Response == \"Real Expression\"][gene].values\n    scVIDR_ahrr = df_dose[df_dose.Response == \"scVIDR\"][gene].values\n    VAEArith_ahrr = df_dose[df_dose.Response == \"VAEArith\"][gene].values\n    real_tensor = torch.Tensor([real_ahrr]).T\n    scVIDR_tensor = torch.Tensor([scVIDR_ahrr]).T\n    VAEArith_tensor = torch.Tensor([VAEArith_ahrr]).T\n    stat_dist = mmd(real_tensor, scVIDR_tensor).numpy().tolist()\n    df_dict[\"Log Dose\"].append(f'{dose:.{3}f}')\n    df_dict[\"Model\"].append(\"scVIDR\")\n    df_dict[\"Sinkhorn Distance\"].append(stat_dist)\n    print(f\"scVIDR {dose}: {stat_dist}\")\n\n    stat_dist = mmd(real_tensor, VAEArith_tensor).numpy().tolist()\n    df_dict[\"Log Dose\"].append(f'{dose:.{3}f}')\n    df_dict[\"Model\"].append(\"VAEArith\")\n    df_dict[\"Sinkhorn Distance\"].append(stat_dist)\n    print(f\"VAEArith {dose}: {stat_dist}\")\n</code></pre> <pre><code>scVIDR 2.3978952727983707: 0.010838132351636887\nVAEArith 2.3978952727983707: 0.017037928104400635\nscVIDR 4.61512051684126: 0.01228361390531063\nVAEArith 4.61512051684126: 0.043471559882164\nscVIDR 6.90875477931522: 0.01594771258533001\nVAEArith 6.90875477931522: 0.09712056070566177\nscVIDR 9.210440366976517: 0.019401179626584053\nVAEArith 9.210440366976517: 0.16627751290798187\n</code></pre> <pre><code>from matplotlib import cm\n</code></pre> <pre><code>df_dists = pd.DataFrame(df_dict)\nsns.barplot(x = \"Log Dose\", y = \"Sinkhorn Distance\", hue = \"Model\", data = df_dists, palette=cm.tab10.colors[1:])\nplt.xticks(rotation = 45)\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/","title":"SupplementalFigure5","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nimport gseapy as gp\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\n#For calculating statistical distance\nimport geomloss\nimport pykeops\nimport pykeops\npykeops.clean_pykeops()          # just in case old build files are still present\npykeops.test_numpy_bindings()    # perform the compilation\n\nimport scvi\nsc.set_figure_params(dpi = 150)\nsc.settings.figdir = \"../Figure\"\nsns.set_style(\"dark\")\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/numba/np/ufunc/parallel.py:365: NumbaWarning: \u001b[1mThe TBB threading layer requires TBB version 2019.5 or later i.e., TBB_INTERFACE_VERSION &gt;= 11005. Found TBB_INTERFACE_VERSION = 6103. The TBB threading layer is disabled.\u001b[0m\n  warnings.warn(problem)\nOMP: Info #273: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n[KeOps] /mnt/home/kanaomar/.cache/keops2.0/build_CUDA_VISIBLE_DEVICES_0_1_2_3 has been cleaned.\n[KeOps] Compiling cuda jit compiler engine ... OK\n[pyKeOps] Compiling nvrtc binder for python ... OK\n[KeOps] Generating code for formula Sum_Reduction((Var(0,3,0)-Var(1,3,1))|(Var(0,3,0)-Var(1,3,1)),1) ... OK\npyKeOps with numpy bindings is working!\n</code></pre> <pre><code>adata = sc.read_h5ad(\"../data/nault2021_singleDose.h5ad\")\n</code></pre> <pre><code>#Prepare Data Set\ncell_types_of_int = [\"Hepatocytes - central\", \"Hepatocytes - portal\", \"Cholangiocytes\", \"Stellate Cells\", \"Portal Fibroblasts\", \"Endothelial Cells\"]\nadata = adata[adata.obs['celltype'].isin(cell_types_of_int)]\n\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nsc.pp.highly_variable_genes(adata, n_top_genes=5000)\nadata.obs[\"dose\"] = [str(d) for d in adata.obs.Dose]\nadata = adata[:,adata.var.highly_variable]\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scanpy/preprocessing/_normalization.py:170: UserWarning: Received a view of an AnnData. Making a copy.\n  view_to_actual(adata)\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/#supplementaryfigure-5e","title":"SupplementaryFigure 5E","text":"<pre><code>for cell in [\"Cholangiocytes\", \"Portal Fibroblasts\"]:\n    print(cell)\n    #Training model\n    train_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\n    train_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(train_adata.obs[\"Dose\"], train_adata.obs[\"celltype\"])]\n    model = VIDR(train_adata, linear_decoder = False)\n#     model.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n\n#     model.save(f\"../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\", overwrite = True)\n    vae = model.load(f\"../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n#Prediction of Each Celltype\n    pred, delta, reg = model.predict(\n    ctrl_key=\"0\",\n    treat_key=\"30\",\n    cell_type_to_predict=cell,\n    regression = True)\n    pred.obs[\"dose\"] = 'pred'\n    ctrl_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\n    treat_adata = adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\n    eval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\n    treatments = []\n    for i in eval_adata2.obs[\"dose\"]:\n        if i == \"0\":\n            treatments.append(\"Control\")\n        elif i == \"30\":\n            treatments.append(\"TCDD\")\n        else:\n            treatments.append(\"scVIDR\")\n    eval_adata2.obs[\"Treatment\"] = treatments\n    CD4T = adata[adata.obs[\"celltype\"] ==cell]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"dose\", method=\"wilcoxon\")\n    diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"30\"]\n    r2_value = model.reg_mean_plot(\n    eval_adata2,\n    axis_keys={\"x\": \"pred\", \"y\": \"30\"},\n    gene_list=diff_genes[:10],\n    top_100_genes = diff_genes[:100],\n    labels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\n    path_to_save=f\"../figures/Figure5E_{cell}.svg\",\n    show=True,\n    legend=False, title = f\"scVIDR {cell}\")\n</code></pre> <pre><code>Cholangiocytes\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18265\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                          \nNone\n\n\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nEpoch 35/100:  35%|\u2588\u2588\u2588\u258c      | 35/100 [02:16&lt;04:12,  3.89s/it, loss=109, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18265\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2355\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m28520\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1228: ImplicitModificationWarning: Initializing view as actual.\n  warnings.warn(\nTrying to set attribute `.obs` of view, copying.\n... storing 'dose' as categorical\n</code></pre> <pre><code>Portal Fibroblasts\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18789\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nNone\nEpoch 43/100:  43%|\u2588\u2588\u2588\u2588\u258e     | 43/100 [03:15&lt;04:18,  4.54s/it, loss=105, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18789\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m2419\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m28520\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\nObservation names are not unique. To make them unique, call `.obs_names_make_unique`.\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1220: FutureWarning: The `inplace` parameter in pandas.Categorical.reorder_categories is deprecated and will be removed in a future version. Reordering categories will always return a new Categorical object.\n  c.reorder_categories(natsorted(c.categories), inplace=True)\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/anndata/_core/anndata.py:1228: ImplicitModificationWarning: Initializing view as actual.\n  warnings.warn(\nTrying to set attribute `.obs` of view, copying.\n... storing 'dose' as categorical\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/#supplementary-figure-5c","title":"Supplementary Figure 5C","text":"<pre><code>dists = []\nctrl_size = []\ntreat_size = []\nmmd = geomloss.SamplesLoss(\"sinkhorn\")\nfor cell in cell_types_of_int:\n    print(cell)\n    #Training model\n    train_adata, test_adata = prepare_data(adata, \"celltype\", \"dose\", cell, \"30\", normalized = True)\n    train_adata.obs[\"cell_dose\"] = [f\"{j}_{str(i)}\" for (i,j) in zip(train_adata.obs[\"Dose\"], train_adata.obs[\"celltype\"])]\n    model = VIDR(train_adata, linear_decoder = False)\n    model.train(\n    max_epochs=100,\n    batch_size=128,\n    early_stopping=True,\n    early_stopping_patience=25)\n\n    model.save(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt\", overwrite=True)\n    vae = model.load(f\"../../data/VAE_Binary_Prediction_Dioxin_5000g_{cell}.pt/\", train_adata)\n\n    #Preparing latent space\n    latent_X = vae.get_latent_representation(adata)\n    latent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\n    cell_dose = [f\"{j}_{str(i)}\" for (i,j) in zip(adata.obs[\"Dose\"], adata.obs[\"celltype\"])]\n    training = [\"Train\" if i != cell+\"_30\" else \"Test\" for i in cell_dose]\n    latent_adata.obs[\"Cell_Dose\"] = cell_dose\n    latent_adata.obs[\"Training Split\"] = training\n\n    #Calculate the latent space distance between the cells\n    cell_model = [cell]*len(cell_types_of_int)\n    x = latent_adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"0\"))]\n    y = latent_adata[((adata.obs['celltype'] == cell) &amp; (adata.obs[\"dose\"] == \"30\"))]\n    x_tensor = torch.Tensor(x.X)\n    y_tensor = torch.Tensor(y.X)\n    stat_dist = mmd(x_tensor, y_tensor)\n    dists.append(stat_dist.detach().numpy().tolist())\n    ctrl_size.append(x.X.shape[0])\n    treat_size.append(y.X.shape[0])\n    print(f\"{cell}: {stat_dist}\")\n\nstat_df = pd.DataFrame({\"Cell\":cell_types_of_int, \"Maximum Mean Discrepancy\":dists, \"CTRL Size\":ctrl_size, \"TREAT Size\":treat_size})\n</code></pre> <pre><code>Hepatocytes - central\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17540\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nNone\nEpoch 42/100:  42%|\u2588\u2588\u2588\u2588\u258f     | 42/100 [03:22&lt;04:40,  4.83s/it, loss=111, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17540\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nHepatocytes - central: 272.31787109375\nHepatocytes - portal\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17791\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                          \nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nEpoch 39/100:  39%|\u2588\u2588\u2588\u2589      | 39/100 [03:03&lt;04:46,  4.69s/it, loss=111, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m17791\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nHepatocytes - portal: 338.39874267578125\nCholangiocytes\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18265\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nNone\nEpoch 31/100:  31%|\u2588\u2588\u2588       | 31/100 [01:59&lt;04:26,  3.87s/it, loss=108, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18265\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nCholangiocytes: 143.7571563720703\nStellate Cells\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18474\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nNone\nEpoch 33/100:  33%|\u2588\u2588\u2588\u258e      | 33/100 [01:53&lt;03:50,  3.44s/it, loss=109, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18474\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nStellate Cells: 181.10621643066406\nPortal Fibroblasts\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18789\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nNone\nEpoch 47/100:  47%|\u2588\u2588\u2588\u2588\u258b     | 47/100 [02:37&lt;02:57,  3.35s/it, loss=108, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18789\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nPortal Fibroblasts: 243.34303283691406\nEndothelial Cells\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"dose\"\u001b[0m\u001b[1m]\u001b[0m                                                \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"celltype\"\u001b[0m\u001b[1m]\u001b[0m                                             \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16013\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                          \nNone\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nEpoch 27/100:  27%|\u2588\u2588\u258b       | 27/100 [00:59&lt;02:39,  2.19s/it, loss=93.5, v_num=1]\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m16013\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.                                                              \nNone\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup               \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                             \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                              \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m     \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m18865\u001b[0m cells, \u001b[1;36m5000\u001b[0m vars, \u001b[1;36m2\u001b[0m batches,\n         \u001b[1;36m6\u001b[0m labels, and \u001b[1;36m0\u001b[0m proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra\n         continuous covariates.\n\n\n/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/scvi/model/base/_base_model.py:147: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nEndothelial Cells: 304.38067626953125\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/#supplemental-figure-5a","title":"Supplemental Figure 5A","text":"<pre><code>sns.barplot(\"Cell\", \"Maximum Mean Discrepancy\", data=stat_df, estimator=np.mean, ci=95, capsize=.2, order = sorted(cell_types_of_int))\nplt.xticks(rotation = 90)\nplt.ylabel(\"Sinkhorn Distance\")\nplt.show()\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/seaborn/_decorators.py:36: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation.\n  warnings.warn(\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/#supplementary-figure-5b","title":"Supplementary Figure 5B","text":"<pre><code>sns.barplot(\"Cell\", \"CTRL Size\", data=stat_df, estimator=np.mean, ci=95, capsize=.2, order = sorted(cell_types_of_int))\nplt.xticks(rotation = 90)\nplt.ylabel(\"Control Population Size\")\nplt.show()\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/seaborn/_decorators.py:36: FutureWarning: Pass the following variables as keyword args: x, y. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation.\n  warnings.warn(\n</code></pre>"},{"location":"tutorials/SupplementalFigure5/#supplementary-figure-5c_1","title":"Supplementary Figure 5C","text":"<p>See Figure2 notebook for generation of dataframe</p> <pre><code>r2_values_allCells_df = pd.read_csv(\"../data/SingleDose_Model_Results.csv\")\n</code></pre> <pre><code>df = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"DEGs\"]\n</code></pre> <pre><code>order = ['scVIDR', 'VAEArith']\nhue_order = [\"All HVGs\", \"DEGs\"]\nax = sns.barplot(x = \"Cell\", y = \"R^2\",  data = r2_values_allCells_df, hue = \"Model\", hue_order=order)\nplt.ylabel(\"$R^2$ Top 100 DEGs\")\nplt.xticks(rotation = 90)\nplt.show()\n</code></pre> <pre><code>(array([0, 1, 2, 3, 4, 5]),\n [Text(0, 0, 'Cholangiocytes'),\n  Text(1, 0, 'Endothelial Cells'),\n  Text(2, 0, 'Hepatocytes - central'),\n  Text(3, 0, 'Hepatocytes - portal'),\n  Text(4, 0, 'Portal Fibroblasts'),\n  Text(5, 0, 'Stellate Cells')])\n</code></pre> <p></p> <p>See Figure3 notebook for generation of dataframe</p> <pre><code>r2_values_allCells_df = pd.read_csv(\"../data/Continuous_Comparison_r2Values.csv\")\n</code></pre> <pre><code>df = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"DEGs\"]\n</code></pre> <pre><code>doses = [0.0,0.01, 0.03, 0.1, 0.3, 1.0, 3.0, 10.0, 30.0]\n</code></pre> <pre><code>order = [i for i in doses][1:]\nax = sns.barplot(x = \"Cell\", y = \"R^2\",  data = df, hue = \"Dose\", hue_order = order)\nplt.xticks(rotation = 90)\nplt.ylabel(\"scVIDR $R^2$ Top 100 DEGs\")\nplt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)\nplt.show()\n</code></pre> <p></p> <pre><code>order = doses[1:]\nhue_order = cell_types_of_int\nax = sns.barplot(x = \"Cell\", y = \"R^2\",  data = df[df[\"Model\"] == \"VAEArith\"], hue = \"Dose\", hue_order = order)\nplt.xticks(rotation = 90)\nplt.ylabel(\"VAEArith $R^2$ Top 100 DEGs\")\nplt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0)\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure6/","title":"SupplementalFigure6","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport scgen as scg\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nsc.set_figure_params(dpi = 150, frameon = True)\nsns.set_style(\"dark\")\nsc.settings.figdir = \"../figures\"\n</code></pre> <pre><code>/mnt/home/kanaomar/miniconda3/lib/python3.9/site-packages/numba/np/ufunc/parallel.py:365: NumbaWarning: \u001b[1mThe TBB threading layer requires TBB version 2019.5 or later i.e., TBB_INTERFACE_VERSION &gt;= 11005. Found TBB_INTERFACE_VERSION = 6103. The TBB threading layer is disabled.\u001b[0m\n  warnings.warn(problem)\nOMP: Info #273: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</code></pre> <pre><code>adata = sc.read_h5ad(\"../data/srivatsan2020.h5ad\")\n</code></pre> <p>To see how the dataframes are generated, see the supplemental figure 4 notebook.</p> <pre><code>test_drugs = np.loadtxt(\"../data/srivatsan2020_testDrugList.txt\", dtype = str, delimiter=\"\\t\")\n</code></pre> <pre><code>df_list = []\ndoses = [0.0, 10.0, 100.0, 1000.0, 10000.0]\nfor idx, drug in enumerate(test_drugs):\n    for d in doses[1:]:\n        df = pd.read_csv(f\"../data/Sciplex3_VAEArith_{d}_{drug}.csv\")\n        df[\"drug\"] = drug\n        df_list.append(df)\nfor idx, drug in enumerate(test_drugs):\n    for d in doses[1:]:\n        df = pd.read_csv(f\"../data/Sciplex3_scVIDR_{d}_{drug}.csv\")\n        df[\"drug\"] = drug\n        df_list.append(df)\n</code></pre> <pre><code>df_full = pd.concat(df_list)\n</code></pre> <pre><code>df_full[\"Dose\"] = df_full[\"Dose\"].astype(str)\n</code></pre> <pre><code>pathway_dict = {drug:pathway for drug, pathway in zip(adata.obs[\"product_name\"], adata.obs[\"pathway\"])}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure7/","title":"SupplementalFigure7","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nsc.set_figure_params(dpi = 150, frameon = True)\nsns.set_style(\"dark\")\nsc.settings.figdir = \"../figures\"\n</code></pre> <pre><code>kang_adata = sc.read_h5ad(\"../data/kang2018.h5ad\")\n</code></pre> <pre><code>kang_adata.obs[\"study\"] = \"Kang et al\"\n</code></pre> <pre><code>zheng_adata = sc.read_h5ad(\"../data/zheng2017.h5ad\")\n</code></pre> <pre><code>zheng_adata.obs[\"cell_type\"].replace(\"CD4 T cells\", \"CD4T\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"B cells\", \"B\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"CD14+ Monocytes\", \"CD14+Mono\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"NK cells\", \"NK\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"CD8 T cells\", \"CD8T\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"Dendritic cells\", \"Dendritic\", inplace=True)\nzheng_adata.obs[\"cell_type\"].replace(\"FCGR3A+ Monocytes\", \"FCGR3A+Mono\", inplace=True)\n</code></pre> <pre><code>adata = kang_adata.concatenate(zheng_adata)\n</code></pre> <pre><code>adata.obs[\"study\"].unique()\n</code></pre> <pre><code>array(['Kang et al', 'Zheng et al'], dtype=object)\n</code></pre> <pre><code>adata.obs[\"Study\"] = [\"Study A\" if i == \"Kang et al\" else \"Study B\"]\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nNameError                                 Traceback (most recent call last)\n\nCell In[9], line 1\n----&gt; 1 adata.obs[\"Study\"] = [\"Study A\" if i == \"Kang et al\" else \"Study B\"]\n\n\nNameError: name 'i' is not defined\n</code></pre> <pre><code>study_labels = adata.obs[\"study\"].values\ncell_labels = adata.obs[\"cell_type\"].values\nadata.obs[\"study_cell\"] = [f\"{study}-{cell}\" for study, cell in zip(study_labels, cell_labels)]\n</code></pre> <pre><code>adata.obs[\"study_cell\"]\n</code></pre> <pre><code>index\nAAACATACCAAGCT-1-stimulated-0            Kang et al-NK\nAAACATACCCCTAC-1-stimulated-0     Kang et al-Dendritic\nAAACATACCCGTAA-1-stimulated-0          Kang et al-CD4T\nAAACATACCCTCGT-1-stimulated-0             Kang et al-B\nAAACATACGAGGTG-1-stimulated-0          Kang et al-CD4T\n                                         ...          \nTTTCGAACTCTCAT-1-1-1             Zheng et al-CD14+Mono\nTTTCTACTGAGGCA-1-1-1                     Zheng et al-B\nTTTCTACTTCCTCG-1-1-1                     Zheng et al-B\nTTTGCATGAGAGGC-1-1-1                     Zheng et al-B\nTTTGCATGCCTCAC-1-1-1                  Zheng et al-CD4T\nName: study_cell, Length: 19516, dtype: object\n</code></pre> <pre><code>#Training model\ncell = \"Zheng et al-B\"\ntrain_adata, test_adata = prepare_data(adata, \"study_cell\", \"condition\", cell, \"stimulated\", normalized = True)\nvae = VIDR(train_adata, linear_decoder = False)\n\n# vae.train(\n# max_epochs=100,\n# batch_size=128,\n# early_stopping=True,\n# early_stopping_patience=25)\n\n# vae.save(f\"../../data/VAE_OOD_Prediction_IFNB_7000g_{cell}.pt\", overwrite = True)\nvae = vae.load(f\"../../data/VAE_OOD_Prediction_IFNB_7000g_{cell}.pt/\", train_adata)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"study_cell\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m19516\u001b[0m cells, \u001b[1;36m5835\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m14\u001b[0m labels, and \u001b[1;36m0\u001b[0m     \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m19516\u001b[0m cells, \u001b[1;36m5835\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m14\u001b[0m labels, and \u001b[1;36m0\u001b[0m     \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\n</code></pre> <pre><code>#UMAP Projection of latent space\nlatent_X = vae.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup                                     \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m19516\u001b[0m cells, \u001b[1;36m5835\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m14\u001b[0m labels, and \u001b[1;36m0\u001b[0m     \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.\n</code></pre> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 100 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>from matplotlib import cm\n</code></pre> <pre><code>latent_adata.obs[\"Study\"] = [\"Study A\" if i == \"Kang et al\" else \"Study B\" for i in  adata.obs.study]\nlatent_adata.obs[\"Cell Type\"] = adata.obs[\"cell_type\"]\nlatent_adata.obs[\"Condition\"] = adata.obs[\"condition\"]\n</code></pre> <pre><code>for idx, label in enumerate(['Study', 'Cell Type', 'Condition']):\n    if label == \"Cell Type\":\n        palette = \"tab10\"\n    elif label == \"Condition\":\n        palette = cm.tab10.colors[:2]\n    else:\n        palette = \"coolwarm\"\n    print(palette)\n    ax = sc.pl.umap(\n        latent_adata,\n        color = label,\n        palette = palette\n    )\n</code></pre> <pre><code>coolwarm\n</code></pre> <pre><code>tab10\n</code></pre> <pre><code>((0.12156862745098039, 0.4666666666666667, 0.7058823529411765), (1.0, 0.4980392156862745, 0.054901960784313725))\n</code></pre> <pre><code>ctrl_key = \"control\"\ntreat_key = \"stimulated\"\nstudy_A_key = \"Kang et al\"\nstudy_B_key = \"Zheng et al\"\ncell_type_to_predict = \"B\"\n</code></pre> <pre><code>cell_type_key = \"cell_type\"\ntreatment_key = \"condition\"\nstudy_key = \"study\"\n</code></pre> <pre><code>studyA = vae.adata[vae.adata.obs[study_key] == study_A_key]\nstudyB = vae.adata[vae.adata.obs[study_key] == study_B_key]\n</code></pre> <pre><code>ctrl_x = studyA[studyA.obs[treatment_key] == ctrl_key]\ntreat_x = studyA[studyA.obs[treatment_key] == treat_key]\n</code></pre> <pre><code>ctrl_x = random_sample(ctrl_x, cell_type_key)\ntreat_x = random_sample(treat_x, cell_type_key)\n</code></pre> <pre><code>#Balancing across treatments \nnew_adata = ctrl_x.concatenate(treat_x)\nnew_adata = random_sample(new_adata, treatment_key, max_or_min = \"min\", replacement = False)\n</code></pre> <pre><code>#Densify Sparse Matrix\nif sparse.issparse(new_adata.X):\n        new_adata.X = new_adata.X.A\n</code></pre> <pre><code>if sparse.issparse(new_adata.X):\n            new_adata.X = new_adata.X.A\n</code></pre> <pre><code>latent_X =  vae.get_latent_representation(new_adata)\nlatent_adata = sc.AnnData(X=latent_X, obs = new_adata.obs.copy())\n#Get deltas and control centroids for each cell tpye in the training dataset\ndeltas = []\nlatent_centroids = []\ncell_types = np.unique(latent_adata.obs[cell_type_key])\nfor cell_i in cell_types:\n    if cell_i != cell_type_to_predict:\n        latent_ctrl = latent_adata[(latent_adata.obs[cell_type_key] == cell_i) &amp; (latent_adata.obs[treatment_key] == ctrl_key)]\n        latent_treat = latent_adata[(latent_adata.obs[cell_type_key] == cell_i) &amp; (latent_adata.obs[treatment_key] == treat_key)]\n        ctrl_centroid = np.average(latent_ctrl.X, axis = 0)\n        treat_centroid = np.average(latent_treat.X, axis = 0)\n        delta = treat_centroid - ctrl_centroid\n        deltas.append(delta)\n        latent_centroids.append(ctrl_centroid)\nlr = LinearRegression()\nreg = lr.fit(latent_centroids, deltas)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup                                     \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m34118\u001b[0m cells, \u001b[1;36m5835\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m14\u001b[0m labels, and \u001b[1;36m0\u001b[0m     \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.\n</code></pre> <pre><code>scVIDR_pred_l = []\nfor cell_i in cell_types:\n    print(cell_i)\n    studyB_i = studyB[studyB.obs[cell_type_key] == cell_i]\n    print(studyB_i)\n    latent_cd_i = vae.get_latent_representation(studyB_i)\n    scVIDR_delta_i = reg.predict([np.average(latent_cd_i, axis = 0)])[0]\n    print(scVIDR_delta_i)\n    treat_pred = scVIDR_delta_i + latent_cd_i\n    predicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\n    scvidr_pred_i = sc.AnnData(X=predicted_cells , obs=studyB_i.obs, var=studyB_i.var.copy())\n    scVIDR_pred_l.append(scvidr_pred_i)\n</code></pre> <pre><code>B\nView of AnnData object with n_obs \u00d7 n_vars = 342 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-1.1875428  -0.9810512  -0.9034028   1.0080755  -2.822612    1.9888012\n  2.74437    -0.33823186 -3.4023392   0.8470795  -0.03016177  1.3572129\n -0.8457316  -3.4008465   1.213508    1.0370331  -1.1089827  -1.5722971\n  1.2053063   2.8660097   0.45004186  1.5204619  -1.0602865  -1.1114156\n  0.301614    0.70524514  0.9615224  -0.6817345   2.7672496  -2.3375173\n  0.18527424  2.4289594   0.24793583 -0.726011    0.42058218  0.5782151\n  1.1462336   1.1313728   1.1815714   1.133357    0.7124855  -2.1059296\n -0.75088096  0.42397344 -0.6244265  -1.408945   -0.9957286   1.0489578\n -2.4219623   1.1971315   0.8377676   1.597843    0.11171508  1.5990009\n  0.06661261  1.3307991  -2.3222947  -1.991075    2.9358435  -3.5562167\n -2.40971     1.4637101  -1.708941   -0.14157844  0.88943833  1.1244204\n -0.13255906  1.9271634   1.816632   -1.457781   -1.0465343  -0.5875258\n -0.644421   -0.37418714  0.23943686  1.9963083  -0.53932333  0.3764066\n  2.5318825   1.6942408  -0.01706064  1.1611979  -1.5354884   1.1831766\n -0.674902   -0.65908533 -0.5784869  -0.02456892  0.267956    1.461221\n  1.9106774   0.6410176   0.8539256  -0.5936737  -1.4217625   0.7345071\n -0.89355814 -2.7557802  -2.0694323  -0.89143234]\nCD14+Mono\nView of AnnData object with n_obs \u00d7 n_vars = 480 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-1.2041175e+00 -3.0514174e+00 -1.4446522e+00 -3.9389330e-01\n -9.4836414e-01  1.1055237e+00 -1.1520295e+00  4.0116787e-02\n -2.9014158e+00  5.8153534e-01 -5.0091863e-01 -1.9939716e-01\n -1.9363744e+00 -1.1380692e+00 -2.4287519e+00  2.5989165e+00\n -1.0561948e+00 -5.0044703e-01  3.3151426e+00  5.8134747e-01\n  1.0803858e+00  1.4080013e+00  4.9392149e-01  4.4365448e-01\n  1.0247047e+00  3.6492100e+00 -7.4721205e-01  1.4867353e+00\n -7.8549540e-01 -1.0052474e+00  1.4375372e+00  2.9561751e+00\n  1.6383094e-01 -2.1204300e+00  1.3107458e-01 -1.5256524e-01\n  1.4254522e+00 -1.8599950e+00  9.3772823e-01  1.9860005e+00\n  2.8303201e+00 -2.0080631e+00  5.4827201e-01 -3.8985783e-01\n -5.6079036e-01 -1.3712947e+00 -8.7150276e-02  2.2762004e-01\n -6.9477499e-02  3.5468185e+00  1.2131789e+00 -4.7857058e-01\n -1.3864436e+00  7.2599429e-01  1.5970643e-01 -1.3825994e+00\n -1.1580800e+00 -2.7688403e+00  2.7526360e+00 -5.7704103e-01\n -1.5578332e+00 -1.2139424e+00 -5.8136767e-01 -4.7422573e-04\n  1.2485619e+00  3.2467145e-01  4.6399817e-01  1.4725683e+00\n -2.6210469e-01  2.1186843e+00 -5.7030129e-01 -2.2062898e+00\n  8.4928060e-01 -1.2640805e+00 -1.5724812e+00  1.9698732e+00\n -2.0398369e+00  2.1013670e+00  2.2438273e+00  1.0189614e+00\n  2.9227238e+00  3.9698398e-01 -2.4267313e+00  1.5167868e+00\n  1.4300747e+00  4.4676578e-01  3.8316676e-01 -3.0995114e+00\n -6.3606822e-01 -2.1850471e+00  1.4864764e+00  4.9849486e-01\n -3.0381327e+00  1.5367441e+00  1.6652093e+00 -5.1939034e-01\n -9.0353703e-01  1.4298756e+00 -1.7350338e+00 -5.7713038e-01]\nCD4T\nView of AnnData object with n_obs \u00d7 n_vars = 1144 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-4.0346456e-01 -9.3464512e-01 -9.3142927e-01  7.5309861e-01\n -1.0687020e+00  4.9421346e-01 -6.8597950e-02  4.2571837e-01\n -1.5406834e+00  6.5075827e-01 -8.3913374e-01 -2.1670046e-01\n -9.8517376e-01 -7.6149088e-01 -5.4952830e-01  6.6485751e-01\n  2.4639300e-01 -1.2964544e-01  1.5703317e+00  2.1841638e+00\n -2.7193972e-01  5.3137922e-01 -4.7335654e-02  3.5398790e-01\n  9.6218961e-01  9.0793848e-01  2.7514943e-01  5.1523304e-01\n -2.0507485e-01 -1.6308824e+00  1.8068838e-01  1.7672596e+00\n -9.4510674e-01 -5.0249010e-01  4.5657256e-01  5.8202557e-03\n  8.1230330e-01  3.8035274e-02  2.0520866e-02  1.3656390e+00\n  1.1805496e+00 -1.0071615e+00 -2.1695009e-01 -1.3029316e-01\n -7.1284074e-01 -8.2660073e-01 -3.8867858e-01 -3.1534916e-01\n -4.1927391e-01  1.0372124e+00  6.4745456e-02  1.1148586e+00\n -9.9402785e-01  7.0683056e-01  9.0607613e-02 -1.5823251e-01\n -1.3254135e+00 -1.9426062e+00  1.1062553e+00 -6.5879762e-01\n -9.5066929e-01 -3.5818598e-01  1.3940121e-01 -1.7687833e-01\n -2.1507907e-01 -5.4019129e-01 -1.9486116e-01  7.7302432e-01\n  1.0828315e+00  1.1681371e+00 -3.5457110e-01 -1.2553408e+00\n  4.7262192e-02  1.2390554e-01 -5.2509093e-01  1.4099476e+00\n -7.1995258e-01  7.2153068e-01  1.5258768e+00  4.9319419e-01\n  5.8139831e-01  9.2313665e-01 -1.5533044e+00  5.3876251e-01\n -1.8823892e-01 -4.5046117e-04 -1.5667352e-01 -9.7112322e-01\n -3.1071189e-01 -2.6354751e-01 -1.1173576e-01 -8.5376024e-02\n -4.2303097e-01  3.0810964e-01  4.6175849e-01  6.9546425e-01\n  6.8107158e-02 -2.4237126e-01 -1.1833667e+00 -2.1982557e-01]\nCD8T\nView of AnnData object with n_obs \u00d7 n_vars = 316 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-0.4763036  -0.9434493  -0.9018226   0.71451676 -0.9852177   0.7276978\n  0.11997303  0.39121333 -2.0681705   0.49079147 -0.72997963  0.32883716\n -1.2407281  -0.85436046 -0.8567368   0.6123163  -0.14408506 -0.21701543\n  1.4058121   2.812931   -0.07602113  0.5578317  -0.06951838  0.10028784\n  1.1225588   1.2172986   0.06622057  0.83275634 -0.16658604 -1.5050895\n  0.1736545   1.6925261  -0.8229789  -0.77401644  0.84668016  0.19652402\n  0.9575012   0.01720798  0.28759015  1.7937789   1.2836621  -1.3293725\n -0.17254272  0.14773858 -0.63540566 -1.1286029  -0.68636405 -0.5090391\n -0.37694892  1.4524939   0.19597237  0.9635577  -1.1321013   0.60936946\n  0.08456427 -0.01863912 -1.3895617  -1.9177102   1.2263685  -0.8036746\n -1.1291105  -0.49552774 -0.05968378 -0.34549737  0.2815045  -0.35861793\n  0.12148786  1.0551145   1.3905104   1.1909825  -0.17518854 -1.2002203\n  0.1672852  -0.03961378 -0.57904696  1.2648053  -0.687397    1.1146983\n  1.2798916   0.5999419   0.6324144   0.81343734 -1.7378427   0.8373176\n -0.26717347 -0.00672175  0.08310027 -0.9255922  -0.3148262  -0.34549776\n -0.27557033 -0.2588995  -0.39076138  0.2594267   0.01658481  0.8346523\n -0.0230926   0.05361491 -1.2147369  -0.51322824]\nDendritic\nView of AnnData object with n_obs \u00d7 n_vars = 37 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-1.7507269  -2.0251951  -1.0004256   0.6215048  -2.6961694   2.5163913\n  2.233182   -0.9243959  -4.2248135   0.7616194   0.1512892   1.628818\n -1.3772464  -3.6566553   0.21030664  2.334725   -2.0704243  -1.9551375\n  2.3029413   2.1578624   1.1967856   1.9416854  -0.75561595 -1.1722921\n  0.3131122   2.2668047   0.35558715 -0.15497762  2.7351866  -1.7738625\n  0.90962064  3.1797671   1.1386478  -2.0568929   0.19551957  0.52583283\n  1.8522154   0.1640752   1.8178735   1.6352586   1.741484   -2.7083254\n -0.22563541  0.04523547 -0.5229899  -1.5770161  -1.1166457   1.4350513\n -2.2068095   2.5788107   1.8145161   0.6875453  -0.1614443   1.7387826\n  0.18244092  0.7726072  -2.1279576  -2.3847575   3.9793904  -3.6577697\n -2.9463494   1.238225   -2.3815203  -0.20130536  1.7445174   1.7319673\n  0.5739794   2.409211    1.3074114  -0.8947525  -1.1232944  -1.1959589\n -0.1540758  -1.0092752  -0.35531533  2.278411   -1.395221    1.1637367\n  2.704504    2.231069    1.1392927   0.51090765 -1.9482629   2.1038737\n -0.02778673 -0.30882207 -0.11237854 -0.9714916   0.10061389  0.32716334\n  2.7403462   1.2686454  -0.42160583 -0.09711325 -0.7015782  -0.03489235\n -1.6018133  -1.9666953  -2.3183556  -1.1216886 ]\nFCGR3A+Mono\nView of AnnData object with n_obs \u00d7 n_vars = 150 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-1.2990448  -3.2985735  -1.8967322  -1.0603454  -1.8548586   0.919046\n -0.42216912  0.9996598  -3.6660671   0.5733769  -0.05653769 -0.3573666\n -2.2329946  -1.8545337  -2.1329014   1.9824198  -0.72509885 -0.584312\n  2.427219    0.10979915  1.239674    1.873035    0.15541264  0.08702094\n  0.9878419   3.3920429  -0.5559072   1.1467221  -0.5227778  -1.6195811\n  1.5061635   2.5773838  -0.18969792 -0.73823994  0.41252488 -0.21912786\n  0.5138883  -2.0311217   1.1472148   1.3368475   2.3773804  -2.1562476\n  0.4499328   0.75118893 -0.2315582  -1.9865365   0.32549194  0.41850275\n -0.82324904  3.620765    0.59461266 -0.45703644 -1.1183659   0.45934337\n -0.03634213 -1.0696808  -1.6102908  -2.8783932   2.897017   -1.2137899\n -1.397567   -1.6374421  -0.5350784   0.512929    1.4987706   0.7507657\n -0.36957544  1.5618818  -0.6311993   1.0906979  -0.7206132  -1.6615955\n  0.6700928  -1.7220345  -1.2920642   2.0271926  -1.2523578   2.071068\n  3.096801    0.6336115   2.976953    1.3074654  -2.4959369   0.60248375\n  1.9606516   0.09070384 -0.18962146 -3.6437504  -0.48273307 -1.2269766\n  2.1190062  -0.06043645 -3.1508598   1.5103698   0.51485085 -0.2857298\n -1.1152836   1.0750661  -1.9292694  -0.95872146]\nNK\nView of AnnData object with n_obs \u00d7 n_vars = 154 \u00d7 5835\n    obs: 'condition', 'n_counts', 'n_genes', 'mt_frac', 'cell_type', 'study', 'percent_mito', 'batch', 'study_cell', '_scvi_batch', '_scvi_labels', '_scvi_local_l_mean', '_scvi_local_l_var'\n    var: 'gene_symbol-0', 'n_cells-0', 'gene_symbol-0-1', 'n_cells-0-1', 'n_cells-1-1', 'means-1', 'dispersions-1', 'dispersions_norm-1'\n    uns: '_scvi'\n    obsm: 'X_pca', 'X_umap', 'X_tsne'\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n[-0.4589798  -1.6075914  -1.2283676   0.2930317  -0.9509702   1.202795\n  0.27662468  0.4194106  -2.6055608   0.609059   -0.6414668   0.7281109\n -1.2623086  -1.2736268  -1.1609395   0.80982333 -0.7867402  -0.22160713\n  1.8021078   3.28442     0.5404752   0.9598893  -0.12162082  0.01413035\n  1.1271474   2.030995   -0.05450764  1.1945012  -0.32310873 -1.8226742\n  0.19562912  2.168983   -0.69943124 -1.1636674   1.0567582   0.5646944\n  0.85527784  0.01699507  0.5096535   2.2993882   1.4809022  -1.996809\n -0.5574652   0.37290424 -0.92159235 -1.6920662  -0.4876101  -0.53999776\n -0.47170305  2.3564193   0.16344939  0.84494627 -0.88787305  0.68775403\n -0.02750047 -0.2309578  -1.8213459  -2.204951    1.7956526  -0.99164116\n -1.4527931  -0.49802965 -0.17820588 -0.38584435  1.1178379  -0.23824754\n  0.09547782  1.524725    1.2483685   1.1273838  -0.36340195 -1.2559124\n  0.11341211 -0.7404123  -0.70785993  1.5410167  -1.1498749   1.5433258\n  1.6177396   0.77267087  1.340034    1.2077708  -2.2954693   1.0566381\n  0.15698612 -0.27929208  0.16676179 -1.1702328  -0.3264614  -0.72337824\n  0.31940228 -0.64585453 -0.8098497   0.7946612  -0.0787077   0.92965007\n  0.2002742   0.43564957 -1.7836245  -0.64337736]\n</code></pre> <pre><code>scVIDR_pred = scVIDR_pred_l[0].concatenate(scVIDR_pred_l[1:])\n</code></pre> <pre><code>scVIDR_pred.obs[\"condition\"] = \"stimulated - scVIDR Prediction\"\n</code></pre> <pre><code>eval_adata = train_adata.concatenate(scVIDR_pred)\n</code></pre> <pre><code>sc.pp.neighbors(eval_adata)\nsc.tl.umap(eval_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 5835 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>eval_adata.obs[\"Study\"] = [\"Study A\" if i == \"Kang et al\" else \"Study B\" for i in  eval_adata.obs.study]\neval_adata.obs[\"Cell Type\"] = eval_adata.obs[\"cell_type\"]\neval_adata.obs[\"Condition\"] = eval_adata.obs[\"condition\"]\n</code></pre> <pre><code>for idx, label in enumerate(['Study', 'Cell Type', 'Condition']):\n    if label == \"Cell Type\":\n        palette = \"tab10\"\n    elif label == \"Condition\":\n        palette = cm.tab10.colors[:3]\n    else:\n        palette = \"coolwarm\"\n    print(palette)\n    ax = sc.pl.umap(\n        eval_adata,\n        color = label,\n        palette = palette\n    )\n</code></pre> <pre><code>coolwarm\n</code></pre> <pre><code>tab10\n</code></pre> <pre><code>((0.12156862745098039, 0.4666666666666667, 0.7058823529411765), (1.0, 0.4980392156862745, 0.054901960784313725), (0.17254901960784313, 0.6274509803921569, 0.17254901960784313))\n</code></pre> <pre><code>sc.pl.umap(\n    eval_adata,\n    color = \"ISG15\"\n)\n</code></pre> <pre><code>for cell_i in cell_types:\n    print(cell_i)\n    studyB_i = studyB[(studyB.obs[cell_type_key] == cell_i)]\n    studyA_i = studyA[(studyA.obs[cell_type_key] == cell_i)]\n\n    studyA_ctrl_i = studyA_i[(studyA_i.obs[treatment_key] == ctrl_key)]\n    studyA_stim_i = studyA_i[(studyA_i.obs[treatment_key] == treat_key)]\n\n    latent_cd_i = vae.get_latent_representation(studyB_i)\n    scVIDR_delta_i = reg.predict([np.average(latent_cd_i, axis = 0)])[0]\n    treat_pred = scVIDR_delta_i + latent_cd_i\n    predicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\n    scvidr_pred_i = sc.AnnData(X=predicted_cells , obs=studyB_i.obs, var=studyB_i.var.copy())\n    scvidr_pred_i.obs[\"condition\"] = \"pred\"\n\n    sc.tl.rank_genes_groups(studyA_i, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes = studyA_i.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\n\n    eval_adata_A = studyA_i\n    eval_adata_B = studyA_stim_i.concatenate(studyB_i)\n    eval_adata_C = studyB_i.concatenate(scvidr_pred_i)\n\n    r2_value = vae.reg_mean_plot(\n        eval_adata_A,\n        axis_keys={\"x\": \"control\", \"y\": \"stimulated\"},\n        labels={\"x\": \"Study A Control\", \"y\": \"Study A Stimulated\"},\n        gene_list=diff_genes[:10],\n        path_to_save=\"../figures/Figure2C2.svg\",\n        show=True,\n        legend=False,)\n\n    r2_value = vae.reg_mean_plot(\n        eval_adata_B,\n        axis_keys={\"x\": \"control\", \"y\": \"stimulated\"},\n        labels={\"x\": \"Study B Control\", \"y\": \"Study A Stimulated\"},\n        gene_list=diff_genes[:10],\n        path_to_save=\"../figures/Figure2C2.svg\",\n        show=True,\n        legend=False,)\n\n    r2_value = vae.reg_mean_plot(\n       eval_adata_C,\n       axis_keys={\"x\": \"control\", \"y\": \"pred\"},\n        labels={\"x\": \"Study B Control\", \"y\": \"Study B Predicted Stimulated\"},\n        gene_list=diff_genes[:10],\n        path_to_save=\"../figures/Figure2C2.svg\",\n        show=True,\n        legend=False,)\n</code></pre> <pre><code>B\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>CD14+Mono\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>CD4T\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>CD8T\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>Dendritic\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>FCGR3A+Mono\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>NK\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>df_list = []\n\nfor cell_i in cell_types:\n    print(cell_i)\n    studyB_i = studyB[(studyB.obs[cell_type_key] == cell_i)]\n    studyA_i = studyA[(studyA.obs[cell_type_key] == cell_i)]\n\n    studyA_ctrl_i = studyA_i[(studyA_i.obs[treatment_key] == ctrl_key)]\n    studyA_stim_i = studyA_i[(studyA_i.obs[treatment_key] == treat_key)]\n\n    latent_cd_i = vae.get_latent_representation(studyB_i)\n    scVIDR_delta_i = reg.predict([np.average(latent_cd_i, axis = 0)])[0]\n    treat_pred = scVIDR_delta_i + latent_cd_i\n    predicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\n    scvidr_pred_i = sc.AnnData(X=predicted_cells , obs=studyB_i.obs, var=studyB_i.var.copy())\n    scvidr_pred_i.obs[\"condition\"] = \"pred\"\n\n    sc.tl.rank_genes_groups(studyA_i, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes = studyA_i.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\n\n    eval_adata_A = studyA_i\n    eval_adata_B = studyA_stim_i.concatenate(studyB_i)\n    eval_adata_C = studyB_i.concatenate(scvidr_pred_i)\n\n    r2_df1 = calculate_r2_singledose(\n        eval_adata_B, cell_i,\n        \"Study A Stim vs. Study B Ctrl\", \n        \"condition\", \n        {\"x\":\"control\", \"y\":\"stimulated\"},\n        random_sample_coef = 0.8,\n        n_iter = 100\n    )\n\n    df_list.append(r2_df1)\n\n    r2_df2 = calculate_r2_singledose(\n        eval_adata_C, cell_i,\n        \"Study B Pred vs. Study B Ctrl\", \n        \"condition\", \n        {\"x\":\"control\", \"y\":\"pred\"},\n        random_sample_coef = 0.8,\n        n_iter = 100\n    )\n\n    df_list.append(r2_df2)\n</code></pre> <pre><code>B\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nCD14+Mono\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nCD4T\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nCD8T\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nDendritic\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nFCGR3A+Mono\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \nNK\n\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.\n</code></pre> <pre><code>r2_values_allCells_df = pd.concat(df_list)\n</code></pre> <pre><code>r2_values_allCells_df[\"Study Comparison\"] = r2_values_allCells_df[\"Model\"]\n</code></pre> <pre><code>hue_order = [\"Study A Stim vs. Study B Ctrl\",\"Study B Pred vs. Study B Ctrl\"]\nax = sns.barplot(x = \"Cell\", y = \"R^2\",  data = r2_values_allCells_df, hue = \"Study Comparison\", hue_order = hue_order)\nax.legend(loc='center left', bbox_to_anchor=(1, 0.5))\nax.set_ylabel(r\"$R^2$\")\nplt.xticks(rotation = 90)\n</code></pre> <pre><code>(array([0, 1, 2, 3, 4, 5, 6]),\n [Text(0, 0, 'B'),\n  Text(1, 0, 'CD14+Mono'),\n  Text(2, 0, 'CD4T'),\n  Text(3, 0, 'CD8T'),\n  Text(4, 0, 'Dendritic'),\n  Text(5, 0, 'FCGR3A+Mono'),\n  Text(6, 0, 'NK')])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/","title":"SupplementalFigure8","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import hte vaedr functions we have created\nfrom vidr import VIDR\nfrom PCAEval import PCAEval\nfrom utils import *\n\n#Import important modules\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\nfrom sklearn.ensemble import RandomForestRegressor\n\n#For calculating statistical distance\nimport geomloss\nimport pykeops\nimport pykeops\npykeops.clean_pykeops()          # just in case old build files are still present\npykeops.test_numpy_bindings()    # perform the compilation\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nsc.set_figure_params(dpi = 150, frameon = True)\nsns.set_style(\"dark\")\nsc.settings.figdir = \"../figures\"\n</code></pre> <pre><code>[KeOps] /mnt/home/kanaomar/.cache/keops2.1.1/build_CUDA_VISIBLE_DEVICES_0_1_2_3 has been cleaned.\n[KeOps] Compiling cuda jit compiler engine ... OK\n[pyKeOps] Compiling nvrtc binder for python ... OK\n[KeOps] Generating code for formula Sum_Reduction((Var(0,3,0)-Var(1,3,1))|(Var(0,3,0)-Var(1,3,1)),1) ... OK\npyKeOps with numpy bindings is working!\n</code></pre> <pre><code>adata = sc.read_h5ad(\"../data/train_species.h5ad\")\n</code></pre> <pre><code>adata\n</code></pre> <pre><code>AnnData object with n_obs \u00d7 n_vars = 62114 \u00d7 6619\n    obs: 'condition', 'species', 'individual', 'batch', 'louvain', 'n_counts'\n    var: 'gene_ids-0-0-0-0', 'gene_ids-1-0-0-0', 'gene_ids-2-0-0-0', 'gene_ids-0-1-0-0', 'gene_ids-1-1-0-0', 'gene_ids-2-1-0-0', 'gene_ids-0-0-1-0', 'gene_ids-1-0-1-0', 'gene_ids-2-0-1-0', 'gene_ids-0-1-1-0', 'gene_ids-1-1-1-0', 'gene_ids-2-1-1-0', 'gene_ids-3-1-1-0', 'gene_ids-0-0-0-1', 'gene_ids-1-0-0-1', 'gene_ids-2-0-0-1', 'gene_ids-0-1-0-1', 'gene_ids-1-1-0-1', 'gene_ids-2-1-0-1', 'gene_ids-0-0-1-1', 'gene_ids-1-0-1-1', 'gene_ids-2-0-1-1', 'gene_ids-0-1-1-1', 'gene_ids-1-1-1-1', 'gene_ids-2-1-1-1'\n    uns: 'condition_colors', 'neighbors', 'species_colors'\n    obsm: 'X_pca', 'X_umap'\n    obsp: 'distances', 'connectivities'\n</code></pre> <pre><code>adata.obs.species\n</code></pre> <pre><code>index\nAAACCTGTCGGTCTAA-1-0-0-0-0    rabbit\nAAACCTGTCTGTCCGT-1-0-0-0-0    rabbit\nAAACGGGAGCCGATTT-1-0-0-0-0    rabbit\nAAACGGGAGGCGCTCT-1-0-0-0-0    rabbit\nAAACGGGCACAACGCC-1-0-0-0-0    rabbit\n                               ...  \nTTTGGTTGTGGGTATG-1-2-1-1-1     mouse\nTTTGTCAAGCCCTAAT-1-2-1-1-1     mouse\nTTTGTCAAGCTAAACA-1-2-1-1-1     mouse\nTTTGTCACAGTTTACG-1-2-1-1-1     mouse\nTTTGTCATCCGTTGTC-1-2-1-1-1     mouse\nName: species, Length: 62114, dtype: category\nCategories (4, object): ['mouse', 'pig', 'rabbit', 'rat']\n</code></pre> <pre><code># #Training model\n# for cell in [\"rat\", \"rabbit\", \"pig\"]:\n#     train_adata, test_adata = prepare_data(adata, \"species\", \"condition\", cell, \"LPS6\", normalized = True)\n#     vae = VIDR(train_adata, linear_decoder = False)\n\n#     vae.train(\n#     max_epochs=100,\n#     batch_size=128,\n#     early_stopping=True,\n#     early_stopping_patience=25)\n#     vae.save(f\"../../data/VAE_Species_Prediction_LPS_7000g_{cell}.pt\", overwrite = True)\n</code></pre> <pre><code>cell = \"rat\"\ntrain_adata, test_adata = prepare_data(adata, \"species\", \"condition\", cell, \"LPS6\", normalized = True)\nvae = VIDR(train_adata, linear_decoder = False)\nvae = vae.load(f\"../../data/VAE_Species_Prediction_LPS_7000g_{cell}.pt/\", train_adata)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\n</code></pre> <pre><code>jaccard_similarity = lambda x, y: len(set(x) &amp; set(y))/len(set(x) | set(y)) \n</code></pre> <pre><code>C = adata.obs.species.unique().shape[0]\njaccard_mat = np.zeros([C,C])\nall_cts = adata.obs.species.unique()\n\nfor idx, cell_i in enumerate(all_cts):\n    CD4T = adata[adata.obs[\"species\"] ==cell_i]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes_i = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"][:100]\n    for jdx, cell_j in enumerate(all_cts):\n        print(cell_i, cell_j)\n        CD4T = adata[adata.obs[\"species\"] ==cell_j]\n        sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n        diff_genes_j = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"][:100]\n\n        sim = jaccard_similarity(diff_genes_i, diff_genes_j)\n        jaccard_mat[idx, jdx] = sim\n</code></pre> <pre><code>rabbit rabbit\nrabbit pig\nrabbit rat\nrabbit mouse\npig rabbit\npig pig\npig rat\npig mouse\nrat rabbit\nrat pig\nrat rat\nrat mouse\nmouse rabbit\nmouse pig\nmouse rat\nmouse mouse\n</code></pre> <pre><code>sns.clustermap(data = jaccard_mat, xticklabels = all_cts, yticklabels = all_cts, vmin = 0)\n</code></pre> <pre><code>&lt;seaborn.matrix.ClusterGrid at 0x2ba51e866400&gt;\n</code></pre> <pre><code>jaccard_list = []\n\nfor idx, cell_i in enumerate(all_cts):\n    CD4T = adata[adata.obs[\"species\"] ==cell_i]\n    sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n    diff_genes_i = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"][:100]\n    for jdx, cell_j in enumerate(all_cts):\n        print(cell_i, cell_j)\n        CD4T = adata[adata.obs[\"species\"] ==cell_j]\n        sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n        diff_genes_j = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"][:100]\n\n        sim = jaccard_similarity(diff_genes_i, diff_genes_j)\n        jaccard_list.append([cell_i, cell_j, sim])\n</code></pre> <pre><code>rabbit rabbit\nrabbit pig\nrabbit rat\nrabbit mouse\npig rabbit\npig pig\npig rat\npig mouse\nrat rabbit\nrat pig\nrat rat\nrat mouse\nmouse rabbit\nmouse pig\nmouse rat\nmouse mouse\n</code></pre> <pre><code>jaccard_df_narrow = pd.DataFrame(jaccard_list, columns = [\"Cell Type\", \"Cell B\", \"Jaccard Similarity\"])\n</code></pre> <pre><code>filt_df = jaccard_df_narrow[jaccard_df_narrow[\"Jaccard Similarity\"] != 1]\n</code></pre> <pre><code>sns.barplot(x = \"Cell Type\", y = \"Jaccard Similarity\", data = filt_df)\nplt.xticks(rotation = 90)\nplt.xlabel(\"Species\")\n</code></pre> <pre><code>Text(0.5, 0, 'Species')\n</code></pre> <pre><code>\n</code></pre> <pre><code>#UMAP Projection of latent space\nlatent_X = vae.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup                                     \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m62114\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.\n</code></pre> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 100 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>latent_adata.obs[\"Training Split\"] =  [\"Test\" if ((i == \"rat\") &amp; (j == \"LPS6\")) else \"Train\" for i, j in zip(latent_adata.obs[\"species\"], latent_adata.obs[\"condition\"])]\n</code></pre> <pre><code>ax = sc.pl.umap(\n    latent_adata,\n    color = [\"species\"],\n    wspace = 0.45,\n    title = \"Species\"\n)\n</code></pre> <pre><code>ax = sc.pl.umap(\n    latent_adata,\n    color = [\"condition\"],\n    wspace = 0.45,\n    title = \"Condition\"\n)\n</code></pre> <pre><code>ax = sc.pl.umap(\n    latent_adata,\n    color = [\"Training Split\"],\n    palette = \"Dark2\",\n    wspace = 0.45\n)\n</code></pre> <pre><code>ctrl_key = \"unst\"\ntreat_key = \"LPS6\"\ncell_type_to_predict = \"rat\"\n</code></pre> <pre><code>cell_type_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_labels\"][\n    \"original_key\"\n]\ntreatment_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_batch\"][\n    \"original_key\"\n]\n</code></pre> <pre><code>vae.adata.obs[\"species_condition\"] = adata.obs.species.astype(str) + adata.obs.condition.astype(str)\n</code></pre> <pre><code>adata_bal = random_sample(vae.adata, \"species_condition\", \"min\")\nadata_bal_ctrl = adata_bal[(adata_bal.obs[cell_type_key] == cell_type_to_predict) &amp; (adata_bal.obs[treatment_key] == ctrl_key)]\nlatent_bal =  vae.get_latent_representation(adata_bal)\nlatent_bal_adata = sc.AnnData(X=latent_bal, obs = adata_bal.obs.copy())\nlatent_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_type_to_predict) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n</code></pre> <pre><code>#Get deltas and control centroids for each cell tpye in the training dataset\ndeltas = []\nlatent_centroids = []\ncell_types = np.unique(latent_adata.obs[cell_type_key])\nfor cell_i in cell_types:\n    if cell_i != cell_type_to_predict:\n        latent_ctrl = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n        latent_treat = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == treat_key)].X\n        deltas_i = np.average(latent_treat, axis = 0) - np.average(latent_ctrl, axis = 0)\n        deltas.append(deltas_i)\n        latent_centroids.append(np.average(latent_ctrl, axis = 0))\nlr = LinearRegression()\nreg = lr.fit(latent_centroids, deltas)\nscvidr_delta = reg.predict([np.average(latent_cd, axis = 0)])[0]\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#scvidr-rat-results","title":"scVIDR Rat Results","text":"<pre><code>treat_pred = scvidr_delta + latent_cd\npredicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\npred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\ntreat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"condition\"]:\n    if i == 'unst':\n        treatments.append(\"Control\")\n    elif i == \"LPS6\":\n        treatments.append(\"LPS6\")\n    else:\n        treatments.append(\"scVIDR\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"SF8B1.svg\")\nCD4T = adata[adata.obs[\"species\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"]\nr2_value = vae.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": \"LPS6\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF8C1.svg\",\nshow=True,\nlegend=False, title = \"scVIDR\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/pcaSF8B1.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#scgen-cross-species-results","title":"scGen Cross Species Results","text":"<pre><code>latent_mouse_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == \"mouse\") &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\nlatent_mouse_trt = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == \"mouse\") &amp; (latent_bal_adata.obs[treatment_key] == treat_key)].X\n\nscgen_treat_delta = np.average(latent_mouse_trt,axis=0) - np.average(latent_mouse_cd,axis=0)\nscgen_species_delta = np.average(latent_cd,axis=0) - np.average(latent_mouse_cd,axis=0)\n</code></pre> <pre><code>treat_pred = 0.5*(scgen_species_delta + latent_mouse_trt + scgen_treat_delta + latent_cd)\npredicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\npred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\ntreat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"condition\"]:\n    if i == 'unst':\n        treatments.append(\"Control\")\n    elif i == \"LPS6\":\n        treatments.append(\"LPS6\")\n    else:\n        treatments.append(\"scGen\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"SF8B2.svg\")\nCD4T = adata[adata.obs[\"species\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"]\nr2_value = vae.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": \"LPS6\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF8C2.svg\",\nshow=True,\nlegend=False, title = \"scGen\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/pcaSF8B2.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#scgen-results-with-average-delta","title":"scGen Results with Average Delta","text":"<pre><code>latent_ctrl = latent_bal_adata[(latent_bal_adata.obs[treatment_key] == ctrl_key)].X\nlatent_treat = latent_bal_adata[(latent_bal_adata.obs[treatment_key] == treat_key)].X\nscgen_delta = np.average(latent_treat, axis = 0) - np.average(latent_ctrl, axis = 0)\n</code></pre> <pre><code># latent_bal_adata[(latent_bal_adata.obs[treatment_key] == treat_key)].obs.species_condition.unique()\n</code></pre> <pre><code>treat_pred = scgen_delta + latent_cd\npredicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\npred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\ntreat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"condition\"]:\n    if i == 'unst':\n        treatments.append(\"Control\")\n    elif i == \"LPS6\":\n        treatments.append(\"LPS6\")\n    else:\n        treatments.append(\"scGen\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"SF8B2.svg\")\nCD4T = adata[adata.obs[\"species\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"]\nr2_value = vae.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": \"LPS6\"},\ngene_list=diff_genes[:10],\ntop_100_genes = None,\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF8C2.svg\",\nshow=True,\nlegend=False, title = \"scGen\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/pcaSF8B2.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#scpregan-results","title":"scPreGAN Results","text":"<pre><code>from scPreGAN import *\n</code></pre> <pre><code>gan = Model(n_features=adata.X.shape[1], use_cuda=True)\ntrain_data = gan.load_anndata(data_path=\"../data/train_species.h5ad\",\n            condition_key=\"condition\",\n            condition={\"control\":\"unst\", \"case\":\"LPS6\"},\n            cell_type_key=\"species\",\n            out_of_sample_prediction = True,\n            prediction_cell_type=cell\n            )\n</code></pre> <pre><code>Random Seed:  3060\nSuccessfully created the model\nSuccessfully loaded the model\n</code></pre> <pre><code># #Training scPreGan\n\n# gan.train(train_data = train_data)\n\n# torch.save(gan.D_A.state_dict(), \"../data/gan_da_rat.pt\")\n# torch.save(gan.D_B.state_dict(), \"../data/gan_db_rat.pt\")\n# torch.save(gan.G_A.state_dict(), \"../data/gan_ga_rat.pt\")\n# torch.save(gan.G_B.state_dict(), \"../data/gan_gb_rat.pt\")\n# torch.save(gan.E.state_dict(), \"../data/gan_e_rat.pt\")\n</code></pre> <pre><code>[100/20000] adv_loss: -0.0238  recon_loss: 0.3465 encoding_loss: 0.0103 G_loss: 0.3330 D_A_loss: -108.1751  D_B_loss: -108.4284\n[200/20000] adv_loss: -0.0382  recon_loss: 0.2965 encoding_loss: 0.0043 G_loss: 0.2626 D_A_loss: -93.5066  D_B_loss: -89.2510\n[300/20000] adv_loss: -0.0352  recon_loss: 0.2698 encoding_loss: 0.0036 G_loss: 0.2381 D_A_loss: -84.6317  D_B_loss: -83.2130\n[400/20000] adv_loss: -0.0327  recon_loss: 0.2668 encoding_loss: 0.0025 G_loss: 0.2366 D_A_loss: -78.1662  D_B_loss: -74.5129\n[500/20000] adv_loss: -0.0302  recon_loss: 0.2525 encoding_loss: 0.0019 G_loss: 0.2242 D_A_loss: -73.4822  D_B_loss: -70.3501\n[600/20000] adv_loss: -0.0206  recon_loss: 0.2416 encoding_loss: 0.0022 G_loss: 0.2232 D_A_loss: -69.2881  D_B_loss: -64.7405\n[700/20000] adv_loss: -0.0243  recon_loss: 0.2421 encoding_loss: 0.0021 G_loss: 0.2200 D_A_loss: -63.4964  D_B_loss: -60.3896\n[800/20000] adv_loss: -0.0142  recon_loss: 0.2307 encoding_loss: 0.0016 G_loss: 0.2180 D_A_loss: -58.9558  D_B_loss: -55.5171\n[900/20000] adv_loss: -0.0167  recon_loss: 0.2193 encoding_loss: 0.0016 G_loss: 0.2042 D_A_loss: -53.7842  D_B_loss: -51.2267\n[1000/20000] adv_loss: -0.0172  recon_loss: 0.2086 encoding_loss: 0.0015 G_loss: 0.1929 D_A_loss: -49.7916  D_B_loss: -47.0637\n[1100/20000] adv_loss: -0.0074  recon_loss: 0.2126 encoding_loss: 0.0022 G_loss: 0.2073 D_A_loss: -48.4547  D_B_loss: -43.4780\n[1200/20000] adv_loss: -0.0105  recon_loss: 0.2044 encoding_loss: 0.0017 G_loss: 0.1956 D_A_loss: -44.4699  D_B_loss: -41.5969\n[1300/20000] adv_loss: -0.0097  recon_loss: 0.1957 encoding_loss: 0.0014 G_loss: 0.1873 D_A_loss: -42.3269  D_B_loss: -37.2285\n[1400/20000] adv_loss: 0.0031  recon_loss: 0.2031 encoding_loss: 0.0048 G_loss: 0.2109 D_A_loss: -39.1141  D_B_loss: -36.2893\n[1500/20000] adv_loss: -0.0001  recon_loss: 0.1947 encoding_loss: 0.0015 G_loss: 0.1960 D_A_loss: -36.5831  D_B_loss: -32.9490\n[1600/20000] adv_loss: 0.0046  recon_loss: 0.1814 encoding_loss: 0.0026 G_loss: 0.1887 D_A_loss: -33.1014  D_B_loss: -31.7685\n[1700/20000] adv_loss: 0.0033  recon_loss: 0.1914 encoding_loss: 0.0017 G_loss: 0.1964 D_A_loss: -30.6015  D_B_loss: -29.7046\n[1800/20000] adv_loss: 0.0028  recon_loss: 0.1838 encoding_loss: 0.0016 G_loss: 0.1882 D_A_loss: -27.2895  D_B_loss: -27.7060\n[1900/20000] adv_loss: 0.0073  recon_loss: 0.1853 encoding_loss: 0.0012 G_loss: 0.1938 D_A_loss: -25.7496  D_B_loss: -27.4963\n[2000/20000] adv_loss: 0.0120  recon_loss: 0.1801 encoding_loss: 0.0017 G_loss: 0.1938 D_A_loss: -23.0978  D_B_loss: -25.4080\n[2100/20000] adv_loss: 0.0227  recon_loss: 0.1789 encoding_loss: 0.0014 G_loss: 0.2030 D_A_loss: -23.0014  D_B_loss: -24.6750\n[2200/20000] adv_loss: 0.0122  recon_loss: 0.1785 encoding_loss: 0.0015 G_loss: 0.1923 D_A_loss: -18.0069  D_B_loss: -24.2036\n[2300/20000] adv_loss: 0.0081  recon_loss: 0.1817 encoding_loss: 0.0012 G_loss: 0.1910 D_A_loss: -16.8236  D_B_loss: -21.8153\n[2400/20000] adv_loss: 0.0068  recon_loss: 0.1802 encoding_loss: 0.0016 G_loss: 0.1886 D_A_loss: -15.7430  D_B_loss: -22.1690\n[2500/20000] adv_loss: 0.0139  recon_loss: 0.1768 encoding_loss: 0.0013 G_loss: 0.1921 D_A_loss: -14.6871  D_B_loss: -21.7059\n[2600/20000] adv_loss: 0.0213  recon_loss: 0.1827 encoding_loss: 0.0016 G_loss: 0.2056 D_A_loss: -14.1933  D_B_loss: -21.2217\n[2700/20000] adv_loss: 0.0211  recon_loss: 0.1820 encoding_loss: 0.0019 G_loss: 0.2051 D_A_loss: -13.6804  D_B_loss: -20.8790\n[2800/20000] adv_loss: 0.0216  recon_loss: 0.1780 encoding_loss: 0.0014 G_loss: 0.2010 D_A_loss: -12.3563  D_B_loss: -19.8406\n[2900/20000] adv_loss: 0.0245  recon_loss: 0.1719 encoding_loss: 0.0020 G_loss: 0.1983 D_A_loss: -13.1034  D_B_loss: -21.5601\n[3000/20000] adv_loss: 0.0248  recon_loss: 0.1689 encoding_loss: 0.0021 G_loss: 0.1958 D_A_loss: -12.4081  D_B_loss: -19.2791\n[3100/20000] adv_loss: 0.0251  recon_loss: 0.1713 encoding_loss: 0.0019 G_loss: 0.1983 D_A_loss: -11.9336  D_B_loss: -19.8580\n[3200/20000] adv_loss: 0.0359  recon_loss: 0.1696 encoding_loss: 0.0020 G_loss: 0.2075 D_A_loss: -13.0851  D_B_loss: -19.3289\n[3300/20000] adv_loss: 0.0331  recon_loss: 0.1698 encoding_loss: 0.0015 G_loss: 0.2044 D_A_loss: -11.5174  D_B_loss: -20.3864\n[3400/20000] adv_loss: 0.0299  recon_loss: 0.1761 encoding_loss: 0.0021 G_loss: 0.2082 D_A_loss: -12.2965  D_B_loss: -19.8114\n[3500/20000] adv_loss: 0.0365  recon_loss: 0.1668 encoding_loss: 0.0020 G_loss: 0.2054 D_A_loss: -12.1880  D_B_loss: -20.8127\n[3600/20000] adv_loss: 0.0446  recon_loss: 0.1778 encoding_loss: 0.0018 G_loss: 0.2241 D_A_loss: -12.9537  D_B_loss: -20.7383\n[3700/20000] adv_loss: 0.0391  recon_loss: 0.1748 encoding_loss: 0.0018 G_loss: 0.2158 D_A_loss: -12.7856  D_B_loss: -20.0384\n[3800/20000] adv_loss: 0.0394  recon_loss: 0.1797 encoding_loss: 0.0027 G_loss: 0.2217 D_A_loss: -11.5444  D_B_loss: -20.3644\n[3900/20000] adv_loss: 0.0469  recon_loss: 0.1769 encoding_loss: 0.0020 G_loss: 0.2258 D_A_loss: -12.6670  D_B_loss: -21.0934\n[4000/20000] adv_loss: 0.0413  recon_loss: 0.1684 encoding_loss: 0.0015 G_loss: 0.2113 D_A_loss: -12.4237  D_B_loss: -21.4957\n[4100/20000] adv_loss: 0.0453  recon_loss: 0.1784 encoding_loss: 0.0015 G_loss: 0.2252 D_A_loss: -12.1669  D_B_loss: -20.0435\n[4200/20000] adv_loss: 0.0486  recon_loss: 0.1909 encoding_loss: 0.0017 G_loss: 0.2412 D_A_loss: -12.8943  D_B_loss: -21.8133\n[4300/20000] adv_loss: 0.0462  recon_loss: 0.1792 encoding_loss: 0.0024 G_loss: 0.2277 D_A_loss: -12.5277  D_B_loss: -21.3984\n[4400/20000] adv_loss: 0.0529  recon_loss: 0.1695 encoding_loss: 0.0018 G_loss: 0.2242 D_A_loss: -13.2052  D_B_loss: -21.8325\n[4500/20000] adv_loss: 0.0513  recon_loss: 0.1768 encoding_loss: 0.0018 G_loss: 0.2299 D_A_loss: -12.3329  D_B_loss: -21.5632\n[4600/20000] adv_loss: 0.0536  recon_loss: 0.1710 encoding_loss: 0.0020 G_loss: 0.2266 D_A_loss: -13.0512  D_B_loss: -21.6949\n[4700/20000] adv_loss: 0.0534  recon_loss: 0.1695 encoding_loss: 0.0017 G_loss: 0.2246 D_A_loss: -12.6687  D_B_loss: -21.5501\n[4800/20000] adv_loss: 0.0521  recon_loss: 0.1724 encoding_loss: 0.0019 G_loss: 0.2264 D_A_loss: -12.5512  D_B_loss: -21.9120\n[4900/20000] adv_loss: 0.0558  recon_loss: 0.2056 encoding_loss: 0.0019 G_loss: 0.2634 D_A_loss: -12.3539  D_B_loss: -21.5966\n[5000/20000] adv_loss: 0.0538  recon_loss: 0.1806 encoding_loss: 0.0018 G_loss: 0.2363 D_A_loss: -11.7618  D_B_loss: -20.3047\n[5100/20000] adv_loss: 0.0556  recon_loss: 0.1780 encoding_loss: 0.0019 G_loss: 0.2355 D_A_loss: -11.9076  D_B_loss: -22.2701\n[5200/20000] adv_loss: 0.0541  recon_loss: 0.1715 encoding_loss: 0.0023 G_loss: 0.2279 D_A_loss: -12.6001  D_B_loss: -22.1283\n[5300/20000] adv_loss: 0.0590  recon_loss: 0.1835 encoding_loss: 0.0026 G_loss: 0.2451 D_A_loss: -12.3211  D_B_loss: -21.4763\n[5400/20000] adv_loss: 0.0584  recon_loss: 0.1840 encoding_loss: 0.0017 G_loss: 0.2440 D_A_loss: -12.1296  D_B_loss: -22.1303\n[5500/20000] adv_loss: 0.0568  recon_loss: 0.1682 encoding_loss: 0.0014 G_loss: 0.2264 D_A_loss: -11.9058  D_B_loss: -21.7852\n[5600/20000] adv_loss: 0.0578  recon_loss: 0.1708 encoding_loss: 0.0017 G_loss: 0.2302 D_A_loss: -12.2129  D_B_loss: -21.5865\n[5700/20000] adv_loss: 0.0532  recon_loss: 0.1652 encoding_loss: 0.0017 G_loss: 0.2201 D_A_loss: -11.8861  D_B_loss: -21.3832\n[5800/20000] adv_loss: 0.0592  recon_loss: 0.1800 encoding_loss: 0.0015 G_loss: 0.2407 D_A_loss: -11.8592  D_B_loss: -22.5028\n[5900/20000] adv_loss: 0.0611  recon_loss: 0.1724 encoding_loss: 0.0018 G_loss: 0.2353 D_A_loss: -12.1742  D_B_loss: -21.7796\n[6000/20000] adv_loss: 0.0581  recon_loss: 0.1852 encoding_loss: 0.0015 G_loss: 0.2447 D_A_loss: -12.2476  D_B_loss: -20.6969\n[6100/20000] adv_loss: 0.0574  recon_loss: 0.1685 encoding_loss: 0.0015 G_loss: 0.2274 D_A_loss: -11.6020  D_B_loss: -21.1404\n[6200/20000] adv_loss: 0.0557  recon_loss: 0.1648 encoding_loss: 0.0013 G_loss: 0.2218 D_A_loss: -11.5391  D_B_loss: -21.7059\n[6300/20000] adv_loss: 0.0552  recon_loss: 0.1747 encoding_loss: 0.0022 G_loss: 0.2321 D_A_loss: -12.2373  D_B_loss: -22.0071\n[6400/20000] adv_loss: 0.0548  recon_loss: 0.1797 encoding_loss: 0.0019 G_loss: 0.2364 D_A_loss: -12.1547  D_B_loss: -20.7848\n[6500/20000] adv_loss: 0.0532  recon_loss: 0.1607 encoding_loss: 0.0019 G_loss: 0.2158 D_A_loss: -12.1215  D_B_loss: -21.3225\n[6600/20000] adv_loss: 0.0538  recon_loss: 0.1740 encoding_loss: 0.0016 G_loss: 0.2294 D_A_loss: -12.9073  D_B_loss: -22.5973\n[6700/20000] adv_loss: 0.0535  recon_loss: 0.1682 encoding_loss: 0.0012 G_loss: 0.2229 D_A_loss: -11.5948  D_B_loss: -22.3586\n[6800/20000] adv_loss: 0.0605  recon_loss: 0.1753 encoding_loss: 0.0012 G_loss: 0.2370 D_A_loss: -11.5107  D_B_loss: -21.3939\n[6900/20000] adv_loss: 0.0495  recon_loss: 0.1642 encoding_loss: 0.0016 G_loss: 0.2153 D_A_loss: -11.3190  D_B_loss: -21.5034\n[7000/20000] adv_loss: 0.0492  recon_loss: 0.1729 encoding_loss: 0.0015 G_loss: 0.2236 D_A_loss: -10.7056  D_B_loss: -21.3990\n[7100/20000] adv_loss: 0.0513  recon_loss: 0.1684 encoding_loss: 0.0015 G_loss: 0.2212 D_A_loss: -11.9519  D_B_loss: -21.0379\n[7200/20000] adv_loss: 0.0475  recon_loss: 0.1684 encoding_loss: 0.0013 G_loss: 0.2172 D_A_loss: -11.7898  D_B_loss: -19.9595\n[7300/20000] adv_loss: 0.0474  recon_loss: 0.1623 encoding_loss: 0.0016 G_loss: 0.2113 D_A_loss: -11.8793  D_B_loss: -20.9907\n[7400/20000] adv_loss: 0.0469  recon_loss: 0.1792 encoding_loss: 0.0013 G_loss: 0.2273 D_A_loss: -11.8935  D_B_loss: -20.1690\n[7500/20000] adv_loss: 0.0465  recon_loss: 0.1730 encoding_loss: 0.0015 G_loss: 0.2210 D_A_loss: -12.2184  D_B_loss: -21.4691\n[7600/20000] adv_loss: 0.0469  recon_loss: 0.1640 encoding_loss: 0.0014 G_loss: 0.2123 D_A_loss: -11.1894  D_B_loss: -20.3001\n[7700/20000] adv_loss: 0.0463  recon_loss: 0.1691 encoding_loss: 0.0015 G_loss: 0.2169 D_A_loss: -11.3900  D_B_loss: -21.5486\n[7800/20000] adv_loss: 0.0454  recon_loss: 0.1744 encoding_loss: 0.0016 G_loss: 0.2215 D_A_loss: -11.6896  D_B_loss: -20.6187\n[7900/20000] adv_loss: 0.0460  recon_loss: 0.1786 encoding_loss: 0.0017 G_loss: 0.2263 D_A_loss: -11.4558  D_B_loss: -20.7117\n[8000/20000] adv_loss: 0.0413  recon_loss: 0.1665 encoding_loss: 0.0020 G_loss: 0.2098 D_A_loss: -11.4162  D_B_loss: -19.7117\n[8100/20000] adv_loss: 0.0420  recon_loss: 0.1609 encoding_loss: 0.0016 G_loss: 0.2046 D_A_loss: -11.7241  D_B_loss: -20.1521\n[8200/20000] adv_loss: 0.0450  recon_loss: 0.1668 encoding_loss: 0.0020 G_loss: 0.2138 D_A_loss: -11.6045  D_B_loss: -20.1455\n[8300/20000] adv_loss: 0.0402  recon_loss: 0.1731 encoding_loss: 0.0015 G_loss: 0.2149 D_A_loss: -11.4212  D_B_loss: -19.9849\n[8400/20000] adv_loss: 0.0406  recon_loss: 0.1678 encoding_loss: 0.0014 G_loss: 0.2098 D_A_loss: -11.7868  D_B_loss: -19.8300\n[8500/20000] adv_loss: 0.0405  recon_loss: 0.1648 encoding_loss: 0.0020 G_loss: 0.2073 D_A_loss: -10.8320  D_B_loss: -19.2213\n[8600/20000] adv_loss: 0.0402  recon_loss: 0.1709 encoding_loss: 0.0019 G_loss: 0.2130 D_A_loss: -11.3348  D_B_loss: -20.3355\n[8700/20000] adv_loss: 0.0410  recon_loss: 0.1671 encoding_loss: 0.0015 G_loss: 0.2096 D_A_loss: -11.6441  D_B_loss: -19.3199\n[8800/20000] adv_loss: 0.0379  recon_loss: 0.1740 encoding_loss: 0.0021 G_loss: 0.2140 D_A_loss: -11.8881  D_B_loss: -19.6553\n[8900/20000] adv_loss: 0.0432  recon_loss: 0.1773 encoding_loss: 0.0018 G_loss: 0.2223 D_A_loss: -12.2151  D_B_loss: -21.6869\n[9000/20000] adv_loss: 0.0394  recon_loss: 0.1639 encoding_loss: 0.0020 G_loss: 0.2052 D_A_loss: -11.4922  D_B_loss: -19.5311\n[9100/20000] adv_loss: 0.0391  recon_loss: 0.1754 encoding_loss: 0.0025 G_loss: 0.2170 D_A_loss: -11.4344  D_B_loss: -20.0152\n[9200/20000] adv_loss: 0.0395  recon_loss: 0.1729 encoding_loss: 0.0026 G_loss: 0.2150 D_A_loss: -10.6682  D_B_loss: -20.2429\n[9300/20000] adv_loss: 0.0366  recon_loss: 0.1664 encoding_loss: 0.0021 G_loss: 0.2050 D_A_loss: -11.9154  D_B_loss: -20.4456\n[9400/20000] adv_loss: 0.0358  recon_loss: 0.1666 encoding_loss: 0.0018 G_loss: 0.2042 D_A_loss: -11.9083  D_B_loss: -20.3259\n[9500/20000] adv_loss: 0.0375  recon_loss: 0.1801 encoding_loss: 0.0031 G_loss: 0.2208 D_A_loss: -11.4016  D_B_loss: -19.6480\n[9600/20000] adv_loss: 0.0350  recon_loss: 0.1813 encoding_loss: 0.0021 G_loss: 0.2184 D_A_loss: -12.2340  D_B_loss: -20.0809\n[9700/20000] adv_loss: 0.0327  recon_loss: 0.1709 encoding_loss: 0.0024 G_loss: 0.2059 D_A_loss: -11.8934  D_B_loss: -20.2570\n[9800/20000] adv_loss: 0.0357  recon_loss: 0.1629 encoding_loss: 0.0023 G_loss: 0.2008 D_A_loss: -11.5790  D_B_loss: -20.6521\n[9900/20000] adv_loss: 0.0321  recon_loss: 0.1661 encoding_loss: 0.0022 G_loss: 0.2004 D_A_loss: -11.4205  D_B_loss: -19.7638\n[10000/20000] adv_loss: 0.0350  recon_loss: 0.1704 encoding_loss: 0.0018 G_loss: 0.2073 D_A_loss: -11.7917  D_B_loss: -21.1067\n[10100/20000] adv_loss: 0.0359  recon_loss: 0.1638 encoding_loss: 0.0021 G_loss: 0.2018 D_A_loss: -12.3479  D_B_loss: -19.1138\n[10200/20000] adv_loss: 0.0339  recon_loss: 0.1625 encoding_loss: 0.0019 G_loss: 0.1983 D_A_loss: -10.9133  D_B_loss: -19.8377\n[10300/20000] adv_loss: 0.0325  recon_loss: 0.1817 encoding_loss: 0.0019 G_loss: 0.2161 D_A_loss: -11.8474  D_B_loss: -20.7530\n[10400/20000] adv_loss: 0.0302  recon_loss: 0.1761 encoding_loss: 0.0021 G_loss: 0.2084 D_A_loss: -11.3460  D_B_loss: -19.3849\n[10500/20000] adv_loss: 0.0342  recon_loss: 0.1656 encoding_loss: 0.0023 G_loss: 0.2021 D_A_loss: -11.1505  D_B_loss: -19.6499\n[10600/20000] adv_loss: 0.0315  recon_loss: 0.1692 encoding_loss: 0.0023 G_loss: 0.2030 D_A_loss: -11.6456  D_B_loss: -20.1447\n[10700/20000] adv_loss: 0.0312  recon_loss: 0.1770 encoding_loss: 0.0036 G_loss: 0.2118 D_A_loss: -15.2892  D_B_loss: -22.5845\n[10800/20000] adv_loss: 0.0275  recon_loss: 0.1752 encoding_loss: 0.0032 G_loss: 0.2059 D_A_loss: -11.3593  D_B_loss: -20.9051\n[10900/20000] adv_loss: 0.0265  recon_loss: 0.1718 encoding_loss: 0.0018 G_loss: 0.2001 D_A_loss: -12.7211  D_B_loss: -21.2403\n[11000/20000] adv_loss: 0.0271  recon_loss: 0.1670 encoding_loss: 0.0024 G_loss: 0.1964 D_A_loss: -10.9926  D_B_loss: -21.7853\n[11100/20000] adv_loss: 0.0284  recon_loss: 0.1738 encoding_loss: 0.0030 G_loss: 0.2052 D_A_loss: -13.0072  D_B_loss: -21.4462\n[11200/20000] adv_loss: 0.0281  recon_loss: 0.1744 encoding_loss: 0.0024 G_loss: 0.2049 D_A_loss: -12.0438  D_B_loss: -20.5864\n[11300/20000] adv_loss: 0.0257  recon_loss: 0.1662 encoding_loss: 0.0023 G_loss: 0.1942 D_A_loss: -11.5773  D_B_loss: -20.2980\n[11400/20000] adv_loss: 0.0287  recon_loss: 0.1738 encoding_loss: 0.0030 G_loss: 0.2055 D_A_loss: -13.6893  D_B_loss: -21.6739\n[11500/20000] adv_loss: 0.0264  recon_loss: 0.1684 encoding_loss: 0.0028 G_loss: 0.1976 D_A_loss: -12.7059  D_B_loss: -21.7263\n[11600/20000] adv_loss: 0.0261  recon_loss: 0.1630 encoding_loss: 0.0041 G_loss: 0.1932 D_A_loss: -11.7351  D_B_loss: -21.6808\n[11700/20000] adv_loss: 0.0266  recon_loss: 0.1662 encoding_loss: 0.0036 G_loss: 0.1965 D_A_loss: -12.3227  D_B_loss: -21.3576\n[11800/20000] adv_loss: 0.0240  recon_loss: 0.1752 encoding_loss: 0.0025 G_loss: 0.2016 D_A_loss: -11.8245  D_B_loss: -22.1777\n[11900/20000] adv_loss: 0.0250  recon_loss: 0.1670 encoding_loss: 0.0023 G_loss: 0.1942 D_A_loss: -12.7580  D_B_loss: -20.9058\n[12000/20000] adv_loss: 0.0266  recon_loss: 0.1716 encoding_loss: 0.0028 G_loss: 0.2010 D_A_loss: -11.5222  D_B_loss: -20.8387\n[12100/20000] adv_loss: 0.0239  recon_loss: 0.1673 encoding_loss: 0.0024 G_loss: 0.1935 D_A_loss: -12.5051  D_B_loss: -21.4505\n[12200/20000] adv_loss: 0.0235  recon_loss: 0.1609 encoding_loss: 0.0027 G_loss: 0.1870 D_A_loss: -11.5762  D_B_loss: -21.5789\n[12300/20000] adv_loss: 0.0317  recon_loss: 0.1892 encoding_loss: 0.0040 G_loss: 0.2250 D_A_loss: -13.7001  D_B_loss: -22.7667\n[12400/20000] adv_loss: 0.0259  recon_loss: 0.1778 encoding_loss: 0.0030 G_loss: 0.2067 D_A_loss: -12.8568  D_B_loss: -23.1269\n[12500/20000] adv_loss: 0.0262  recon_loss: 0.1816 encoding_loss: 0.0024 G_loss: 0.2102 D_A_loss: -13.0925  D_B_loss: -20.8266\n[12600/20000] adv_loss: 0.0223  recon_loss: 0.1750 encoding_loss: 0.0024 G_loss: 0.1998 D_A_loss: -13.2685  D_B_loss: -20.7516\n[12700/20000] adv_loss: 0.0238  recon_loss: 0.1651 encoding_loss: 0.0025 G_loss: 0.1915 D_A_loss: -11.7419  D_B_loss: -21.9982\n[12800/20000] adv_loss: 0.0282  recon_loss: 0.1745 encoding_loss: 0.0026 G_loss: 0.2052 D_A_loss: -13.2552  D_B_loss: -22.2194\n[12900/20000] adv_loss: 0.0255  recon_loss: 0.1773 encoding_loss: 0.0038 G_loss: 0.2066 D_A_loss: -13.7069  D_B_loss: -21.7949\n[13000/20000] adv_loss: 0.0272  recon_loss: 0.1736 encoding_loss: 0.0023 G_loss: 0.2031 D_A_loss: -13.0551  D_B_loss: -21.0294\n[13100/20000] adv_loss: 0.0239  recon_loss: 0.1691 encoding_loss: 0.0024 G_loss: 0.1954 D_A_loss: -11.4410  D_B_loss: -21.5614\n[13200/20000] adv_loss: 0.0240  recon_loss: 0.1765 encoding_loss: 0.0018 G_loss: 0.2023 D_A_loss: -11.4681  D_B_loss: -21.7203\n[13300/20000] adv_loss: 0.0243  recon_loss: 0.1790 encoding_loss: 0.0019 G_loss: 0.2052 D_A_loss: -11.7007  D_B_loss: -20.7988\n[13400/20000] adv_loss: 0.0255  recon_loss: 0.1660 encoding_loss: 0.0023 G_loss: 0.1938 D_A_loss: -11.6956  D_B_loss: -20.8346\n[13500/20000] adv_loss: 0.0250  recon_loss: 0.1715 encoding_loss: 0.0026 G_loss: 0.1991 D_A_loss: -12.8404  D_B_loss: -22.1297\n[13600/20000] adv_loss: 0.0255  recon_loss: 0.1718 encoding_loss: 0.0028 G_loss: 0.2001 D_A_loss: -10.6984  D_B_loss: -21.0549\n[13700/20000] adv_loss: 0.0253  recon_loss: 0.1679 encoding_loss: 0.0022 G_loss: 0.1955 D_A_loss: -11.5727  D_B_loss: -21.6037\n[13800/20000] adv_loss: 0.0251  recon_loss: 0.1766 encoding_loss: 0.0022 G_loss: 0.2039 D_A_loss: -13.0105  D_B_loss: -23.8891\n[13900/20000] adv_loss: 0.0223  recon_loss: 0.1657 encoding_loss: 0.0024 G_loss: 0.1904 D_A_loss: -12.4314  D_B_loss: -22.2521\n[14000/20000] adv_loss: 0.0231  recon_loss: 0.1635 encoding_loss: 0.0023 G_loss: 0.1889 D_A_loss: -12.1050  D_B_loss: -21.1881\n[14100/20000] adv_loss: 0.0241  recon_loss: 0.1634 encoding_loss: 0.0025 G_loss: 0.1900 D_A_loss: -11.2742  D_B_loss: -20.8966\n[14200/20000] adv_loss: 0.0310  recon_loss: 0.1773 encoding_loss: 0.0038 G_loss: 0.2121 D_A_loss: -13.9516  D_B_loss: -22.6594\n[14300/20000] adv_loss: 0.0238  recon_loss: 0.1765 encoding_loss: 0.0024 G_loss: 0.2026 D_A_loss: -13.0705  D_B_loss: -21.1153\n[14400/20000] adv_loss: 0.0270  recon_loss: 0.1706 encoding_loss: 0.0024 G_loss: 0.2001 D_A_loss: -11.5381  D_B_loss: -21.8381\n[14500/20000] adv_loss: 0.0248  recon_loss: 0.1709 encoding_loss: 0.0024 G_loss: 0.1980 D_A_loss: -10.7628  D_B_loss: -21.0925\n[14600/20000] adv_loss: 0.0256  recon_loss: 0.1690 encoding_loss: 0.0020 G_loss: 0.1966 D_A_loss: -12.3722  D_B_loss: -21.1659\n[14700/20000] adv_loss: 0.0233  recon_loss: 0.1672 encoding_loss: 0.0025 G_loss: 0.1930 D_A_loss: -12.2467  D_B_loss: -20.9909\n[14800/20000] adv_loss: 0.0284  recon_loss: 0.1745 encoding_loss: 0.0020 G_loss: 0.2049 D_A_loss: -11.7965  D_B_loss: -21.9676\n[14900/20000] adv_loss: 0.0277  recon_loss: 0.1746 encoding_loss: 0.0022 G_loss: 0.2046 D_A_loss: -11.1138  D_B_loss: -20.4407\n[15000/20000] adv_loss: 0.0257  recon_loss: 0.1714 encoding_loss: 0.0020 G_loss: 0.1991 D_A_loss: -12.1143  D_B_loss: -20.6258\n[15100/20000] adv_loss: 0.0237  recon_loss: 0.1746 encoding_loss: 0.0035 G_loss: 0.2018 D_A_loss: -11.1458  D_B_loss: -20.8461\n[15200/20000] adv_loss: 0.0307  recon_loss: 0.1718 encoding_loss: 0.0027 G_loss: 0.2052 D_A_loss: -12.9859  D_B_loss: -20.7232\n[15300/20000] adv_loss: 0.0274  recon_loss: 0.1814 encoding_loss: 0.0032 G_loss: 0.2120 D_A_loss: -12.3387  D_B_loss: -22.6639\n[15400/20000] adv_loss: 0.0243  recon_loss: 0.1686 encoding_loss: 0.0035 G_loss: 0.1964 D_A_loss: -12.3349  D_B_loss: -22.5876\n[15500/20000] adv_loss: 0.0274  recon_loss: 0.1726 encoding_loss: 0.0023 G_loss: 0.2023 D_A_loss: -11.2997  D_B_loss: -20.7801\n[15600/20000] adv_loss: 0.0289  recon_loss: 0.1663 encoding_loss: 0.0026 G_loss: 0.1978 D_A_loss: -12.0270  D_B_loss: -20.6875\n[15700/20000] adv_loss: 0.0252  recon_loss: 0.1698 encoding_loss: 0.0019 G_loss: 0.1968 D_A_loss: -11.7578  D_B_loss: -20.0737\n[15800/20000] adv_loss: 0.0241  recon_loss: 0.1662 encoding_loss: 0.0025 G_loss: 0.1928 D_A_loss: -11.8110  D_B_loss: -21.0124\n[15900/20000] adv_loss: 0.0251  recon_loss: 0.1640 encoding_loss: 0.0022 G_loss: 0.1913 D_A_loss: -11.3624  D_B_loss: -20.9140\n[16000/20000] adv_loss: 0.0270  recon_loss: 0.1680 encoding_loss: 0.0023 G_loss: 0.1973 D_A_loss: -11.9620  D_B_loss: -21.3198\n[16100/20000] adv_loss: 0.0270  recon_loss: 0.1699 encoding_loss: 0.0025 G_loss: 0.1994 D_A_loss: -12.3831  D_B_loss: -20.5892\n[16200/20000] adv_loss: 0.0282  recon_loss: 0.1677 encoding_loss: 0.0020 G_loss: 0.1978 D_A_loss: -12.7482  D_B_loss: -20.4608\n[16300/20000] adv_loss: 0.0313  recon_loss: 0.1781 encoding_loss: 0.0030 G_loss: 0.2124 D_A_loss: -14.2345  D_B_loss: -21.4682\n[16400/20000] adv_loss: 0.0257  recon_loss: 0.1717 encoding_loss: 0.0022 G_loss: 0.1997 D_A_loss: -11.6224  D_B_loss: -20.8077\n[16500/20000] adv_loss: 0.0304  recon_loss: 0.1739 encoding_loss: 0.0023 G_loss: 0.2065 D_A_loss: -12.2905  D_B_loss: -21.3156\n[16600/20000] adv_loss: 0.0289  recon_loss: 0.1680 encoding_loss: 0.0025 G_loss: 0.1993 D_A_loss: -12.4972  D_B_loss: -20.4863\n[16700/20000] adv_loss: 0.0307  recon_loss: 0.1738 encoding_loss: 0.0026 G_loss: 0.2071 D_A_loss: -12.2735  D_B_loss: -20.9083\n[16800/20000] adv_loss: 0.0262  recon_loss: 0.1704 encoding_loss: 0.0027 G_loss: 0.1993 D_A_loss: -12.9444  D_B_loss: -21.3499\n[16900/20000] adv_loss: 0.0247  recon_loss: 0.1768 encoding_loss: 0.0024 G_loss: 0.2039 D_A_loss: -12.4784  D_B_loss: -21.5959\n[17000/20000] adv_loss: 0.0254  recon_loss: 0.1695 encoding_loss: 0.0022 G_loss: 0.1972 D_A_loss: -12.1536  D_B_loss: -21.8945\n[17100/20000] adv_loss: 0.0272  recon_loss: 0.1648 encoding_loss: 0.0021 G_loss: 0.1941 D_A_loss: -12.0534  D_B_loss: -21.2327\n[17200/20000] adv_loss: 0.0273  recon_loss: 0.1741 encoding_loss: 0.0027 G_loss: 0.2040 D_A_loss: -12.3437  D_B_loss: -20.1606\n[17300/20000] adv_loss: 0.0320  recon_loss: 0.1755 encoding_loss: 0.0027 G_loss: 0.2102 D_A_loss: -11.9851  D_B_loss: -21.2165\n[17400/20000] adv_loss: 0.0264  recon_loss: 0.1605 encoding_loss: 0.0023 G_loss: 0.1892 D_A_loss: -12.0887  D_B_loss: -21.8521\n[17500/20000] adv_loss: 0.0304  recon_loss: 0.1706 encoding_loss: 0.0025 G_loss: 0.2035 D_A_loss: -13.8096  D_B_loss: -20.2115\n[17600/20000] adv_loss: 0.0292  recon_loss: 0.1685 encoding_loss: 0.0023 G_loss: 0.2000 D_A_loss: -11.6279  D_B_loss: -20.1569\n[17700/20000] adv_loss: 0.0278  recon_loss: 0.1705 encoding_loss: 0.0019 G_loss: 0.2003 D_A_loss: -11.3740  D_B_loss: -20.7145\n[17800/20000] adv_loss: 0.0303  recon_loss: 0.1672 encoding_loss: 0.0029 G_loss: 0.2004 D_A_loss: -12.6720  D_B_loss: -20.6704\n[17900/20000] adv_loss: 0.0284  recon_loss: 0.1759 encoding_loss: 0.0019 G_loss: 0.2062 D_A_loss: -11.6906  D_B_loss: -20.1122\n[18000/20000] adv_loss: 0.0283  recon_loss: 0.1770 encoding_loss: 0.0043 G_loss: 0.2095 D_A_loss: -12.6829  D_B_loss: -21.3194\n[18100/20000] adv_loss: 0.0302  recon_loss: 0.1707 encoding_loss: 0.0023 G_loss: 0.2032 D_A_loss: -12.5079  D_B_loss: -20.5437\n[18200/20000] adv_loss: 0.0272  recon_loss: 0.1652 encoding_loss: 0.0018 G_loss: 0.1943 D_A_loss: -12.0940  D_B_loss: -20.6839\n[18300/20000] adv_loss: 0.0316  recon_loss: 0.1830 encoding_loss: 0.0035 G_loss: 0.2180 D_A_loss: -14.7120  D_B_loss: -21.7434\n[18400/20000] adv_loss: 0.0279  recon_loss: 0.1719 encoding_loss: 0.0022 G_loss: 0.2020 D_A_loss: -12.2051  D_B_loss: -19.7538\n[18500/20000] adv_loss: 0.0318  recon_loss: 0.1675 encoding_loss: 0.0028 G_loss: 0.2021 D_A_loss: -13.3307  D_B_loss: -20.6614\n[18600/20000] adv_loss: 0.0186  recon_loss: 0.1714 encoding_loss: 0.0030 G_loss: 0.1930 D_A_loss: -15.8012  D_B_loss: -21.8533\n[18700/20000] adv_loss: 0.0242  recon_loss: 0.1683 encoding_loss: 0.0029 G_loss: 0.1954 D_A_loss: -12.5730  D_B_loss: -20.4386\n[18800/20000] adv_loss: 0.0244  recon_loss: 0.1775 encoding_loss: 0.0022 G_loss: 0.2042 D_A_loss: -11.4722  D_B_loss: -19.9679\n[18900/20000] adv_loss: 0.0199  recon_loss: 0.1745 encoding_loss: 0.0027 G_loss: 0.1971 D_A_loss: -12.9563  D_B_loss: -21.3559\n[19000/20000] adv_loss: 0.0217  recon_loss: 0.1667 encoding_loss: 0.0025 G_loss: 0.1909 D_A_loss: -12.7221  D_B_loss: -20.4991\n[19100/20000] adv_loss: 0.0237  recon_loss: 0.1850 encoding_loss: 0.0032 G_loss: 0.2119 D_A_loss: -13.4279  D_B_loss: -20.2572\n[19200/20000] adv_loss: 0.0220  recon_loss: 0.1679 encoding_loss: 0.0031 G_loss: 0.1930 D_A_loss: -13.5769  D_B_loss: -20.8411\n[19300/20000] adv_loss: 0.0236  recon_loss: 0.1686 encoding_loss: 0.0021 G_loss: 0.1944 D_A_loss: -13.0230  D_B_loss: -21.0651\n[19400/20000] adv_loss: 0.0185  recon_loss: 0.1676 encoding_loss: 0.0023 G_loss: 0.1884 D_A_loss: -12.7316  D_B_loss: -20.0561\n[19500/20000] adv_loss: 0.0251  recon_loss: 0.1667 encoding_loss: 0.0028 G_loss: 0.1945 D_A_loss: -11.9865  D_B_loss: -19.7757\n[19600/20000] adv_loss: 0.0233  recon_loss: 0.1696 encoding_loss: 0.0031 G_loss: 0.1960 D_A_loss: -12.4942  D_B_loss: -20.7676\n[19700/20000] adv_loss: 0.0235  recon_loss: 0.1716 encoding_loss: 0.0026 G_loss: 0.1976 D_A_loss: -12.1943  D_B_loss: -19.8476\n[19800/20000] adv_loss: 0.0226  recon_loss: 0.1637 encoding_loss: 0.0026 G_loss: 0.1889 D_A_loss: -12.0065  D_B_loss: -19.6304\n[19900/20000] adv_loss: 0.0239  recon_loss: 0.1671 encoding_loss: 0.0023 G_loss: 0.1933 D_A_loss: -12.6808  D_B_loss: -19.5891\n[20000/20000] adv_loss: 0.0189  recon_loss: 0.1697 encoding_loss: 0.0018 G_loss: 0.1903 D_A_loss: -12.6852  D_B_loss: -19.4677\nTraining finished.\n</code></pre> <pre><code>gan.D_A.load_state_dict(torch.load(\"../data/gan_da_rat.pt\"))\ngan.D_B.load_state_dict(torch.load(\"../data/gan_db_rat.pt\"))\ngan.G_A.load_state_dict(torch.load(\"../data/gan_ga_rat.pt\"))\ngan.G_B.load_state_dict(torch.load(\"../data/gan_gb_rat.pt\"))\ngan.G_B.load_state_dict(torch.load(\"../data/gan_gb_rat.pt\"))\ngan.E.load_state_dict(torch.load(\"../data/gan_e_rat.pt\"))\n</code></pre> <pre><code>&lt;All keys matched successfully&gt;\n</code></pre> <pre><code>ctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\npred = gan.predict(control_adata=ctrl_adata,\n                   cell_type_key=\"species\",\n                   condition_key=\"condition\")\npred.obs[\"condition\"] = 'pred'\ntreat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\neval_adata3 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata3.obs[\"condition\"]:\n    if i == 'unst':\n        treatments.append(\"Control\")\n    elif i == \"LPS6\":\n        treatments.append(\"LPS6\")\n    else:\n        treatments.append(\"scPreGAN\")\neval_adata3.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata3)\nsc.pl.pca(eval_adata3, color = \"Treatment\", frameon = True, title = \"\", save = \"SF8B3.svg\")\nCD4T = adata[adata.obs[\"species\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"]\nr2_value = vae.reg_mean_plot(\neval_adata3,\naxis_keys={\"x\": \"pred\", \"y\": \"LPS6\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF8C3.svg\",\nshow=True,\nlegend=False, title = \"scPreGAN\")\n</code></pre> <pre><code>Predicting data finished\nWARNING: saving figure to file ../figures/pcaSF8B3.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#cellot-prediction","title":"CellOT Prediction","text":"<pre><code>cellot_dir = \"../data/cellot-pred\"\npred = sc.read_h5ad(f\"{cellot_dir}/holdout-rat/model-cellot/evals_ood_data_space/imputed.h5ad\")\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\ntreat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\n\neval_adata4 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata4.obs[\"condition\"]:\n    if i == 'unst':\n        treatments.append(\"Control\")\n    elif i == \"LPS6\":\n        treatments.append(\"LPS6\")\n    else:\n        treatments.append(\"cellOT\")\neval_adata4.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata4)\nsc.pl.pca(eval_adata4, color = \"Treatment\", frameon = True, title = \"\", save = \"SF8B3.svg\")\nCD4T = adata[adata.obs[\"species\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"LPS6\"]\nr2_value = vae.reg_mean_plot(\neval_adata4,\naxis_keys={\"x\": \"pred\", \"y\": \"LPS6\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF8C3.svg\",\nshow=True,\nlegend=False, title = \"cellOT\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/pcaSF8B3.svg\n</code></pre>"},{"location":"tutorials/SupplementalFigure8/#supplementary-figure-8c","title":"Supplementary Figure 8C","text":"<pre><code># df_list = []\n# for cell in [\"rat\", \"rabbit\", \"pig\"]:\n#     print(cell)\n#     train_adata, test_adata = prepare_data(adata, \"species\", \"condition\", cell, \"LPS6\", normalized = True)\n\n#     vae = VIDR(train_adata, linear_decoder = False)\n# #     vae.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     vae.save(f\"../../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt\")\n#     vae = vae.load(f\"../../data/VAE_Species_Prediction_LPS_7000g_{cell}.pt/\", train_adata)\n\n#     vae_name = \"scGen\"\n\n#     ctrl_key = \"unst\"\n#     treat_key = \"LPS6\"\n\n#     cell_type_to_predict = cell\n#     cell_type_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_labels\"][\n#         \"original_key\"\n#     ]\n#     treatment_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_batch\"][\n#         \"original_key\"\n#     ]\n\n#     vae.adata.obs[\"species_condition\"] = adata.obs.species.astype(str) + adata.obs.condition.astype(str)\n\n#     adata_bal = random_sample(vae.adata, \"species_condition\", \"min\")\n#     adata_bal_ctrl = adata_bal[(adata_bal.obs[cell_type_key] == cell_type_to_predict) &amp; (adata_bal.obs[treatment_key] == ctrl_key)]\n#     latent_bal =  vae.get_latent_representation(adata_bal)\n#     latent_bal_adata = sc.AnnData(X=latent_bal, obs = adata_bal.obs.copy())\n#     latent_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_type_to_predict) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n\n#     latent_mouse_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == \"mouse\") &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n#     latent_mouse_trt = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == \"mouse\") &amp; (latent_bal_adata.obs[treatment_key] == treat_key)].X\n\n#     scgen_treat_delta = np.average(latent_mouse_trt,axis=0) - np.average(latent_mouse_cd,axis=0)\n#     scgen_species_delta = np.average(latent_cd,axis=0) - np.average(latent_mouse_cd,axis=0)\n\n#     treat_pred = 0.5*(scgen_species_delta + latent_mouse_trt + scgen_treat_delta + latent_cd)\n#     predicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\n#     pred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\n\n\n#     pred.obs[\"condition\"] = 'pred'\n#     ctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\n#     treat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\n#     eval_adata = ctrl_adata.concatenate(treat_adata, pred)\n\n#     CD4T = adata[adata.obs[\"species\"] ==cell]\n#     sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n#     diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][treat_key]\n\n#     r2_df = calculate_r2_singledose(\n#         eval_adata, cell,\n#         vae_name, \n#         \"condition\", \n#         {\"x\":\"pred\", \"y\":\"LPS6\"}, \n#         diff_genes=None, \n#         random_sample_coef = 0.8,\n#         n_iter = 100\n#     )\n#     df_list.append(r2_df)\n</code></pre> <pre><code>rat\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\nrabbit\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m55007\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m55007\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\npig\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m57308\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m57308\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\n</code></pre> <pre><code># for cell in [\"rat\", \"rabbit\", \"pig\"]:\n#     print(cell)\n#     train_adata, test_adata = prepare_data(adata, \"species\", \"condition\", cell, \"LPS6\", normalized = True)\n\n#     vae = VIDR(train_adata, linear_decoder = False)\n# #     vae.train(\n# #     max_epochs=100,\n# #     batch_size=128,\n# #     early_stopping=True,\n# #     early_stopping_patience=25)\n\n# #     vae.save(f\"../../data/VAE_Binary_Prediction_IFNB_7000g_{cell}.pt\")\n#     vae = vae.load(f\"../../data/VAE_Species_Prediction_LPS_7000g_{cell}.pt/\", train_adata)\n\n#     vae_name = \"scVIDR\"\n\n#     ctrl_key = \"unst\"\n#     treat_key = \"LPS6\"\n\n#     cell_type_to_predict = cell\n#     cell_type_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_labels\"][\n#         \"original_key\"\n#     ]\n#     treatment_key = vae.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_batch\"][\n#         \"original_key\"\n#     ]\n\n#     vae.adata.obs[\"species_condition\"] = adata.obs.species.astype(str) + adata.obs.condition.astype(str)\n\n#     adata_bal = random_sample(vae.adata, \"species_condition\", \"min\")\n#     adata_bal_ctrl = adata_bal[(adata_bal.obs[cell_type_key] == cell_type_to_predict) &amp; (adata_bal.obs[treatment_key] == ctrl_key)]\n#     latent_bal =  vae.get_latent_representation(adata_bal)\n#     latent_bal_adata = sc.AnnData(X=latent_bal, obs = adata_bal.obs.copy())\n#     latent_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_type_to_predict) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n\n#     #Get deltas and control centroids for each cell tpye in the training dataset\n#     deltas = []\n#     latent_centroids = []\n#     cell_types = np.unique(latent_bal_adata.obs[cell_type_key])\n#     for cell_i in cell_types:\n#         if cell_i != cell_type_to_predict:\n#             latent_ctrl = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n#             latent_treat = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == treat_key)].X\n#             deltas_i = np.average(latent_treat, axis = 0) - np.average(latent_ctrl, axis = 0)\n#             deltas.append(deltas_i)\n#             latent_centroids.append(np.average(latent_ctrl, axis = 0))\n#     lr = LinearRegression()\n#     reg = lr.fit(latent_centroids, deltas)\n#     scvidr_delta = reg.predict([np.average(latent_cd, axis = 0)])[0]\n\n#     treat_pred = scvidr_delta + latent_cd\n#     predicted_cells = vae.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\n#     pred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\n\n#     pred.obs[\"condition\"] = 'pred'\n#     ctrl_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"unst\"))]\n#     treat_adata = adata[((adata.obs['species'] == cell) &amp; (adata.obs[\"condition\"] == \"LPS6\"))]\n#     eval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\n\n#     CD4T = adata[adata.obs[\"species\"] ==cell]\n#     sc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\n#     diff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][treat_key]\n\n#     r2_df = calculate_r2_singledose(\n#         eval_adata2, cell,\n#         vae_name, \n#         \"condition\", \n#         {\"x\":\"pred\", \"y\":treat_key}, \n#         diff_genes=None, \n#         random_sample_coef = 0.8,\n#         n_iter = 100\n#     )\n#     df_list.append(r2_df)\n</code></pre> <pre><code>rat\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m52691\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\nrabbit\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m55007\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m55007\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\npig\n\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"species\"\u001b[0m\u001b[1m]\u001b[0m                                                                    \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m57308\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.                                                \nNone\n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m57308\u001b[0m cells, \u001b[1;36m6619\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m4\u001b[0m labels, and \u001b[1;36m0\u001b[0m      \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \nNone\n</code></pre> <pre><code># r2_values_allCells_df = pd.concat(df_list)\n</code></pre> <pre><code># r2_values_allCells_df.to_csv(\"../data/Species_Model_Results.csv\")\n</code></pre> <pre><code># r2_values_allCells_df = pd.read_csv(\"../data/Species_Model_Results.csv\")\n</code></pre> <pre><code># r2_df_hvgs = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"All HVGs\"]\n</code></pre> <pre><code># r2_df_hvgs = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"All HVGs\"]\n</code></pre> <pre><code># order = ['scVIDR', 'scGen',]# 'scPreGAN', \"CellOT\"]\n# hue_order = [\"rat\", \"rabbit\", \"pig\"]\n# ax = sns.boxplot(x = \"Model\", y = \"R^2\",  data = r2_df_hvgs, hue = \"Cell\", order = order, hue_order = hue_order)\n# pairs = [\n#     (('scVIDR','rat'), ('scGen', 'rat')),\n#     (('scVIDR', 'rabbit'), ('scGen', 'rabbit')),\n#     (('scVIDR', 'pig'), ('scGen', 'pig'))\n# #    (('scVIDR','All HVGs'), ('scPreGAN', 'All HVGs')),\n# #    (('scVIDR','DEGs'), ('scPreGAN', 'DEGs')),\n# #    (('scVIDR', 'All HVGs'), ('CellOT', 'All HVGs')),\n# #    (('scVIDR', 'DEGs'), ('CellOT', 'DEGs'))\n# ]\n# annotator = Annotator(ax, pairs, data=r2_df_hvgs, x=\"Model\", y=\"R^2\", hue = \"Cell\", order = order)\n# annotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\n# annotator.apply_and_annotate()\n# plt.ylabel(r\"$R^2$ All HVGs\")\n# plt.savefig(\"../figures/SF8D.svg\", bbox_inches = \"tight\")\n# plt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\nscVIDR_pig vs. scGen_pig: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=0.000e+00\nscVIDR_rat vs. scGen_rat: Mann-Whitney-Wilcoxon test greater, P_val:1.281e-34 U_stat=1.000e+04\nscVIDR_rabbit vs. scGen_rabbit: Mann-Whitney-Wilcoxon test greater, P_val:1.281e-34 U_stat=1.000e+04\n</code></pre> <pre><code># r2_df_degs = r2_values_allCells_df[r2_values_allCells_df[\"Gene Set\"] == \"DEGs\"]\n</code></pre> <pre><code># order = ['scVIDR', 'scGen',]# 'scPreGAN', \"CellOT\"]\n# hue_order = [\"rat\", \"rabbit\", \"pig\"]\n# ax = sns.boxplot(x = \"Model\", y = \"R^2\",  data = r2_df_degs, hue = \"Cell\", order = order, hue_order = hue_order)\n# pairs = [\n#     (('scVIDR','rat'), ('scGen', 'rat')),\n#     (('scVIDR', 'rabbit'), ('scGen', 'rabbit')),\n#     (('scVIDR', 'pig'), ('scGen', 'pig'))\n# #    (('scVIDR','All HVGs'), ('scPreGAN', 'All HVGs')),\n# #    (('scVIDR','DEGs'), ('scPreGAN', 'DEGs')),\n# #    (('scVIDR', 'All HVGs'), ('CellOT', 'All HVGs')),\n# #    (('scVIDR', 'DEGs'), ('CellOT', 'DEGs'))\n# ]\n# annotator = Annotator(ax, pairs, data=r2_df_degs, x=\"Model\", y=\"R^2\", hue = \"Cell\", order = order)\n# annotator.configure(test='Mann-Whitney-gt', text_format='star', loc='outside')\n# annotator.apply_and_annotate()\n# plt.ylabel(r\"$R^2$ All HVGs\")\n# plt.savefig(\"../figures/SF8D.svg\", bbox_inches = \"tight\")\n# plt.show()\n</code></pre> <pre><code>p-value annotation legend:\n      ns: p &lt;= 1.00e+00\n       *: 1.00e-02 &lt; p &lt;= 5.00e-02\n      **: 1.00e-03 &lt; p &lt;= 1.00e-02\n     ***: 1.00e-04 &lt; p &lt;= 1.00e-03\n    ****: p &lt;= 1.00e-04\n\nscVIDR_pig vs. scGen_pig: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=0.000e+00\nscVIDR_rat vs. scGen_rat: Mann-Whitney-Wilcoxon test greater, P_val:1.281e-34 U_stat=1.000e+04\nscVIDR_rabbit vs. scGen_rabbit: Mann-Whitney-Wilcoxon test greater, P_val:1.000e+00 U_stat=0.000e+00\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/SupplementalFigure9/","title":"SupplementalFigure9","text":"<pre><code>#Create Access to my code\nimport sys\nsys.path.insert(1, '../vidr/')\n\n#Import the vaedr functions we have created\nfrom vidr import VIDR\nfrom utils import *\n\n\n#Import important modules\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport torch\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy import linalg\nfrom scipy import spatial\nfrom anndata import AnnData\nfrom scipy import sparse\nfrom statannotations.Annotator import Annotator\nfrom matplotlib import pyplot as plt\n\nimport scvi\nsc.set_figure_params(dpi = 150)\nsc.settings.figdir = \"../figures/\"\nsns.set_style(\"dark\")\n</code></pre> <pre><code>adata = sc.read(\"../data/kang2018.h5ad\")\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/compat/__init__.py:232: FutureWarning: Moving element from .uns['neighbors']['distances'] to .obsp['distances'].\n\nThis is where adjacency matrices should go now.\n  warn(\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/compat/__init__.py:232: FutureWarning: Moving element from .uns['neighbors']['connectivities'] to .obsp['connectivities'].\n\nThis is where adjacency matrices should go now.\n  warn(\n</code></pre> <pre><code>adata = adata[((adata.obs[\"cell_type\"] == \"B\") | (adata.obs[\"cell_type\"] == \"CD4T\"))]\n</code></pre> <pre><code>#Training model\ncell = \"B\"\ntrain_adata, test_adata = prepare_data(adata, \"cell_type\", \"condition\", cell, \"stimulated\", normalized = True)\nmodel = VIDR(train_adata, linear_decoder = False)\nmodel.train(\nmax_epochs=100,\nbatch_size=128,\nearly_stopping=True,\nearly_stopping_patience=25)\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Using batches from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"condition\"\u001b[0m\u001b[1m]\u001b[0m                                                                 \n\u001b[34mINFO    \u001b[0m Using labels from adata.obs\u001b[1m[\u001b[0m\u001b[32m\"cell_type\"\u001b[0m\u001b[1m]\u001b[0m                                                                  \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m6382\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m2\u001b[0m labels, and \u001b[1;36m0\u001b[0m       \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.               \n\u001b[34mINFO    \u001b[0m Please do not further modify adata until model is trained.\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scvi/model/base/_base_model.py:149: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n\n\nNone\n\n\nGPU available: True, used: True\nTPU available: False, using: 0 TPU cores\nLOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3]\nSet SLURM handle signals.\n\n\nEpoch 29/100:  29%|\u2588\u2588\u2589       | 29/100 [00:30&lt;01:13,  1.04s/it, loss=98.8, v_num=1]\n</code></pre> <pre><code>model.save(f\"../../data/VAE_Binary_Prediction_IFNB_7000g_2cell.pt\", overwrite = True)\n</code></pre>"},{"location":"tutorials/SupplementalFigure9/#supplemental-figure-9a","title":"Supplemental Figure 9A","text":"<pre><code>#UMAP Projection of latent space\nlatent_X = model.get_latent_representation(adata)\nlatent_adata = sc.AnnData(X=latent_X, obs=adata.obs.copy())\ncell_condition = [f\"{j}_{str(i)}\" for (i,j) in zip(adata.obs[\"condition\"], adata.obs[\"cell_type\"])]\ntraining = [\"Train\" if i != cell+\"_stimulated\" else \"Test\" for i in cell_condition]\nlatent_adata.obs[\"Cell_Condition\"] = cell_condition\nlatent_adata.obs[\"Training Split\"] = training\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Received view of anndata, making copy.                                                                    \n\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup                                     \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m7375\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m2\u001b[0m labels, and \u001b[1;36m0\u001b[0m       \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scvi/model/base/_base_model.py:149: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre> <pre><code>sc.pp.neighbors(latent_adata)\nsc.tl.umap(latent_adata)\n</code></pre> <pre><code>WARNING: You\u2019re trying to run this on 100 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['cell_type', 'condition'], frameon=True,palette = \"tab10\", save =\"SF3A1.svg\", title = \"Cell Type\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/umapSF3A1.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['condition'], frameon=True, save =\"S3A2.svg\", title = \"Condition\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/umapS3A2.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre> <pre><code>ax = sc.pl.umap(latent_adata, color=['Training Split'], frameon=True,palette=\"Dark2\", save =\"S3A3.svg\")\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/umapS3A3.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre>"},{"location":"tutorials/SupplementalFigure9/#supplemental-figure-3b","title":"Supplemental Figure 3B","text":"<pre><code>ctrl_key = \"control\"\ntreat_key = \"stimulated\"\ncell_type_to_predict = \"B\"\n</code></pre> <pre><code>cell_type_key = model.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_labels\"][\n    \"original_key\"\n]\ntreatment_key = model.scvi_setup_dict_[\"categorical_mappings\"][\"_scvi_batch\"][\n    \"original_key\"\n]\n</code></pre> <pre><code>ctrl_x = model.adata[model.adata.obs[treatment_key] == ctrl_key]\ntreat_x = model.adata[model.adata.obs[treatment_key] == treat_key]\n</code></pre> <pre><code>#Balancing across treatments \nadata_bal = ctrl_x.concatenate(treat_x)\nadata_bal = random_sample(adata_bal, treatment_key, max_or_min = \"min\", replacement = False)\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n</code></pre> <pre><code>#Getting control for validation \nadata_bal_ctrl = adata_bal[(adata_bal.obs[cell_type_key] == cell_type_to_predict) &amp; (adata_bal.obs[treatment_key] == ctrl_key)]\n\n#Getting latent representations\nlatent_bal =  model.get_latent_representation(adata_bal)\nlatent_bal_adata = sc.AnnData(X=latent_bal, obs = adata_bal.obs.copy())\nlatent_cd = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_type_to_predict) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n</code></pre> <pre><code>\u001b[34mINFO    \u001b[0m Input adata not setup with scvi. attempting to transfer anndata setup                                     \n\u001b[34mINFO    \u001b[0m Using data from adata.X                                                                                   \n\u001b[34mINFO    \u001b[0m Computing library size prior per batch                                                                    \n\u001b[34mINFO    \u001b[0m Registered keys:\u001b[1m[\u001b[0m\u001b[32m'X'\u001b[0m, \u001b[32m'batch_indices'\u001b[0m, \u001b[32m'local_l_mean'\u001b[0m, \u001b[32m'local_l_var'\u001b[0m, \u001b[32m'labels'\u001b[0m\u001b[1m]\u001b[0m                           \n\u001b[34mINFO    \u001b[0m Successfully registered anndata object containing \u001b[1;36m6254\u001b[0m cells, \u001b[1;36m6998\u001b[0m vars, \u001b[1;36m2\u001b[0m batches, \u001b[1;36m2\u001b[0m labels, and \u001b[1;36m0\u001b[0m       \n         proteins. Also registered \u001b[1;36m0\u001b[0m extra categorical covariates and \u001b[1;36m0\u001b[0m extra continuous covariates.\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scvi/model/base/_base_model.py:149: UserWarning: Make sure the registered X field in anndata contains unnormalized count data.\n  warnings.warn(\n</code></pre> <pre><code>#No regression on latent space\nctrl_x = latent_bal_adata[(latent_bal_adata.obs[treatment_key] == ctrl_key) &amp; ~(latent_bal_adata.obs[cell_type_key] == cell_type_to_predict)].X.copy()\ntreat_x = latent_bal_adata[latent_bal_adata.obs[treatment_key] == treat_key].X.copy()\n\n#Find scGen delta\nlatent_ctrl = np.average(ctrl_x, axis = 0)\nlatent_treat = np.average(treat_x, axis = 0)\nscgen_delta = latent_treat - latent_ctrl\n</code></pre> <pre><code>#Get deltas and control centroids for each cell tpye in the training dataset\ndeltas = []\nlatent_centroids = []\ncell_types = np.unique(adata_bal.obs[cell_type_key])\nfor cell_i in cell_types:\n    if cell_i != cell_type_to_predict:\n        latent_ctrl = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == ctrl_key)].X\n        latent_treat = latent_bal_adata[(latent_bal_adata.obs[cell_type_key] == cell_i) &amp; (latent_bal_adata.obs[treatment_key] == treat_key)].X\n        deltas_i = np.average(latent_treat, axis = 0) - np.average(latent_ctrl, axis = 0)\n        deltas.append(deltas_i)\n        latent_centroids.append(np.average(latent_ctrl, axis = 0))\nlr = LinearRegression()\nreg = lr.fit(latent_centroids, deltas)\nscvidr_delta = reg.predict([np.average(latent_cd, axis = 0)])[0]\n</code></pre>"},{"location":"tutorials/SupplementalFigure9/#scvidr-results","title":"scVIDR Results","text":"<pre><code>#Predict scVIDR results\ntreat_pred = scgen_delta + latent_cd\npredicted_cells = model.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\npred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\npred.obs[\"condition\"] = 'pred'\n\n\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\ntreat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\neval_adata1 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata1.obs[\"condition\"]:\n    if i == \"control\":\n        treatments.append(\"Control\")\n    elif i == \"stimulated\":\n        treatments.append(r\"IFN$\\beta$\")\n    else:\n        treatments.append(\"scGen\")\neval_adata1.obs[\"Treatment\"] = treatments\n\n#PCA Projection\nsc.tl.pca(eval_adata1)\nsc.pl.pca(eval_adata1, color = \"Treatment\", frameon = True, title = \"\", save = \"SF9B.svg\")\n\n#Regression Plot\nCD4T = adata[adata.obs[\"cell_type\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\nr2_value = model.reg_mean_plot(\neval_adata1,\naxis_keys={\"x\": \"pred\", \"y\": r\"stimulated\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/SF9C1.svg\",\nshow=True,\nlegend=False, title = \"scGen\")\nprint(r2_value)\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n\n\nWARNING: saving figure to file ../figures/pcaSF9B.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/compat/_overloaded_dict.py:106: ImplicitModificationWarning: Trying to modify attribute `._uns` of view, initializing view as actual.\n  self.data[key] = value\n</code></pre> <pre><code>(0.9138199316591675, 0.816085990613895)\n</code></pre> <pre><code>#Predict scVIDR results\ntreat_pred = scvidr_delta + latent_cd\npredicted_cells = model.module.generative(torch.Tensor(treat_pred))[\"px\"].cpu().detach().numpy()\npred = sc.AnnData(X=predicted_cells , obs=adata_bal_ctrl.obs.copy(), var=adata_bal_ctrl.var.copy(),obsm=adata_bal_ctrl.obsm.copy(),)\n\npred.obs[\"condition\"] = 'pred'\nctrl_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"control\"))]\ntreat_adata = adata[((adata.obs['cell_type'] == cell) &amp; (adata.obs[\"condition\"] == \"stimulated\"))]\neval_adata2 = ctrl_adata.concatenate(treat_adata, pred)\ntreatments = []\nfor i in eval_adata2.obs[\"condition\"]:\n    if i == \"control\":\n        treatments.append(\"Control\")\n    elif i == \"stimulated\":\n        treatments.append(r\"IFN$\\beta$\")\n    else:\n        treatments.append(\"scVIDR\")\neval_adata2.obs[\"Treatment\"] = treatments\nsc.tl.pca(eval_adata2)\nsc.pl.pca(eval_adata2, color = \"Treatment\", frameon = True, title = \"\", save = \"sup3C1.svg\")\nCD4T = adata[adata.obs[\"cell_type\"] ==cell]\nsc.tl.rank_genes_groups(CD4T, groupby=\"condition\", method=\"wilcoxon\")\ndiff_genes = CD4T.uns[\"rank_genes_groups\"][\"names\"][\"stimulated\"]\nr2_value = model.reg_mean_plot(\neval_adata2,\naxis_keys={\"x\": \"pred\", \"y\": r\"stimulated\"},\ngene_list=diff_genes[:10],\ntop_100_genes = diff_genes[:100],\nlabels={\"x\": \"Predicted Expression\", \"y\": \"Real Expression\"},\npath_to_save=\"../figures/S3B2.svg\",\nshow=True,\nlegend=False, title = \"scVIDR\")\nprint(r2_value)\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n\n\nWARNING: saving figure to file ../figures/pcasup3C1.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/compat/_overloaded_dict.py:106: ImplicitModificationWarning: Trying to modify attribute `._uns` of view, initializing view as actual.\n  self.data[key] = value\n</code></pre> <pre><code>(0.9138199316591675, 0.816085990613895)\n</code></pre>"},{"location":"tutorials/SupplementalFigure9/#supplemental-figure-3c","title":"Supplemental Figure 3C","text":"<pre><code>eval_list  = [eval_adata2[eval_adata2.obs.Treatment == \"scVIDR\"],\n             ]\neval_adata = eval_adata1.concatenate(eval_list)\n</code></pre> <pre><code>/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/anndata/_core/anndata.py:1785: FutureWarning: X.dtype being converted to np.float32 from float64. In the next version of anndata (0.9) conversion will not be automatic. Pass dtype explicitly to avoid this warning. Pass `AnnData(X, dtype=X.dtype, ...)` to get the future behavour.\n  [AnnData(sparse.csr_matrix(a.shape), obs=a.obs) for a in all_adatas],\n</code></pre> <pre><code>sc.tl.pca(eval_adata)\nsc.pl.pca(eval_adata, color = \"Treatment\", frameon = True, title = \"\", save = \"S3C.svg\", alpha = 0.5)\n</code></pre> <pre><code>WARNING: saving figure to file ../figures/pcaS3C.svg\n\n\n/mnt/ufs18/home-091/kanaomar/mambaforge/envs/scVIDR/lib/python3.8/site-packages/scanpy/plotting/_tools/scatterplots.py:392: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/tutorials-introduction/","title":"Tutorial: Getting Started with scVIDR","text":"<p>scVIDR (Single Cell Variational Inference of Dose Response) is a computational framework designed to predict gene expression changes in single cells following chemical perturbations. By leveraging variational autoencoders, scVIDR captures dose-dependent responses across diverse cell types. This innovative approach empowers researchers to anticipate how individual cells react to different chemical exposures, making it a valuable tool in fields like pharmacology and toxicology.</p> <p>These tutorials will guide you through scVIDR's features, from dataset preparation to advanced dose-response modeling, enabling you to harness its capabilities for your research.</p>"},{"location":"tutorials/tutorials-introduction/#installation","title":"Installation","text":"<p>To ensure a smooth experience with SCVIDR, we have built a pre-configured Docker container that includes SCVIDR and all its dependencies. This eliminates compatibility issues and provides a stable environment for analysis.</p> <p>If you haven't set up SCVIDR yet, please follow the steps outlined in the Installation Guide. The guide includes detailed instructions on downloading and running the Docker container, so you can get started quickly.</p>"},{"location":"tutorials/tutorials-introduction/#input-data","title":"Input Data","text":"<p>Several datasets were used in the analysis, but we highlight the key datasets below:</p> <ul> <li> <p>TCDD Liver Dose-Response Dataset:</p> <ul> <li>Source: Nault et al.</li> <li>Accession Number: GSE184506 (Gene Expression Omnibus).</li> <li>Description: Single-nucleus RNA-seq (snRNA-seq) of flash-frozen mouse livers treated subchronically with TCDD every 4 days for 28 days, Immune cells were excluded due to known migration to the liver during TCDD administration.</li> </ul> </li> <li> <p>IFN-\u03b3 PBMC Dataset:</p> <ul> <li>Source: Kang et al.</li> <li>Accession Number: GSE96583 (Gene Expression Omnibus).</li> <li>Description: Single-cell PBMC dataset examining interferon-gamma (IFN-\u03b3) perturbations.</li> </ul> </li> <li> <p>Study B Data:</p> <ul> <li>Source: Zheng et al.</li> <li>Accession Number: SRP073767 (Sequence Read Archive).</li> <li>Description: Dataset used for cross-experiment predictions of single-cell RNA-seq data.</li> </ul> </li> <li> <p>LPS6 Species Dataset:</p> <ul> <li>Source: Hagai et al.</li> <li>Accession Number: E-MTAB-5919 (BioSciences).</li> <li>Description: Dataset used for cross-species perturbation predictions.</li> </ul> </li> <li> <p>Sci-Plex Chemical Transcriptomics Dataset:</p> <ul> <li>Source: Srivatsan et al.</li> <li>Accession Number: DOI 10.1126/science.aax6234 (BioSciences).</li> <li>Description: scRNA-seq of A549, K562, and MCF7 cells treated with 188 compounds at four doses (24 h).</li> </ul> </li> </ul>"},{"location":"tutorials/tutorials-introduction/#preprocessing","title":"Preprocessing","text":"<p>The cell expression vectors were normalized to the median total expression counts for each cell to ensure consistency across cells. This normalization step was carried out using the <code>scanpy.pp.normalize_total</code> function.</p> <p>Following normalization, cell counts were log-transformed with a pseudo-count of 1. This transformation reduces skewness and normalizes the data distribution. The transformation was implemented using the <code>scanpy.pp.log1p</code> function.</p> <p>To focus the analysis on the most informative features, the top 5,000 highly variable genes (HVGs) were selected. This step was performed using the <code>scanpy.pp.highly_variable</code> function, ensuring that the analysis prioritizes biologically relevant variations.</p> <p>Batch effects across different experiments and datasets were accounted for using the <code>scvi.data.setup_anndata</code> function. This adjustment ensures that technical variability does not obscure meaningful biological signals.</p> <p>Finally, differential abundances of cells across groups were handled through a balancing process. Random sampling with replacement was applied for dose groups to equalize representation, while random sampling without replacement was used to balance cell types.</p>"},{"location":"tutorials/tutorials-introduction/#index","title":"Index","text":""},{"location":"tutorials/tutorials-introduction/#examples-of-scvidr-applied-to-datasets","title":"Examples of scVIDR Applied to Datasets","text":""},{"location":"tutorials/tutorials-introduction/#prediction-of-in-vivo-single-cell-gene-expression-of-portal-hepatocytes","title":"Prediction of In Vivo Single-Cell Gene Expression of Portal Hepatocytes","text":"<ol> <li>UMAP Projection of Latent Space</li> <li>PCA Plots Comparing Prediction Models</li> <li>Regression Analysis with Predicted Data</li> <li>Comparison of Gene Expression Across Treatments</li> <li>Comprehensive Analysis of Gene Expression Predictions Across Cell Types</li> </ol>"},{"location":"tutorials/tutorials-introduction/#prediction-of-in-vivo-tcdd-dose-response-across-cell-types","title":"Prediction of In Vivo TCDD Dose-Response Across Cell Types","text":"<ol> <li>Regression and Evaluation Across TCDD Doses</li> <li>UMAP Visualization of Dose-Response</li> <li>Dose-Response Prediction for Portal Hepatocytes</li> <li>Comparison of Prediction Accuracy Across All Cell Types</li> <li>Regression Analysis of Predicted Gene Expression</li> <li>Non-Regression Analysis of Predicted Gene Expression Across Doses</li> <li>Dose-Response Prediction for Ahrr Gene</li> </ol>"},{"location":"tutorials/tutorials-introduction/#interrogation-of-vae-using-ridge-regression-in-portal-hepatocyte-response-prediction","title":"Interrogation of VAE Using Ridge Regression in Portal Hepatocyte Response Prediction","text":"<ol> <li>Ridge Regression Analysis on Latent Representations</li> <li>Visualization of Top Gene Scores</li> <li>Gene Enrichment Analysis and Visualization</li> <li>Gene Enrichment Analysis and Visualization</li> <li>Logistic Fit of Median Pathway Scores</li> </ol>"},{"location":"tutorials/tutorials-introduction/#pseudo-dose-ordering-of-hepatocytes-across-tcdd-dose-response","title":"Pseudo-Dose Ordering of Hepatocytes Across TCDD Dose-Response","text":"<ol> <li>Training VIDR Model for Hepatocyte Dose Response Prediction</li> <li>Calculating Pseudodose and Preparing PCA Data</li> <li>Orthogonal Projection of Hepatocytes onto the Pseudo-Dose Axis</li> <li>Pseudo-Dose Visualization in PCA Space</li> <li>Pseudo-Dose vs. Fmo3 Expression</li> <li>Pseudo-Dose vs. Log Dose</li> <li>PCA of Hepatocyte Zones</li> <li>Pseudo-Dose Distribution Across Hepatocyte Zones</li> </ol>"},{"location":"tutorials/tutorials-introduction/#workflow-for-using-scvidr-command-line-tools","title":"Workflow for Using scVIDR Command-Line Tools","text":""},{"location":"tutorials/tutorials-introduction/#vae-model-training-single-and-multi-dose-models","title":"VAE Model Training (Single- and Multi- Dose Models)","text":""},{"location":"tutorials/tutorials-introduction/#overview","title":"Overview","text":"<p>To train a single dose VAE model, use the <code>scvidr_train.py single_dose</code> command (Figure 2 of the manuscript).</p> <p>To train a multi dose VAE model, use the <code>scvidr_train.py multi_dose</code> command (Figure 3 of the manuscript).</p> <p>Both types of models require an AnnData file in the <code>h5ad</code> format as input. This file should include scRNAseq data along with an observation table (<code>obs</code>) containing a dose and a cell type column. The single dose model expects at least two distinct doses, while the multi dose model expects at least three.</p>"},{"location":"tutorials/tutorials-introduction/#command-arguments","title":"Command Arguments","text":"<p>The arguments for both models are the same and are listed below:</p> <pre><code>usage: scvidr_train.py {single_dose/multi_dose} [-h] [--dose_column DOSE_COLUMN]\n                                               [--celltype_column CELLTYPE_COLUMN]\n                                               [--test_celltype TEST_CELLTYPE]\n                                               [--control_dose CONTROL_DOSE]\n                                               [--treated_dose TREATED_DOSE]\n                                               [--celltypes_keep CELLTYPES_KEEP] \n                                               h5ad_data_file model_path\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#positional-arguments","title":"Positional Arguments:","text":"<ul> <li><code>h5ad_data_file</code>: Path to the data file containing the raw reads in <code>h5ad</code> format.</li> <li><code>model_path</code>: Path to the directory where the trained model will be saved.</li> </ul>"},{"location":"tutorials/tutorials-introduction/#optional-arguments","title":"Optional Arguments:","text":"<ul> <li><code>-h, --help</code>: Show this help message and exit.</li> <li><code>--dose_column DOSE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the dose (default <code>\"Dose\"</code>).</li> <li><code>--celltype_column CELLTYPE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the cell type (default <code>\"celltype\"</code>).</li> <li><code>--test_celltype TEST_CELLTYPE</code>: Name of the cell type to leave out for testing. Use quotes for names with spaces (default <code>\"Hepatocytes - portal\"</code>).</li> <li><code>--control_dose CONTROL_DOSE</code>: Value of the control dose (default <code>\"0\"</code>).</li> <li><code>--treated_dose TREATED_DOSE</code>: Value of the treated dose (default <code>\"30\"</code>).</li> <li><code>--celltypes_keep CELLTYPES_KEEP</code>: Specify cell types to keep in the dataset for training/testing. Provide either a file with one cell type per line or a semicolon-separated list (default <code>\"ALL\"</code>).</li> </ul>"},{"location":"tutorials/tutorials-introduction/#example-usage","title":"Example Usage","text":""},{"location":"tutorials/tutorials-introduction/#single-dose-model-training","title":"Single Dose Model Training:","text":"<p>To train all single dose models for individual cell types as used in the manuscript:</p> <pre><code>python scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Hepatocytes - portal\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Hepatocytes - portal.pt/\"\npython scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Hepatocytes - central\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Hepatocytes - central.pt/\"\npython scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Cholangiocytes\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Cholangiocytes.pt/\"\npython scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Stellate Cells\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Stellate Cells.pt/\"\npython scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Portal Fibroblasts\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Portal Fibroblasts.pt/\"\npython scvidr_train.py single_dose --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Endothelial Cells\" ../data/nault2021_singleDose.h5ad \"../data/VAE_Binary_Prediction_Dioxin_5000g_Endothelial Cells.pt/\"\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#multi-dose-model-training","title":"Multi Dose Model Training:","text":"<p>To train all multi dose models for individual cell types as used in the manuscript:</p> <pre><code>python scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Hepatocytes - central\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Hepatocytes - central.pt/\"\npython scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Hepatocytes - portal\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Hepatocytes - portal.pt/\"\npython scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Cholangiocytes\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Cholangiocytes.pt/\"\npython scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Stellate Cells\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Stellate Cells.pt/\"\npython scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Portal Fibroblasts\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Portal Fibroblasts.pt/\"\npython scvidr_train.py multi_dose --control_dose 0.0 --celltypes_keep ../metadata/liver_celltypes --test_celltype \"Endothelial Cells\" ../data/nault2021_multiDose.h5ad \"../data/VAE_Cont_Prediction_Dioxin_5000g_Endothelial Cells.pt/\"\n</code></pre> <p>Note: Pretrained models corresponding to these commands are available under the specified paths.</p>"},{"location":"tutorials/tutorials-introduction/#scvidr-prediction-workflow","title":"scVIDR Prediction Workflow","text":"<p>The <code>scvidr_predict.py</code> script allows you to use a trained scVIDR model to predict treatment conditions for single-dose or multi-dose datasets. Below are the details for using this script.</p>"},{"location":"tutorials/tutorials-introduction/#single-dose-model-prediction","title":"Single-Dose Model Prediction","text":""},{"location":"tutorials/tutorials-introduction/#usage","title":"Usage","text":"<pre><code>scvidr_predict.py single_dose [-h] [--model MODEL]\n                              [--dose_column DOSE_COLUMN]\n                              [--celltype_column CELLTYPE_COLUMN]\n                              [--test_celltype TEST_CELLTYPE]\n                              [--control_dose CONTROL_DOSE]\n                              [--treated_dose TREATED_DOSE]\n                              [--celltypes_keep CELLTYPES_KEEP]\n                              h5ad_data_file model_path output_path\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#description","title":"Description","text":"<p>Predict treatment conditions using a pretrained scVIDR or scGEN model.</p>"},{"location":"tutorials/tutorials-introduction/#positional-arguments_1","title":"Positional Arguments","text":"<ul> <li><code>h5ad_data_file</code>: The data file containing the raw reads in h5ad format.</li> <li><code>model_path</code>: Path to the directory where the trained model was saved during the model training step.</li> <li><code>output_path</code>: Path to the directory where the predicted AnnData will be saved in an h5ad format.</li> </ul>"},{"location":"tutorials/tutorials-introduction/#optional-arguments_1","title":"Optional Arguments","text":"<ul> <li><code>--model MODEL</code>: Specify whether to use scVIDR or scGEN for prediction (default: <code>scVIDR</code>).</li> <li><code>--dose_column DOSE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the dose (default: <code>\"Dose\"</code>).</li> <li><code>--celltype_column CELLTYPE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the cell type (default: <code>\"celltype\"</code>).</li> <li><code>--test_celltype TEST_CELLTYPE</code>: Name of the cell type to be left out for testing. Use quotes for names with spaces (default: <code>\"Hepatocytes - portal\"</code>).</li> <li><code>--control_dose CONTROL_DOSE</code>: Control dose (default: <code>\"0\"</code>).</li> <li><code>--treated_dose TREATED_DOSE</code>: Treated dose (default: <code>\"30\"</code>).</li> <li><code>--celltypes_keep CELLTYPES_KEEP</code>: Specify the cell types to keep during training/testing. Provide either a file containing the list of cell types (one per line) or a semicolon-separated list (default: <code>\"ALL\"</code>).</li> </ul>"},{"location":"tutorials/tutorials-introduction/#example","title":"Example","text":"<pre><code>python scvidr_predict.py single_dose \\\n  ../data/nault2021_singleDose.h5ad \\\n  ../data/VAE_Binary_Prediction_Dioxin_5000g_Hepatocytes-portal.pt/ \\\n  ../data/SingleDose_TCDD \\\n  --model scVIDR \\\n  --dose_column Dose \\\n  --celltype_column celltype \\\n  --test_celltype \"Hepatocytes - portal\" \\\n  --control_dose 0 \\\n  --treated_dose 30 \\\n  --celltypes_keep ../metadata/liver_celltypes\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#multi-dose-model-prediction","title":"Multi-Dose Model Prediction","text":""},{"location":"tutorials/tutorials-introduction/#usage_1","title":"Usage","text":"<pre><code>scvidr_predict.py multi_dose [-h] [--model MODEL]\n                             [--dose_column DOSE_COLUMN]\n                             [--celltype_column CELLTYPE_COLUMN]\n                             [--test_celltype TEST_CELLTYPE]\n                             [--control_dose CONTROL_DOSE]\n                             [--treated_dose TREATED_DOSE]\n                             [--celltypes_keep CELLTYPES_KEEP]\n                             h5ad_data_file model_path output_path\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#description_1","title":"Description","text":"<p>Predict treatment conditions across multiple doses using a pretrained scVIDR or scGEN model.</p>"},{"location":"tutorials/tutorials-introduction/#positional-arguments_2","title":"Positional Arguments","text":"<ul> <li><code>h5ad_data_file</code>: The data file containing the raw reads in h5ad format.</li> <li><code>model_path</code>: Path to the directory where the trained model was saved during the model training step.</li> <li><code>output_path</code>: Path to the directory where the predicted AnnData will be saved in an h5ad format.</li> </ul>"},{"location":"tutorials/tutorials-introduction/#optional-arguments_2","title":"Optional Arguments","text":"<ul> <li><code>--model MODEL</code>: Specify whether to use scVIDR or scGEN for prediction (default: <code>scVIDR</code>).</li> <li><code>--dose_column DOSE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the dose (default: <code>\"Dose\"</code>).</li> <li><code>--celltype_column CELLTYPE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the cell type (default: <code>\"celltype\"</code>).</li> <li><code>--test_celltype TEST_CELLTYPE</code>: Name of the cell type to be left out for testing. Use quotes for names with spaces (default: <code>\"Hepatocytes - portal\"</code>).</li> <li><code>--control_dose CONTROL_DOSE</code>: Control dose (default: <code>\"0\"</code>).</li> <li><code>--treated_dose TREATED_DOSE</code>: Treated dose (default: <code>\"30\"</code>).</li> <li><code>--celltypes_keep CELLTYPES_KEEP</code>: Specify the cell types to keep during training/testing. Provide either a file containing the list of cell types (one per line) or a semicolon-separated list (default: <code>\"ALL\"</code>).</li> </ul>"},{"location":"tutorials/tutorials-introduction/#example_1","title":"Example","text":"<pre><code>python scvidr_predict.py multi_dose \\\n  ../data/nault2021_multiDose.h5ad \\\n  ../data/VAE_Cont_Prediction_Dioxin_5000g_Hepatocytes-portal.pt/ \\\n  ../data/MultiDose_TCDD \\\n  --model scVIDR \\\n  --dose_column Dose \\\n  --celltype_column celltype \\\n  --test_celltype \"Hepatocytes - portal\" \\\n  --control_dose 0.0 \\\n  --treated_dose 30.0 \\\n  --celltypes_keep ../metadata/liver_celltypes\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#notes","title":"Notes","text":"<ol> <li>The prediction scripts assume that the trained models are stored in the <code>model_path</code> directory.</li> <li>Ensure the <code>h5ad_data_file</code> contains the appropriate <code>dose</code> and <code>celltype</code> columns in the <code>obs</code> table.</li> <li>The output file will be an AnnData object saved in the specified <code>output_path</code>.</li> </ol>"},{"location":"tutorials/tutorials-introduction/#gene-score-calculation-using-scvidr","title":"Gene Score Calculation Using scVIDR","text":""},{"location":"tutorials/tutorials-introduction/#usage_2","title":"Usage","text":"<p>The <code>scvidr_genescores.py</code> script interprets scVIDR predictions using ridge regression and outputs gene scores in a CSV format.</p>"},{"location":"tutorials/tutorials-introduction/#command-line-arguments","title":"Command-Line Arguments","text":""},{"location":"tutorials/tutorials-introduction/#positional-arguments_3","title":"Positional Arguments","text":"<ul> <li><code>h5ad_data_file</code>: The data file containing the raw reads in h5ad format.</li> <li><code>model_path</code>: Path to the directory where the trained model was saved in the model training step.</li> <li><code>output_path</code>: Path to the directory where the gene scores will be saved as a CSV file.</li> </ul>"},{"location":"tutorials/tutorials-introduction/#optional-arguments_3","title":"Optional Arguments","text":"<ul> <li><code>--dose_column DOSE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the dose (default: <code>\"Dose\"</code>).</li> <li><code>--celltype_column CELLTYPE_COLUMN</code>: Name of the column in the <code>obs</code> dataframe representing the cell type (default: <code>\"celltype\"</code>).</li> <li><code>--test_celltype TEST_CELLTYPE</code>: Name of the cell type to be left out for testing. Use quotes for names with spaces (default: <code>\"Hepatocytes - portal\"</code>).</li> <li><code>--control_dose CONTROL_DOSE</code>: Control dose (default: <code>\"0\"</code>).</li> <li><code>--treated_dose TREATED_DOSE</code>: Treated dose (default: <code>\"30\"</code>).</li> <li><code>--celltypes_keep CELLTYPES_KEEP</code>: Specify the cell types to keep during training/testing. Provide either a file containing the list of cell types (one per line) or a semicolon-separated list (default: <code>\"ALL\"</code>).</li> <li><code>--training_size TRAINING_SIZE</code>: Number of samples generated from the latent distribution (default: <code>100000</code>).</li> </ul>"},{"location":"tutorials/tutorials-introduction/#example-command","title":"Example Command","text":"<pre><code>python scvidr_genescores.py \\\n  ../data/nault2021_multiDose.h5ad \\\n  ../data/VAE_Cont_Prediction_Dioxin_5000g_Hepatocytes-portal.pt \\\n  ../data/MultiDose_TCDD \\\n  --dose_column Dose \\\n  --celltype_column celltype \\\n  --test_celltype \"Hepatocytes - portal\" \\\n  --control_dose 0.0 \\\n  --treated_dose 30.0 \\\n  --celltypes_keep ../metadata/liver_celltypes\n</code></pre>"},{"location":"tutorials/tutorials-introduction/#notes_1","title":"Notes","text":"<p>Ensure that the required data is preprocessed, and a pre-trained model is available before running the script.</p>"}]}